{"title":"一致性Hash原理与实现","date":"2023-10-25T10:30:00.000Z","date_formatted":{"ll":"2023年10月25日","L":"2023/10/25","MM-DD":"10-25"},"link":"2023/10/25/一致性Hash原理与实现","tags":["一致性Hash"],"categories":["学习","转载"],"updated":"2024-10-11T04:26:17.701Z","content":"<h3 id=\"前言\">前言<a title=\"#前言\" href=\"#前言\"></a></h3>\n<p>互联网公司中，绝大部分都没有马爸爸系列的公司那样财大气粗，他们即没有强劲的服务器、也没有钱去购买昂贵的海量数据库。那他们是怎么应对大数据量高并发的业务场景的呢？<br>\n 这个和当前的开源技术、海量数据架构都有着不可分割的关系。比如通过mysql、nginx等开源软件，通过架构和低成本的服务器搭建千万级别的用户访问系统。<br>\n 怎么样搭建一个好的系统架构，这个话题我们能聊上个七天七夜。这里我主要结合Redis集群来讲一下一致性Hash的相关问题。</p>\n<h3 id=\"redis集群的使用\">Redis集群的使用<a title=\"#redis集群的使用\" href=\"#redis集群的使用\"></a></h3>\n<p>我们在使用Redis的过程中，为了保证Redis的高可用，我们一般会对Redis做主从复制，组成Master-Master或者Master-Slave的形式，进行数据的读写分离，如下图1-1所示：<br>\n<img src=\"http://zeven.site:7521/2023/05/20230506122227.png\" alt=\"Master-Slave模式\" loading=\"lazy\"><br>\n当缓存数据量超过一定的数量时，我们就要对Redis集群做分库分表的操作。</p>\n<p>来个栗子，我们有一个电商平台，需要使用Redis存储商品的图片资源，存储的格式为键值对，key值为图片名称，Value为该图片所在的文件服务器的路径，我们需要根据文件名，查找到文件所在的文件服务器上的路径，我们的图片数量大概在3000w左右，按照我们的规则进行分库，规则就是随机分配的，我们以每台服务器存500w的数量，部署12台缓存服务器，并且进行主从复制，架构图如下图1-2所示：</p>\n<p><img src=\"http://zeven.site:7521/2023/05/20230506122301.png\" alt=\"Redis分库分表\" loading=\"lazy\" class=\"φbp\"></p>\n<p>由于我们定义的规则是随机的，所以我们的数据有可能存储在任何一组Redis中，比如我们需要查询&quot;product.png&quot;的图片，由于规则的随机性，我们需要遍历所有Redis服务器，才能查询得到。这样的结果显然不是我们所需要的。所以我们会想到按某一个字段值进行Hash值、取模。所以我们就看看使用Hash的方式是怎么进行的。</p>\n<h3 id=\"使用hash的redis集群\">使用Hash的Redis集群<a title=\"#使用hash的redis集群\" href=\"#使用hash的redis集群\"></a></h3>\n<p>如果我们使用Hash的方式，每一张图片在进行分库的时候都可以定位到特定的服务器，示意图如图1-3所示：<br>\n<img src=\"http://zeven.site:7521/2023/05/20230506122340.png\" alt=\"使用Hash方式的命中缓存\" loading=\"lazy\"><br>\n从上图中，我们需要查询的是图product.png，由于我们有6台主服务器，所以计算的公式为：hash(product.png) % 6 = 5, 我们就可以定位到是5号主从，这们就省去了遍历所有服务器的时间，从而大大提升了性能。</p>\n<h3 id=\"使用hash时遇到的问题\">使用Hash时遇到的问题<a title=\"#使用hash时遇到的问题\" href=\"#使用hash时遇到的问题\"></a></h3>\n<p>在上述hash取模的过程中，我们虽然不需要对所有Redis服务器进行遍历而提升了性能。但是，使用Hash算法缓存时会出现一些问题，Redis服务器变动时，所有缓存的位置都会发生改变。<br>\n 比如，现在我们的Redis缓存服务器增加到了8台，我们计算的公式从hash(product.png) % 6 = 5变成了hash(product.png) % 8 = ? 结果肯定不是原来的5了。<br>\n 再者，6台的服务器集群中，当某个主从群出现故障时，无法进行缓存，那我们需要把故障机器移除，所以取模数又会从6变成了5。我们计算的公式也会变化。</p>\n<p>由于上面hash算法是使用取模来进行缓存的，为了规避上述情况，Hash一致性算法就诞生了</p>\n<h3 id=\"一致性hash算法原理\">一致性Hash算法原理<a title=\"#一致性hash算法原理\" href=\"#一致性hash算法原理\"></a></h3>\n<p>一致性Hash算法也是使用取模的方法，不过，上述的取模方法是对服务器的数量进行取模，而一致性的Hash算法是对2的32方取模。即一致性Hash算法将整个Hash空间组织成一个虚拟的圆环，Hash函数的值空间为0 ~ 2^32 - 1(一个32位无符号整型)，整个哈希环如下：<br>\n<img src=\"http://zeven.site:7521/2023/05/20230506122426.png\" alt=\"Hash圆环\" loading=\"lazy\"><br>\n整个圆环以顺时针方向组织，圆环正上方的点代表0，0点右侧的第一个点代表1，以此类推。 第二步，我们将各个服务器使用Hash进行一个哈希，具体可以选择服务器的IP或主机名作为关键字进行哈希，这样每台服务器就确定在了哈希环的一个位置上，比如我们有三台机器，使用IP地址哈希后在环空间的位置如图1-4所示：<br>\n<img src=\"http://zeven.site:7521/2023/05/20230506122507.png\" alt=\"服务器在哈希环上的位置\" loading=\"lazy\"><br>\n现在，我们使用以下算法定位数据访问到相应的服务器：</p>\n<p>将数据Key使用相同的函数Hash计算出哈希值，并确定此数据在环上的位置，从此位置沿环顺时针查找，遇到的服务器就是其应该定位到的服务器。</p>\n<p>例如，现在有ObjectA，ObjectB，ObjectC三个数据对象，经过哈希计算后，在环空间上的位置如下：<br>\n<img src=\"http://zeven.site:7521/2023/05/20230506122537.png\" alt=\"数据对象在环上的位置\" loading=\"lazy\"><br>\n根据一致性算法，Object -&gt; NodeA，ObjectB -&gt; NodeB, ObjectC -&gt; NodeC</p>\n<h3 id=\"一致性hash算法的容错性和可扩展性\">一致性Hash算法的容错性和可扩展性<a title=\"#一致性hash算法的容错性和可扩展性\" href=\"#一致性hash算法的容错性和可扩展性\"></a></h3>\n<p>现在，假设我们的Node C宕机了，我们从图中可以看到，A、B不会受到影响，只有Object C对象被重新定位到Node A。所以我们发现，在一致性Hash算法中，如果一台服务器不可用，受影响的数据仅仅是此服务器到其环空间前一台服务器之间的数据（这里为Node C到Node B之间的数据），其他不会受到影响。如图1-6所示：<br>\n<img src=\"http://zeven.site:7521/2023/05/20230506122606.png\" alt=\"C节点宕机情况，数据移到节点A上\" loading=\"lazy\"><br>\n另外一种情况，现在我们系统增加了一台服务器Node X，如图1-7所示：<br>\n<img src=\"http://zeven.site:7521/2023/05/20230506122632.png\" alt=\"增加新的服务器节点X\" loading=\"lazy\"><br>\n此时对象ObjectA、ObjectB没有受到影响，只有Object C重新定位到了新的节点X上。<br>\n 如上所述：</p>\n<p>一致性Hash算法对于节点的增减都只需重定位环空间中的一小部分数据，有很好的容错性和可扩展性。</p>\n<h3 id=\"数据倾斜问题\">数据倾斜问题<a title=\"#数据倾斜问题\" href=\"#数据倾斜问题\"></a></h3>\n<p>在一致性Hash算法服务节点太少的情况下，容易因为节点分布不均匀面造成数据倾斜（被缓存的对象大部分缓存在某一台服务器上）问题，如图1-8特例：<br>\n<img src=\"http://zeven.site:7521/2023/05/20230506122705.png\" alt=\"数据倾斜\" loading=\"lazy\"><br>\n这时我们发现有大量数据集中在节点A上，而节点B只有少量数据。为了解决数据倾斜问题，一致性Hash算法引入了虚拟节点机制，即对每一个服务器节点计算多个哈希，每个计算结果位置都放置一个此服务节点，称为虚拟节点。 具体操作可以为服务器IP或主机名后加入编号来实现，实现如图1-9所示：<br>\n<img src=\"http://zeven.site:7521/2023/05/20230506122759.png\" alt=\"增加虚拟节点情况\" loading=\"lazy\"><br>\n数据定位算法不变，只需要增加一步：虚拟节点到实际点的映射。<br>\n 所以加入虚拟节点之后，即使在服务节点很少的情况下，也能做到数据的均匀分布。</p>\n<h3 id=\"具体实现\">具体实现<a title=\"#具体实现\" href=\"#具体实现\"></a></h3>\n<h6 id=\"算法接口类\">算法接口类<a title=\"#算法接口类\" href=\"#算法接口类\"></a></h6>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">IHashService</span> </span>&#123;  </span><br><span class=\"line\">    <span class=\"function\">Long <span class=\"title\">hash</span><span class=\"params\">(String key)</span></span>;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h6 id=\"算法接口实现类\">算法接口实现类<a title=\"#算法接口实现类\" href=\"#算法接口实现类\"></a></h6>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">HashService</span> <span class=\"keyword\">implements</span> <span class=\"title\">IHashService</span> </span>&#123;  </span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"comment\">/**  </span></span><br><span class=\"line\"><span class=\"comment\">     * MurMurHash算法,性能高,碰撞率低     *  </span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> key String  </span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> Long  </span></span><br><span class=\"line\"><span class=\"comment\">     */</span>  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Long <span class=\"title\">hash</span><span class=\"params\">(String key)</span> </span>&#123;  </span><br><span class=\"line\">        ByteBuffer buf = ByteBuffer.wrap(key.getBytes());  </span><br><span class=\"line\">        <span class=\"keyword\">int</span> seed = <span class=\"number\">0x1234ABCD</span>;  </span><br><span class=\"line\">  </span><br><span class=\"line\">        ByteOrder byteOrder = buf.order();  </span><br><span class=\"line\">        buf.order(ByteOrder.LITTLE_ENDIAN);  </span><br><span class=\"line\">  </span><br><span class=\"line\">        <span class=\"keyword\">long</span> m = <span class=\"number\">0xc6a4a7935bd1e995L</span>;  </span><br><span class=\"line\">        <span class=\"keyword\">int</span> r = <span class=\"number\">47</span>;  </span><br><span class=\"line\">  </span><br><span class=\"line\">        <span class=\"keyword\">long</span> h = seed ^ (buf.remaining() * m);  </span><br><span class=\"line\">  </span><br><span class=\"line\">        <span class=\"keyword\">long</span> k;  </span><br><span class=\"line\">        <span class=\"keyword\">while</span> (buf.remaining() &gt;= <span class=\"number\">8</span>) &#123;  </span><br><span class=\"line\">            k = buf.getLong();  </span><br><span class=\"line\">  </span><br><span class=\"line\">            k *= m;  </span><br><span class=\"line\">            k ^= k &gt;&gt;&gt; r;  </span><br><span class=\"line\">            k *= m;  </span><br><span class=\"line\">  </span><br><span class=\"line\">            h ^= k;  </span><br><span class=\"line\">            h *= m;  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (buf.remaining() &gt; <span class=\"number\">0</span>) &#123;  </span><br><span class=\"line\">            ByteBuffer finish = ByteBuffer.allocate(<span class=\"number\">8</span>).order(ByteOrder.LITTLE_ENDIAN);  </span><br><span class=\"line\">            finish.put(buf).rewind();  </span><br><span class=\"line\">            h ^= finish.getLong();  </span><br><span class=\"line\">            h *= m;  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">        h ^= h &gt;&gt;&gt; r;  </span><br><span class=\"line\">        h *= m;  </span><br><span class=\"line\">        h ^= h &gt;&gt;&gt; r;  </span><br><span class=\"line\">  </span><br><span class=\"line\">        buf.order(byteOrder);  </span><br><span class=\"line\">        <span class=\"keyword\">return</span> h;  </span><br><span class=\"line\">  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h6 id=\"模拟机器节点\">模拟机器节点<a title=\"#模拟机器节点\" href=\"#模拟机器节点\"></a></h6>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Node</span>&lt;<span class=\"title\">T</span>&gt; </span>&#123;  </span><br><span class=\"line\">    <span class=\"keyword\">private</span> String ip;  </span><br><span class=\"line\">    <span class=\"keyword\">private</span> String name;  </span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Node</span><span class=\"params\">(String ip, String name)</span> </span>&#123;  </span><br><span class=\"line\">        <span class=\"keyword\">this</span>.ip = ip;  </span><br><span class=\"line\">        <span class=\"keyword\">this</span>.name = name;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getIp</span><span class=\"params\">()</span> </span>&#123;  </span><br><span class=\"line\">        <span class=\"keyword\">return</span> ip;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setIp</span><span class=\"params\">(String ip)</span> </span>&#123;  </span><br><span class=\"line\">        <span class=\"keyword\">this</span>.ip = ip;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getName</span><span class=\"params\">()</span> </span>&#123;  </span><br><span class=\"line\">        <span class=\"keyword\">return</span> name;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setName</span><span class=\"params\">(String name)</span> </span>&#123;  </span><br><span class=\"line\">        <span class=\"keyword\">this</span>.name = name;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"comment\">/**  </span></span><br><span class=\"line\"><span class=\"comment\">     * 使用IP当做hash的Key  </span></span><br><span class=\"line\"><span class=\"comment\">     *  </span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> String  </span></span><br><span class=\"line\"><span class=\"comment\">     */</span>  </span><br><span class=\"line\">    <span class=\"meta\">@Override</span>  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">toString</span><span class=\"params\">()</span> </span>&#123;  </span><br><span class=\"line\">        <span class=\"keyword\">return</span> ip;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h6 id=\"一致性hash操作\">一致性Hash操作<a title=\"#一致性hash操作\" href=\"#一致性hash操作\"></a></h6>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ConsistentHash</span>&lt;<span class=\"title\">T</span>&gt; </span>&#123;  </span><br><span class=\"line\">    <span class=\"comment\">// Hash函数接口    private final IHashService iHashService;  </span></span><br><span class=\"line\">    <span class=\"comment\">// 每个机器节点关联的虚拟节点数量    private final int          numberOfReplicas;  </span></span><br><span class=\"line\">    <span class=\"comment\">// 环形虚拟节点    private final SortedMap&lt;Long, T&gt; circle = new TreeMap&lt;Long, T&gt;();  </span></span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ConsistentHash</span><span class=\"params\">(IHashService iHashService, <span class=\"keyword\">int</span> numberOfReplicas, Collection&lt;T&gt; nodes)</span> </span>&#123;  </span><br><span class=\"line\">        <span class=\"keyword\">this</span>.iHashService = iHashService;  </span><br><span class=\"line\">        <span class=\"keyword\">this</span>.numberOfReplicas = numberOfReplicas;  </span><br><span class=\"line\">        <span class=\"keyword\">for</span> (T node : nodes) &#123;  </span><br><span class=\"line\">            add(node);  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"comment\">/**  </span></span><br><span class=\"line\"><span class=\"comment\">     * 增加真实机器节点     *  </span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> node T  </span></span><br><span class=\"line\"><span class=\"comment\">     */</span>  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">add</span><span class=\"params\">(T node)</span> </span>&#123;  </span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"keyword\">this</span>.numberOfReplicas; i++) &#123;  </span><br><span class=\"line\">            circle.put(<span class=\"keyword\">this</span>.iHashService.hash(node.toString() + i), node);  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"comment\">/**  </span></span><br><span class=\"line\"><span class=\"comment\">     * 删除真实机器节点     *  </span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> node T  </span></span><br><span class=\"line\"><span class=\"comment\">     */</span>  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">remove</span><span class=\"params\">(T node)</span> </span>&#123;  </span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"keyword\">this</span>.numberOfReplicas; i++) &#123;  </span><br><span class=\"line\">            circle.remove(<span class=\"keyword\">this</span>.iHashService.hash(node.toString() + i));  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> T <span class=\"title\">get</span><span class=\"params\">(String key)</span> </span>&#123;  </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (circle.isEmpty()) <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;  </span><br><span class=\"line\">  </span><br><span class=\"line\">        <span class=\"keyword\">long</span> hash = iHashService.hash(key);  </span><br><span class=\"line\">  </span><br><span class=\"line\">        <span class=\"comment\">// 沿环的顺时针找到一个虚拟节点        if (!circle.containsKey(hash)) &#123;  </span></span><br><span class=\"line\">            SortedMap&lt;Long, T&gt; tailMap = circle.tailMap(hash);  </span><br><span class=\"line\">            hash = tailMap.isEmpty() ? circle.firstKey() : tailMap.firstKey();  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">        <span class=\"keyword\">return</span> circle.get(hash);  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h6 id=\"测试类\">测试类<a title=\"#测试类\" href=\"#测试类\"></a></h6>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TestHashCircle</span> </span>&#123;  </span><br><span class=\"line\">    <span class=\"comment\">// 机器节点IP前缀    private static final String IP_PREFIX = &quot;192.168.0.&quot;;  </span></span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;  </span><br><span class=\"line\">        <span class=\"comment\">// 每台真实机器节点上保存的记录条数        Map&lt;String, Integer&gt; map = new HashMap&lt;String, Integer&gt;();  </span></span><br><span class=\"line\">  </span><br><span class=\"line\">        <span class=\"comment\">// 真实机器节点, 模拟10台        List&lt;Node&lt;String&gt;&gt; nodes = new ArrayList&lt;Node&lt;String&gt;&gt;();  </span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= <span class=\"number\">10</span>; i++) &#123;  </span><br><span class=\"line\">            map.put(IP_PREFIX + i, <span class=\"number\">0</span>); <span class=\"comment\">// 初始化记录            Node&lt;String&gt; node = new Node&lt;String&gt;(IP_PREFIX + i, &quot;node&quot; + i);  </span></span><br><span class=\"line\">            nodes.add(node);  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">        IHashService iHashService = <span class=\"keyword\">new</span> HashService();  </span><br><span class=\"line\">        <span class=\"comment\">// 每台真实机器引入100个虚拟节点        ConsistentHash&lt;Node&lt;String&gt;&gt; consistentHash = new ConsistentHash&lt;Node&lt;String&gt;&gt;(iHashService, 500, nodes);  </span></span><br><span class=\"line\">  </span><br><span class=\"line\">        <span class=\"comment\">// 将5000条记录尽可能均匀的存储到10台机器节点上        for (int i = 0; i &lt; 5000; i++) &#123;  </span></span><br><span class=\"line\">            <span class=\"comment\">// 产生随机一个字符串当做一条记录，可以是其它更复杂的业务对象,比如随机字符串相当于对象的业务唯一标识            String data = UUID.randomUUID().toString() + i;  </span></span><br><span class=\"line\">            <span class=\"comment\">// 通过记录找到真实机器节点            Node&lt;String&gt; node = consistentHash.get(data);  </span></span><br><span class=\"line\">            <span class=\"comment\">// 再这里可以能过其它工具将记录存储真实机器节点上，比如MemoryCache等            // ...  </span></span><br><span class=\"line\">            <span class=\"comment\">// 每台真实机器节点上保存的记录条数加1  </span></span><br><span class=\"line\">            map.put(node.getIp(), map.get(node.getIp()) + <span class=\"number\">1</span>);  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">        <span class=\"comment\">// 打印每台真实机器节点保存的记录条数        for (int i = 1; i &lt;= 10; i++) &#123;  </span></span><br><span class=\"line\">            System.out.println(IP_PREFIX + i + <span class=\"string\">&quot;节点记录条数：&quot;</span> + map.get(IP_PREFIX + i));  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>每台机器映射的虚拟节点越多，则分布的越均匀~~~ 感兴趣的同学可以拷贝上面的代码运行尝试一下。</p>\n<h2 id=\"原文链接：\">原文链接：<a title=\"#原文链接：\" href=\"#原文链接：\"></a></h2>\n<p><a href=\"%5Bhttps://www.jianshu.com/p/528ce5cd7e8f%5D(https://www.jianshu.com/p/528ce5cd7e8f)\">一致性Hash原理与实现</a></p>\n","prev":{"title":"JVM简述","link":"2024/10/10/JVM简述"},"next":{"title":"一次数据库连接池优化的实践剖析","link":"2023/08/20/一次数据库连接池优化的实践剖析"},"plink":"https://zinki.github.io/2023/10/25/一致性Hash原理与实现/","toc":[{"id":"前言","title":"前言","index":"1"},{"id":"redis集群的使用","title":"Redis集群的使用","index":"2"},{"id":"使用hash的redis集群","title":"使用Hash的Redis集群","index":"3"},{"id":"使用hash时遇到的问题","title":"使用Hash时遇到的问题","index":"4"},{"id":"一致性hash算法原理","title":"一致性Hash算法原理","index":"5"},{"id":"一致性hash算法的容错性和可扩展性","title":"一致性Hash算法的容错性和可扩展性","index":"6"},{"id":"数据倾斜问题","title":"数据倾斜问题","index":"7"},{"id":"具体实现","title":"具体实现","index":"8"}]}