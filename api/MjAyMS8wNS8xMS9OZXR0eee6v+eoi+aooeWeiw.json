{"title":"Netty线程模型","date":"2021-05-11T07:40:00.000Z","date_formatted":{"ll":"2021年5月11日","L":"2021/05/11","MM-DD":"05-11"},"link":"2021/05/11/Netty线程模型","tags":["Netty"],"categories":["学习"],"updated":"2024-10-11T02:02:36.242Z","content":"<p>Netty 是一个 NIO 客户端服务器框架，可以快速轻松地开发网络应用程序，例如协议服务器和客户端。它极大地简化和精简了 TCP 和 UDP 套接字服务器等网络编程。<br>\n<img src=\"http://zeven.cpolar.cn/2024/10/202410111000944.png\" alt=\"\" loading=\"lazy\"><span id=\"more\"></span></p>\n<p>传统阻塞IO模型存在以下问题：</p>\n<ol>\n<li>每个连接都需要独立线程处理，当并发数大时，创建线程数多，占用资源</li>\n<li>采用阻塞IO模型，连接建立后，若当前线程没有数据可读，线程会阻塞在读操作上，造成资源浪费</li>\n</ol>\n<p>针对于存在的问题可以采取以下方案：</p>\n<ol>\n<li>基于线程池思想，避免为每个连接创建线程，连接完成后将业务处理交给线程池处理。</li>\n<li>基于IO复用模型，多个连接共用同一个阻塞对象，不用等待所有的连接。遍历到有新数据可以处理时，操作系统会通知程序，线程跳出阻塞状态，进行业务逻辑处理。</li>\n</ol>\n<blockquote>\n<p>Reactor线程模型就是基于IO复用和线程池的结合，其核心是I/O多路复用和事件驱动。</p>\n</blockquote>\n<h3 id=\"reactor单线程模型\">Reactor单线程模型<a title=\"#reactor单线程模型\" href=\"#reactor单线程模型\"></a></h3>\n<p>由于Reactor模式使用的是异步非阻塞IO，所有的IO操作都不会导致阻塞，理论上一个线程可以独立处理所有IO相关的操作。从架构层面看，一个NIO线程确实可以完成其承担的职责。例如，通过Acceptor类接收客户端的TCP连接请求消息，链路建立成功之后，通过Dispatch将对应的ByteBuffer派发到指定的Handler上进行消息解码。用户线程可以通过消息编码通过NIO线程将消息发送给客户端。</p>\n<p><img src=\"http://zeven.cpolar.cn/2024/10/202410111000918.png\" alt=\"\" loading=\"lazy\" class=\"φbp\"></p>\n<p>对于一些小容量应用场景，可以使用单线程模型。但是对于高负载、大并发的应用场景却不合适，主要原因如下：</p>\n<ol>\n<li>用一个线程处理请求，对于多核资源机器来说是有点浪费的；</li>\n<li>一个NIO线程同时处理成百上千的链路，性能上无法支撑，即便NIO线程的CPU负荷达到100%，也无法满足海量消息的编码、解码、读取和发送；</li>\n<li>当NIO线程负载过重之后，处理速度将变慢，这会导致大量客户端连接超时，超时之后往往会进行重发，这更加重了NIO线程的负载，最终会导致大量消息积压和处理超时，成为系统的性能瓶颈；</li>\n<li>可靠性问题：一旦NIO线程意外跑飞，或者进入死循环，会导致整个系统通信模块不可用，不能接收和处理外部消息，造成节点故障。<br>\n为了解决这些问题，演进出了Reactor多线程模型。</li>\n</ol>\n<h3 id=\"reactor多线程模型\">Reactor多线程模型<a title=\"#reactor多线程模型\" href=\"#reactor多线程模型\"></a></h3>\n<p>Rector多线程模型与单线程模型最大的区别就是换成了线程池处理，也就是Reactor线程只处理连接事件和读写事件，业务处理交给线程池处理，充分利用多核机器的资源、提高性能并且增加可靠性。其特点如下：</p>\n<ol>\n<li>有专门一个NIO线程-Acceptor线程用于监听服务端，接收客户端的TCP连接请求；</li>\n<li>网络IO操作-读、写等由一个NIO线程池负责，线程池可以采用标准的JDK线程池实现，它包含一个任务队列和N个可用的线程，由这些NIO线程负责消息的读取、解码、编码和发送；</li>\n<li>1个NIO线程可以同时处理N条链路，但是1个链路只对应1个NIO线程，防止发生并发操作问题。</li>\n</ol>\n<p><img src=\"http://zeven.cpolar.cn/2024/10/202410111002796.png\" alt=\"\" loading=\"lazy\" class=\"φbp\"></p>\n<p>在绝大多数场景下，Reactor多线程模型都可以满足性能需求；但是，在极个别特殊场景中，一个NIO线程负责监听和处理所有的客户端连接可能会存在性能问题。例如并发百万客户端连接，或者服务端需要对客户端握手进行安全认证，但是认证本身非常损耗性能。在这类场景下，单独一个Acceptor线程可能会存在性能不足问题，为了解决性能问题，产生了第三种Reactor线程模型-主从Reactor多线程模型。</p>\n<h3 id=\"主从reactor多线程模型\">主从Reactor多线程模型<a title=\"#主从reactor多线程模型\" href=\"#主从reactor多线程模型\"></a></h3>\n<p>主从Reactor线程模型的特点是：服务端用于接收客户端连接的不再是个1个单独的NIO线程，而是一个独立的NIO（mainReactor）线程池。Acceptor接收到客户端TCP连接请求处理完成后（可能包含接入认证等），将新创建的SocketChannel注册到IO线程池（subreactor线程池）的某个IO线程上，由它负责SocketChannel的读写和编解码工作。Acceptor线程池仅仅只用于客户端的登陆、握手和安全认证，一旦链路建立成功，就将链路注册到后端subReactor线程池的IO线程上，由IO线程负责后续的IO操作。<br>\n<img src=\"http://zeven.cpolar.cn/2024/10/202410111002392.png\" alt=\"\" loading=\"lazy\"><br>\n工作流程大致如下：</p>\n<ol>\n<li>从主线程池中随机选择一个Reactor线程作为Acceptor线程，用于绑定监听端口，接收客户端连接；</li>\n<li>Acceptor线程接收客户端连接请求之后创建新的SocketChannel，将其注册到主线程池的其它Reactor线程上，由其负责接入认证、IP黑白名单过滤、握手等操作；<br>\n步骤2完成之后，业务层的链路正式建立，将SocketChannel从主线程池的Reactor线程的多路复用器上摘除，重新注册到Sub线程池的线程上，用于处理I/O的读写操作</li>\n</ol>\n<p>使用netty而不用原生NIO原因:</p>\n<ol>\n<li>NIO的类库和API繁杂，使用麻烦</li>\n<li>需要具备其他的额外技能做铺垫，例如熟悉Java多线程编程。这是因为NIO编程涉及到Reactor模式，你必须对多线程和网路编程非常熟悉，才能编写出高质量的NIO程序。</li>\n<li>可靠性能力补齐，工作量和难度都非常大。例如客户端面临断连重连、网络闪断、半包读写、失败缓存、网络拥塞和异常码流的处理等问题，NIO编程的特点是功能开发相对容易，但是可靠性能力补齐的工作量和难度都非常大。</li>\n<li>JDK NIO的BUG，例如臭名昭著的epoll bug，它会导致Selector空轮询，最终导致CPU 100%。官方声称在JDK1.6版本的update18修复了该问题，但是直到JDK1.7版本该问题仍旧存在，只不过该BUG发生概率降低了一些而已，它并没有被根本解决。</li>\n</ol>\n<h3 id=\"参考\">参考<a title=\"#参考\" href=\"#参考\"></a></h3>\n<ol>\n<li><a href=\"https://netty.io/\" target=\"_blank\">Netty官网</a></li>\n<li><a href=\"http://www.lllpan.top/article/23\" target=\"_blank\">Reactor线程模型</a></li>\n</ol>\n","prev":{"title":"SnowFlakeID生成算法","link":"2021/06/10/SnowFlakeID生成算法"},"next":{"title":"一致性Hash原理","link":"2021/04/25/一致性Hash原理"},"plink":"https://zinki.github.io/2021/05/11/Netty线程模型/","toc":[{"id":"reactor单线程模型","title":"Reactor单线程模型","index":"1"},{"id":"reactor多线程模型","title":"Reactor多线程模型","index":"2"},{"id":"主从reactor多线程模型","title":"主从Reactor多线程模型","index":"3"},{"id":"参考","title":"参考","index":"4"}]}