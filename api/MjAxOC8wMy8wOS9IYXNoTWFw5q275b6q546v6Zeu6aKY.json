{"title":"HashMap死循环问题","date":"2018-03-09T12:07:00.000Z","date_formatted":{"ll":"2018年3月9日","L":"2018/03/09","MM-DD":"03-09"},"link":"2018/03/09/HashMap死循环问题","tags":["HashMap"],"categories":["学习"],"updated":"2024-10-10T08:03:05.444Z","content":"<p>HashMap在并发执行put操作后get操作会引起死循环, 是因为多线程会导致 HashMap的 Entry链表形成环形数据结构, 一旦形成环形数据结构, Entry 的 next 节点永远不为空, 就会产生死循环获取Entry。<span id=\"more\"></span></p>\n<p>HashMap通常会用一个指针数组（假设为table[]）来做分散所有的key，当一个key被加入时，会通过Hash算法通过key算出这个数组的下标i，然后就把这个<code>&lt;key, value&gt;</code>插到table[i]中，如果有两个不同的key被算在了同一个i，那么就叫冲突，又叫碰撞，这样会在table[i]上形成一个链表。<br>\n我们知道，如果table[]的尺寸很小，比如只有2个，如果要放进10个keys的话，那么碰撞非常频繁，于是一个O(1)的查找算法，就变成了链表遍历，性能变成了O(n)，这是Hash表的缺陷（可参看《Hash Collision DoS 问题》）。<br>\n所以，Hash表的尺寸和容量非常的重要。一般来说，Hash表这个容器当有数据要插入时，都会检查容量有没有超过设定的thredhold，如果超过，需要增大Hash表的尺寸，但是这样一来，整个Hash表里的无素都需要被重算一遍。这叫rehash，这个成本相当的大。</p>\n<h2 id=\"为何出现死循环？\">为何出现死循环？<a title=\"#为何出现死循环？\" href=\"#为何出现死循环？\"></a></h2>\n<p>大家都知道，HashMap采用链表解决Hash冲突，具体的HashMap的分析可以参考一下Java集合—HashMap源码剖析 的分析。因为是链表结构，那么就很容易形成闭合的链路，这样在循环的时候只要有线程对这个HashMap进行get操作就会产生死循环。但是，我好奇的是，这种闭合的链路是如何形成的呢。在单线程情况下，只有一个线程对HashMap的数据结构进行操作，是不可能产生闭合的回路的。那就只有在多线程并发的情况下才会出现这种情况，那就是在put操作的时候，如果<code>size&gt;initialCapacity*loadFactor</code>那么这时候HashMap就会进行rehash操作，随之HashMap的结构就会发生翻天覆地的变化。很有可能就是在两个线程在这个时候同时触发了rehash操作，产生了闭合的回路。<br>\n下面我们从源码中一步一步地分析这种回路是如何产生的。先看一下put操作：<br>\n存储数据put</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public V put(K key, V value) &#123;</span><br><span class=\"line\">        if (table == EMPTY_TABLE) &#123;</span><br><span class=\"line\">            inflateTable(threshold);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        if (key == null)</span><br><span class=\"line\">            return putForNullKey(value);</span><br><span class=\"line\">        int hash = hash(key);</span><br><span class=\"line\">        int i = indexFor(hash, table.length);</span><br><span class=\"line\">        for (Entry&lt;K,V&gt; e = table[i]; e != null; e = e.next) &#123;</span><br><span class=\"line\">            Object k;</span><br><span class=\"line\">            if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123;</span><br><span class=\"line\">                V oldValue = e.value;</span><br><span class=\"line\">                e.value = value;</span><br><span class=\"line\">                e.recordAccess(this);</span><br><span class=\"line\">                return oldValue;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">        modCount++;</span><br><span class=\"line\">        addEntry(hash, key, value, i);</span><br><span class=\"line\">        return null;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>当我们往HashMap中put元素的时候，先根据key的hash值得到这个元素在数组中的位置（即下标），然后就可以把这个元素放到对应的位置中了。 如果这个元素所在的位置上已经存放有其他元素了，那么在同一个位子上的元素将以链表的形式存放，新加入的放在链头，而先前加入的放在链尾。</p>\n<p>检查容量是否超标addEntry</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void addEntry(int hash, K key, V value, int bucketIndex) &#123;</span><br><span class=\"line\">        if ((size &gt;= threshold) &amp;&amp; (null != table[bucketIndex])) &#123;</span><br><span class=\"line\">            resize(2 * table.length);</span><br><span class=\"line\">            hash = (null != key) ? hash(key) : 0;</span><br><span class=\"line\">            bucketIndex = indexFor(hash, table.length);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">        createEntry(hash, key, value, bucketIndex);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>可以看到，如果现在size已经超过了threshold，那么就要进行resize操作,新建一个更大尺寸的hash表，然后把数据从老的Hash表中迁移到新的Hash表中：</p>\n<p>调整Hash表大小resize</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void resize(int newCapacity) &#123;</span><br><span class=\"line\">       Entry[] oldTable = table;</span><br><span class=\"line\">       int oldCapacity = oldTable.length;</span><br><span class=\"line\">       if (oldCapacity == MAXIMUM_CAPACITY) &#123;</span><br><span class=\"line\">           threshold = Integer.MAX_VALUE;</span><br><span class=\"line\">           return;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">       Entry[] newTable = new Entry[newCapacity];</span><br><span class=\"line\">       transfer(newTable, initHashSeedAsNeeded(newCapacity));</span><br><span class=\"line\">       table = newTable;</span><br><span class=\"line\">       threshold = (int)Math.min(newCapacity * loadFactor, MAXIMUM_CAPACITY + 1);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>当table[]数组容量较小，容易产生哈希碰撞，所以，Hash表的尺寸和容量非常的重要。一般来说，Hash表这个容器当有数据要插入时，都会检查容量有没有超过设定的thredhold，如果超过，需要增大Hash表的尺寸，这个过程称为resize。</p>\n</blockquote>\n<p>多个线程同时往HashMap添加新元素时，多次resize会有一定概率出现死循环，因为每次resize需要把旧的数据映射到新的哈希表，这一部分代码在HashMap#transfer() 方法，如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void transfer(Entry[] newTable, boolean rehash) &#123;</span><br><span class=\"line\">        int newCapacity = newTable.length;</span><br><span class=\"line\">        for (Entry&lt;K,V&gt; e : table) &#123;</span><br><span class=\"line\">            while(null != e) &#123;</span><br><span class=\"line\">                Entry&lt;K,V&gt; next = e.next;</span><br><span class=\"line\">                if (rehash) &#123;</span><br><span class=\"line\">                    e.hash = null == e.key ? 0 : hash(e.key);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                int i = indexFor(e.hash, newCapacity);</span><br><span class=\"line\">                e.next = newTable[i];</span><br><span class=\"line\">                newTable[i] = e;</span><br><span class=\"line\">                e = next;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>transfer部分代码是导致多线程使用hashmap出现CUP使用率骤增，从而多个线程阻塞的罪魁祸首。</p>\n<h2 id=\"解决方案\">解决方案<a title=\"#解决方案\" href=\"#解决方案\"></a></h2>\n<p>Sun认为这不是一个问题，HashMap不支持并发操作，若有并发需求使用ConcurrentHashmap。</p>\n<h2 id=\"参考\">参考<a title=\"#参考\" href=\"#参考\"></a></h2>\n<p><a href=\"https://coolshell.cn/articles/9606.html\" target=\"_blank\">JAVA HASHMAP的死循环</a></p>\n","prev":{"title":"常用正则表达式","link":"2018/03/17/常用正则表达式"},"next":{"title":"Javascript引擎工作原理","link":"2018/02/06/Javascript引擎工作原理"},"plink":"https://zinki.github.io/2018/03/09/HashMap死循环问题/","toc":[{"id":"为何出现死循环？","title":"为何出现死循环？","index":"1"},{"id":"解决方案","title":"解决方案","index":"2"},{"id":"参考","title":"参考","index":"3"}]}