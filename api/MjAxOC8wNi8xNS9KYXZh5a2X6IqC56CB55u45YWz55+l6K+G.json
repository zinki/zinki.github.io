{"title":"Java字节码相关知识","date":"2018-06-15T13:00:00.000Z","date_formatted":{"ll":"2018年6月15日","L":"2018/06/15","MM-DD":"06-15"},"link":"2018/06/15/Java字节码相关知识","tags":["字节码"],"categories":["学习"],"updated":"2024-10-10T08:03:05.448Z","content":"<p>字节码就是Java文件通过编译器编译成的.class文件<span id=\"more\"></span></p>\n<p>Java是一门静态语言，通常，我们需要的class在编译的时候就已经生成了，为什么有时候我们还想在运行时动态生成class呢？<br>\n因为在有些时候，我们还真得在运行时为一个类动态创建子类。比如，编写一个ORM框架，如何得知一个简单的JavaBean是否被用户修改过呢？<br>\n以User为例：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class User &#123;</span><br><span class=\"line\">    private String id;</span><br><span class=\"line\">    private String name;</span><br><span class=\"line\">public String getId() &#123;</span><br><span class=\"line\">        return id;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">public void setId(String id) &#123;</span><br><span class=\"line\">        this.id = id;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">public String getName() &#123;</span><br><span class=\"line\">        return name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">public void setName(String name) &#123;</span><br><span class=\"line\">        this.name = name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>其实UserProxy实现起来很简单，就是创建一个User的子类，覆写所有setXxx()方法，做个标记就可以了：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class UserProxy extends User &#123;</span><br><span class=\"line\">    private boolean dirty;</span><br><span class=\"line\">public boolean isDirty() &#123;</span><br><span class=\"line\">        return this.dirty;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">public void setDirty(boolean dirty) &#123;</span><br><span class=\"line\">        this.dirty = dirty;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">@Override</span><br><span class=\"line\">    public void setId(String id) &#123;</span><br><span class=\"line\">        super.setId(id);</span><br><span class=\"line\">        setDirty(true);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">@Override</span><br><span class=\"line\">    public void setName(String name) &#123;</span><br><span class=\"line\">        super.setName(name);</span><br><span class=\"line\">        setDirty(true);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>但是这个UserProxy就必须在运行时动态创建出来了，因为编译时ORM框架根本不知道User类。<br>\n现在问题来了，动态生成字节码，难度有多大？<br>\n如果我们要自己直接输出二进制格式的字节码，在完成这个任务前，必须先认真阅读JVM规范第四章，详细了解class文件结构。估计读完规范后，两个月过去了。<br>\n所以，第一种方法，自己动手，从零开始创建字节码，理论上可行，实际上很难。<br>\n第二种方法，使用已有的一些能操作字节码的库，帮助我们创建class。<br>\n目前，能够操作字节码的开源库主要有CGLIB和Javassist两种，它们都提供了比较高级的API来操作字节码，最后输出为class文件。<br>\n比如CGLib，典型的用法如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Enhancer e = new Enhancer();</span><br><span class=\"line\">e.setSuperclass(...);</span><br><span class=\"line\">e.setStrategy(new DefaultGeneratorStrategy() &#123;</span><br><span class=\"line\">    protected ClassGenerator transform(ClassGenerator cg) &#123;</span><br><span class=\"line\">        return new TransformingGenerator(cg,</span><br><span class=\"line\">            new AddPropertyTransformer(new String[]&#123; &quot;foo&quot; &#125;,</span><br><span class=\"line\">                    new Class[] &#123; Integer.TYPE &#125;));</span><br><span class=\"line\">    &#125;&#125;);</span><br><span class=\"line\">Object obj = e.create();</span><br></pre></td></tr></table></figure>\n<p>比自己生成class要简单，但是，要学会它的API还是得花大量的时间，并且，上面的代码很难看懂对不对？<br>\n有木有更简单的方法？<br>\n有！<br>\n换一个思路，如果我们能创建UserProxy.java这个源文件，再调用Java编译器，直接把源码编译成class，再加载进虚拟机，任务完成！<br>\n毕竟，创建一个字符串格式的源码是很简单的事情，就是拼字符串嘛，高级点的做法可以用一个模版引擎。<br>\n如何编译？<br>\nJava的编译器是javac，但是，在很早很早的时候，Java的编译器就已经用纯Java重写了，自己能编译自己，行业黑话叫“自举”。从Java 1.6开始，编译器接口正式放到JDK的公开API中，于是，我们不需要创建新的进程来调用javac，而是直接使用编译器API来编译源码。<br>\n使用起来也很简单：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">JavaCompiler compiler = ToolProvider.getSystemJavaCompiler();</span><br><span class=\"line\">int compilationResult = compiler.run(null, null, null, &#x27;/path/to/Test.java&#x27;);</span><br></pre></td></tr></table></figure>\n<p>这么写编译是没啥问题，问题是我们在内存中创建了Java代码后，必须先写到文件，再编译，最后还要手动读取class文件内容并用一个ClassLoader加载。<br>\n有木有更简单的方法？<br>\n有！<br>\n其实Java编译器根本不关心源码的内容是从哪来的，你给它一个String当作源码，它就可以输出byte[]作为class的内容。<br>\n所以，我们需要参考Java Compiler API的文档，让Compiler直接在内存中完成编译，输出的class内容就是byte[]。<br>\n代码改造如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Map&lt;String, byte[]&gt; results;</span><br><span class=\"line\">JavaCompiler compiler = ToolProvider.getSystemJavaCompiler();</span><br><span class=\"line\">StandardJavaFileManager stdManager = compiler.getStandardFileManager(null, null, null);</span><br><span class=\"line\">try (MemoryJavaFileManager manager = new MemoryJavaFileManager(stdManager)) &#123;</span><br><span class=\"line\">    JavaFileObject javaFileObject = manager.makeStringSource(fileName, source);</span><br><span class=\"line\">    CompilationTask task = compiler.getTask(null, manager, null, null, null, Arrays.asList(javaFileObject));</span><br><span class=\"line\">    if (task.call()) &#123;</span><br><span class=\"line\">        results = manager.getClassBytes();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上述代码的几个关键在于：<br>\n用MemoryJavaFileManager替换JDK默认的StandardJavaFileManager，以便在编译器请求源码内容时，不是从文件读取，而是直接返回String；<br>\n用MemoryOutputJavaFileObject替换JDK默认的SimpleJavaFileObject，以便在接收到编译器生成的byte[]内容时，不写入class文件，而是直接保存在内存中。<br>\n最后，编译的结果放在Map&lt;String, byte[]&gt;中，Key是类名，对应的byte[]是class的二进制内容。<br>\n为什么编译后不是一个byte[]呢？<br>\n因为一个.java的源文件编译后可能有多个.class文件！只要包含了静态类、匿名类等，编译出的class肯定多于一个。<br>\n如何加载编译后的class呢？<br>\n加载class相对而言就容易多了，我们只需要创建一个ClassLoader，覆写findClass()方法：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class MemoryClassLoader extends URLClassLoader &#123;</span><br><span class=\"line\">Map&lt;String, byte[]&gt; classBytes = new HashMap&lt;String, byte[]&gt;();</span><br><span class=\"line\">public MemoryClassLoader(Map&lt;String, byte[]&gt; classBytes) &#123;</span><br><span class=\"line\">        super(new URL[0], MemoryClassLoader.class.getClassLoader());</span><br><span class=\"line\">        this.classBytes.putAll(classBytes);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">@Override</span><br><span class=\"line\">    protected Class&lt;?&gt; findClass(String name) throws ClassNotFoundException &#123;</span><br><span class=\"line\">        byte[] buf = classBytes.get(name);</span><br><span class=\"line\">        if (buf == null) &#123;</span><br><span class=\"line\">            return super.findClass(name);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        classBytes.remove(name);</span><br><span class=\"line\">        return defineClass(name, buf, 0, buf.length);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","prev":{"title":"Transactional注解不起作用如何排查","link":"2018/07/17/Transactional注解不起作用如何排查"},"next":{"title":"堆外内存相关知识","link":"2018/05/11/堆外内存相关知识"},"plink":"https://zinki.github.io/2018/06/15/Java字节码相关知识/"}