{"title":"IO相关知识","date":"2018-09-05T02:10:00.000Z","date_formatted":{"ll":"2018年9月5日","L":"2018/09/05","MM-DD":"09-05"},"link":"2018/09/05/IO相关知识","tags":["IO"],"categories":["学习"],"updated":"2024-10-11T04:18:57.061Z","content":"<p>select/poll/epoll区别<span id=\"more\"></span></p>\n<p>基本Linux I/O模型的简单矩阵<br>\n<img src=\"http://zeven.site:7521/2024/10/202410110951749.png\" alt=\"\" loading=\"lazy\"></p>\n<p>select，poll，epoll都是IO多路复用的机制。I/O多路复用就是通过一种机制，一个进程可以监视多个描述符，一旦某个描述符就绪（一般是读就绪或者写就绪），能够通知程序进行相应的读写操作。但select，poll，epoll本质上都是同步I/O，因为他们都需要在读写事件就绪后自己负责进行读写，也就是说这个读写过程是阻塞的.<br>\n异步I/O则无需自己负责进行读写，异步I/O的实现会负责把数据从内核拷贝到用户空间</p>\n<p>epoll是Linux内核的IO模型。我想一定有人想问，AIO听起来比NIO更加高大上，为什么不使用AIO？AIO其实也有应用，但是有一个问题就是，Linux是不支持AIO的，AIO框架在windows下使用windows IOCP技术，在Linux下使用epoll多路复用IO技术模拟异步IO.因此基于AIO的程序运行在Linux上的效率相比NIO反而更低。而Linux是最主要的服务器OS，因此相比AIO，目前NIO的应用更加广泛。</p>\n<h2 id=\"select\">select<a title=\"#select\" href=\"#select\"></a></h2>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int select (int n, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout);</span><br></pre></td></tr></table></figure>\n<p>select 函数监视的文件描述符分3类，分别是writefds、readfds、和exceptfds。调用后select函数会阻塞，直到有描述副就绪（有数据 可读、可写、或者有except），或者超时（timeout指定等待时间，如果立即返回设为null即可），函数返回。当select函数返回后，可以 通过遍历fdset，来找到就绪的描述符。<br>\nselect目前几乎在所有的平台上支持，其良好跨平台支持也是它的一个优点。select的一 个缺点在于单个进程能够监视的文件描述符的数量存在最大限制，在Linux上一般为1024，可以通过修改宏定义甚至重新编译内核的方式提升这一限制，但是这样也会造成效率的降低。</p>\n<h2 id=\"poll\">poll<a title=\"#poll\" href=\"#poll\"></a></h2>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int poll (struct pollfd *fds, unsigned int nfds, int timeout);</span><br><span class=\"line\">不同与select使用三个位图来表示三个fdset的方式，poll使用一个 pollfd的指针实现。</span><br><span class=\"line\">struct pollfd &#123;</span><br><span class=\"line\">    int fd; /* file descriptor */</span><br><span class=\"line\">    short events; /* requested events to watch */</span><br><span class=\"line\">    short revents; /* returned events witnessed */</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>pollfd结构包含了要监视的event和发生的event，不再使用select“参数-值”传递的方式。同时，pollfd并没有最大数量限制（但是数量过大后性能也是会下降）。 和select函数一样，poll返回后，需要轮询pollfd来获取就绪的描述符。<br>\n从上面看，select和poll都需要在返回后，通过遍历文件描述符来获取已经就绪的socket。事实上，同时连接的大量客户端在一时刻可能只有很少的处于就绪状态，因此随着监视的描述符数量的增长，其效率也会线性下降。</p>\n<h2 id=\"epoll\">epoll<a title=\"#epoll\" href=\"#epoll\"></a></h2>\n<p>epoll是在2.6内核中提出的，是之前的select和poll的增强版本。相对于select和poll来说，epoll更加灵活，没有描述符限制。epoll使用一个文件描述符管理多个描述符，将用户关系的文件描述符的事件存放到内核的一个事件表中，这样在用户空间和内核空间的copy只需一次。</p>\n<ol>\n<li>epoll操作过程<br>\nepoll操作过程需要三个接口，分别如下：</li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int epoll_create(int size)；//创建一个epoll的句柄，size用来告诉内核这个监听的数目一共有多大</span><br><span class=\"line\">int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event)；</span><br><span class=\"line\">int epoll_wait(int epfd, struct epoll_event * events, int maxevents, int timeout);</span><br></pre></td></tr></table></figure>\n<p>int epoll_create(int size);<br>\n创建一个epoll的句柄，size用来告诉内核这个监听的数目一共有多大，这个参数不同于select()中的第一个参数，给出最大监听的fd+1的值，参数size并不是限制了epoll所能监听的描述符最大个数，只是对内核初始分配内部数据结构的一个建议。<br>\n当创建好epoll句柄后，它就会占用一个fd值，在linux下如果查看/proc/进程id/fd/，是能够看到这个fd的，所以在使用完epoll后，必须调用close()关闭，否则可能导致fd被耗尽。</p>\n<p>int epoll_ctl(int epfd, int op, int fd, struct epoll_event <code>*</code>event)函数是对指定描述符fd执行op操作。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- epfd：是epoll_create()的返回值。</span><br><span class=\"line\">- op：表示op操作，用三个宏来表示：添加EPOLL_CTL_ADD，删除EPOLL_CTL_DEL，修改EPOLL_CTL_MOD。分别添加、删除和修改对fd的监听事件。</span><br><span class=\"line\">- fd：是需要监听的fd（文件描述符）</span><br><span class=\"line\">- epoll_event：是告诉内核需要监听什么事，struct epoll_event结构如下：</span><br><span class=\"line\">struct epoll_event &#123;</span><br><span class=\"line\">  __uint32_t events;  /* Epoll events */</span><br><span class=\"line\">  epoll_data_t data;  /* User data variable */</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>events可以是以下几个宏的集合：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">EPOLLIN ：表示对应的文件描述符可以读（包括对端SOCKET正常关闭）；</span><br><span class=\"line\">EPOLLOUT：表示对应的文件描述符可以写；</span><br><span class=\"line\">EPOLLPRI：表示对应的文件描述符有紧急的数据可读（这里应该表示有带外数据到来）；</span><br><span class=\"line\">EPOLLERR：表示对应的文件描述符发生错误；</span><br><span class=\"line\">EPOLLHUP：表示对应的文件描述符被挂断；</span><br><span class=\"line\">EPOLLET： 将EPOLL设为边缘触发(Edge Triggered)模式，这是相对于水平触发(Level Triggered)来说的。</span><br><span class=\"line\">EPOLLONESHOT：只监听一次事件，当监听完这次事件之后，如果还需要继续监听这个socket的话，需要再次把这个socket加入到EPOLL队列里</span><br></pre></td></tr></table></figure>\n<p>int epoll_wait(int epfd, struct epoll_event * events, int maxevents, int timeout);<br>\n等待epfd上的io事件，最多返回maxevents个事件。<br>\n参数events用来从内核得到事件的集合，maxevents告之内核这个events有多大，这个maxevents的值不能大于创建epoll_create()时的size，参数timeout是超时时间（毫秒，0会立即返回，-1将不确定，也有说法说是永久阻塞）。该函数返回需要处理的事件数目，如返回0表示已超时。</p>\n<ol start=\"2\">\n<li>工作模式</li>\n</ol>\n<p>epoll对文件描述符的操作有两种模式：LT（level trigger）和ET（edge trigger）。LT模式是默认模式，LT模式与ET模式的区别如下：<br>\n　　LT模式：当epoll_wait检测到描述符事件发生并将此事件通知应用程序，应用程序可以不立即处理该事件。下次调用epoll_wait时，会再次响应应用程序并通知此事件。<br>\n　　ET模式：当epoll_wait检测到描述符事件发生并将此事件通知应用程序，应用程序必须立即处理该事件。如果不处理，下次调用epoll_wait时，不会再次响应应用程序并通知此事件。</p>\n<blockquote>\n<p>LT模式<br>\nLT(level triggered)是缺省的工作方式，并且同时支持block和no-block socket.在这种做法中，内核告诉你一个文件描述符是否就绪了，然后你可以对这个就绪的fd进行IO操作。如果你不作任何操作，内核还是会继续通知你的。</p>\n</blockquote>\n<blockquote>\n<p>ET模式<br>\nET(edge-triggered)是高速工作方式，只支持no-block socket。在这种模式下，当描述符从未就绪变为就绪时，内核通过epoll告诉你。然后它会假设你知道文件描述符已经就绪，并且不会再为那个文件描述符发送更多的就绪通知，直到你做了某些操作导致那个文件描述符不再为就绪状态了(比如，你在发送，接收或者接收请求，或者发送接收的数据少于一定量时导致了一个EWOULDBLOCK 错误）。但是请注意，如果一直不对这个fd作IO操作(从而导致它再次变成未就绪)，内核不会发送更多的通知(only once)<br>\nET模式在很大程度上减少了epoll事件被重复触发的次数，因此效率要比LT模式高。epoll工作在ET模式的时候，必须使用非阻塞套接口，以避免由于一个文件句柄的阻塞读/阻塞写操作把处理多个文件描述符的任务饿死。</p>\n</blockquote>\n<h2 id=\"参考\">参考<a title=\"#参考\" href=\"#参考\"></a></h2>\n<p><a href=\"https://segmentfault.com/a/1190000003063859\" target=\"_blank\">Linux IO模式及 select、poll、epoll详解</a></p>\n","prev":{"title":"自定义SQL打印","link":"2018/09/20/自定义SQL打印"},"next":{"title":"IOC实现原理","link":"2018/08/26/IOC实现原理"},"plink":"https://zinki.github.io/2018/09/05/IO相关知识/","toc":[{"id":"select","title":"select","index":"1"},{"id":"poll","title":"poll","index":"2"},{"id":"epoll","title":"epoll","index":"3"},{"id":"参考","title":"参考","index":"4"}]}