{"title":"OOP-KLASS二分模型","date":"2019-12-10T05:10:00.000Z","date_formatted":{"ll":"2019年12月10日","L":"2019/12/10","MM-DD":"12-10"},"link":"2019/12/10/OOP-KLASS二分模型","tags":["JVM","OOP-KLASS"],"categories":["学习"],"updated":"2024-10-10T08:03:05.454Z","content":"<p>HotSpot是基于c++实现，而c++是一门面向对象的语言，本身具备面向对象基本特征，所以Java中的对象表示，最简单的做法是为每个Java类生成一个c++类与之对应。<span id=\"more\"></span></p>\n<p>但HotSpot JVM并没有这么做，而是设计了一个OOP-Klass Model。这里的 OOP 指的是 Ordinary Object Pointer （普通对象指针），它用来表示对象的实例信息，看起来像个指针实际上是藏在指针里的对象。而 Klass 则包含元数据和方法信息，用来描述Java类。</p>\n<p>之所以采用这个模型是因为HotSopt JVM的设计者不想让每个对象中都含有一个vtable（虚函数表），所以就把对象模型拆成klass和oop，其中oop中不含有任何虚函数，而Klass就含有虚函数表，可以进行method dispatch。</p>\n<p>OOP-Klass 模型是对象在JVM中的表示</p>\n<ol>\n<li>OOP<br>\nKlass是在class文件在加载过程中创建的，OOP则是在Java程序运行过程中new对象时创建的。</li>\n</ol>\n<p>一个OOP对象包含以下几个部分：</p>\n<blockquote>\n<p>instanceOopDesc，也叫对象头</p>\n</blockquote>\n<blockquote>\n<blockquote>\n<p>Mark Word，主要存储对象运行时记录信息，如hashcode, GC分代年龄，锁状态标志，线程ID，时间戳等<br>\n元数据指针，即指向方法区的instanceKlass实例</p>\n</blockquote>\n</blockquote>\n<blockquote>\n<p>实例数据</p>\n</blockquote>\n<ol start=\"2\">\n<li>Klass<br>\nKlass简单的说是Java类在HotSpot中的c++对等体，用来描述Java类。</li>\n</ol>\n<p>Klass主要有两个功能：</p>\n<blockquote>\n<p>实现语言层面的Java类<br>\n实现Java对象的分发功能</p>\n</blockquote>\n<p>那Klass是什么时候创建的呢？<br>\n一般jvm在加载class文件时，会在方法区创建instanceKlass，表示其元数据，包括常量池、字段、方法等。</p>\n<p>当 C、 C++和 Delphi 等程序被编译成二进制程序后 , 原来所定义的高级数据结构都不复存在了 , 当Windows/Linux等操作系统 (宿主机) 加载这些二进制程序时, 是不会加载这些语言中所定义的高级数据结构的 宿主机压根儿就不知道原来定义了哪些数据结构 哪此类所有的数据结构都被转换为对特定内存段偏移地址. 例如 C 中的 struct结构体, 被编译后不复存在, 汇编和机器语言中没有与之对应的数据结构的概念, CPU 更不知道何为结构体. C++和Delphi 中的类概念被编后也不复存在, 所谓的类最终变成内存首地址. 而 JVM虚拟机在加载字节码程序时, 会记录字节码中所定义的所有类型的原始信息 (元数据), JVM知道程序中包含了哪些类, 以及每个类中所关联的字段、方法、类等信息.这是 JVM虚拟机与操作系统最大的区别所在</p>\n<p>JVM最终就自然而然地演化出了OOP-KLASS 这种二分模型, KLASS 用于保存类元信息, 而 OOP 用于表示 JVM所创建的类实例对象口 KLASS 信息被保存在 PERM 永久区, 而 OOP则被分配在 HEAP 堆区.同时 JVM为了支持反射等技术, 必须在 OOP 中保存一个指针, 用于指向其所属的类型KLASS, 这样Java开发者便能够基于反射技术, 在 Java 程序运行期获取 Java 的类型信息</p>\n<h2 id=\"参考\">参考<a title=\"#参考\" href=\"#参考\"></a></h2>\n<p><a href=\"https://book.douban.com/subject/27086821/\" target=\"_blank\">揭秘Java虚拟机</a><br>\n<a href=\"https://blog.csdn.net/linxdcn/article/details/73287490\" target=\"_blank\">对象在jvm中的表示：OOP-Klass模型</a></p>\n","prev":{"title":"B树和B+树","link":"2020/01/12/B树和B+树"},"next":{"title":"大数据日知录笔记","link":"2019/11/16/大数据日知录笔记"},"plink":"https://zinki.github.io/2019/12/10/OOP-KLASS二分模型/","toc":[{"id":"参考","title":"参考","index":"1"}]}