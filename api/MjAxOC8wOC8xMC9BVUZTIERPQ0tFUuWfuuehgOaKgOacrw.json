{"title":"AUFS DOCKER基础技术","date":"2018-08-10T05:10:00.000Z","date_formatted":{"ll":"2018年8月10日","L":"2018/08/10","MM-DD":"08-10"},"link":"2018/08/10/AUFS DOCKER基础技术","tags":["DOCKER"],"categories":["转载"],"updated":"2024-10-11T07:58:15.267Z","content":"<p>AUFS是一种Union File System，所谓UnionFS就是把不同物理位置的目录合并mount到同一个目录中。UnionFS的一个最主要的应用是，把一张CD/DVD和一个硬盘目录给联合 mount在一起，然后，你就可以对这个只读的CD/DVD上的文件进行修改（当然，修改的文件存于硬盘上的目录里）。<br>\n<img src=\"http://zeven.cpolar.cn/2023/05/202305071348123.png\" alt=\"\" loading=\"lazy\"><br>\nAUFS又叫Another UnionFS，后来叫Alternative UnionFS，后来可能觉得不够霸气，叫成Advance UnionFS。是个叫Junjiro Okajima（岡島順治郎）在2006年开发的，AUFS完全重写了早期的UnionFS 1.x，其主要目的是为了可靠性和性能，并且引入了一些新的功能，比如可写分支的负载均衡。AUFS在使用上全兼容UnionFS，而且比之前的UnionFS在稳定性和性能上都要好很多，后来的UnionFS 2.x开始抄AUFS中的功能。但是他居然没有进到Linux主干里，就是因为Linus不让，基本上是因为代码量比较多，而且写得烂（相对于只有3000行的union mount和10000行的UnionFS，以及其它平均下来只有6000行代码左右的VFS，AUFS居然有30000行代码），所以，岡島不断地改进代码质量，不断地提交，不断地被Linus拒掉，所以，到今天AUFS都还进不了Linux主干（今天你可以看到AUFS的代码其实还好了，比起OpenSSL好N倍，要么就是Linus对代码的质量要求非常高，要么就是Linus就是不喜欢AUFS）。</p>\n<p>不过，好在有很多发行版都用了AUFS，比如：Ubuntu 10.04，Debian6.0, Gentoo Live CD支持AUFS，所以，也OK了。</p>\n<p>好了，扯完这些闲话，我们还是看一个示例吧（环境：Ubuntu 14.04）</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ tree</span><br><span class=\"line\">.</span><br><span class=\"line\">├── fruits</span><br><span class=\"line\">│   ├── apple</span><br><span class=\"line\">│   └── tomato</span><br><span class=\"line\">└── vegetables</span><br><span class=\"line\">    ├── carrots</span><br><span class=\"line\">    └── tomato</span><br><span class=\"line\"># 创建一个mount目录</span><br><span class=\"line\">$ mkdir mnt</span><br><span class=\"line\"></span><br><span class=\"line\"># 把水果目录和蔬菜目录union mount到 ./mnt目录中</span><br><span class=\"line\">$ sudo mount -t aufs -o dirs=./fruits:./vegetables none ./mnt</span><br><span class=\"line\"></span><br><span class=\"line\">#  查看./mnt目录</span><br><span class=\"line\">$ tree ./mnt</span><br><span class=\"line\">./mnt</span><br><span class=\"line\">├── apple</span><br><span class=\"line\">├── carrots</span><br><span class=\"line\">└── tomato</span><br></pre></td></tr></table></figure>\n<p>我们可以看到在./mnt目录下有三个文件，苹果apple、胡萝卜carrots和蕃茄tomato。水果和蔬菜的目录被union到了./mnt目录下了。</p>\n<p>我们来修改一下其中的文件内容：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ echo mnt &gt; ./mnt/apple</span><br><span class=\"line\">$ cat ./mnt/apple</span><br><span class=\"line\">mnt</span><br><span class=\"line\">$ cat ./fruits/apple</span><br><span class=\"line\">mnt</span><br><span class=\"line\">上面的示例，我们可以看到./mnt/apple的内容改了，./fruits/apple的内容也改了。</span><br><span class=\"line\">$ echo mnt_carrots &gt; ./mnt/carrots</span><br><span class=\"line\">$ cat ./vegetables/carrots</span><br><span class=\"line\">$ cat ./fruits/carrots</span><br><span class=\"line\">mnt_carrots</span><br></pre></td></tr></table></figure>\n<p>上面的示例，我们可以看到，我们修改了./mnt/carrots的文件内容，./vegetables/carrots并没有变化，反而是./fruits/carrots的目录中出现了carrots文件，其内容是我们在./mnt/carrots里的内容。</p>\n<p>也就是说，我们在mount aufs命令中，我们没有指它vegetables和fruits的目录权限，默认上来说，命令行上第一个（最左边）的目录是可读可写的，后面的全都是只读的。（一般来说，最前面的目录应该是可写的，而后面的都应该是只读的）</p>\n<p>所以，如果我们像下面这样指定权限来mount aufs，你就会发现有不一样的效果（记得先把上面./fruits/carrots的文件删除了）：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ sudo mount -t aufs -o dirs=./fruits=rw:./vegetables=rw none ./mnt</span><br><span class=\"line\">$ echo &quot;mnt_carrots&quot; &gt; ./mnt/carrots</span><br><span class=\"line\">$ cat ./vegetables/carrots</span><br><span class=\"line\">mnt_carrots</span><br><span class=\"line\">$ cat ./fruits/carrots</span><br><span class=\"line\">cat: ./fruits/carrots: No such file or directory</span><br></pre></td></tr></table></figure>\n<p>现在，在这情况下，如果我们要修改./mnt/tomato这个文件，那么究竟是哪个文件会被改写？</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ echo &quot;mnt_tomato&quot; &gt; ./mnt/tomato</span><br><span class=\"line\">$ cat ./fruits/tomato</span><br><span class=\"line\">mnt_tomato</span><br><span class=\"line\">$ cat ./vegetables/tomato</span><br><span class=\"line\">I am a vegetable</span><br></pre></td></tr></table></figure>\n<p>可见，如果有重复的文件名，在mount命令行上，越往前的就优先级越高。</p>\n<p>那么，这种UnionFS有什么用？</p>\n<p>历史上，有一个叫Knoppix的Linux发行版，其主要用于Linux演示、光盘教学、系统急救，以及商业产品的演示，不需要硬盘安装，直接把CD/DVD上的image运行在一个可写的存储设备上（比如一个U盘上），其实，也就是把CD/DVD这个文件系统和USB这个可写的系统给联合mount起来，这样你对CD/DVD上的image做的任何改动都会在被应用在U盘上，于是乎，你可以对CD/DVD上的内容进行任意的修改，因为改动都在U盘上，所以你改不坏原来的东西。</p>\n<p>我们可以再发挥一下想像力，你也可以把一个目录，比如你的源代码，作为一个只读的template，和另一个你的working directory给union在一起，然后你就可以做各种修改而不用害怕会把源代码改坏了。有点像一个ad hoc snapshot。</p>\n<p>Docker把UnionFS的想像力发挥到了容器的镜像。你是否还记得我在介绍Linux Namespace上篇中用mount namespace和chroot山寨了一镜像。现在当你看过了这个UnionFS的技术后，你是不是就明白了，你完全可以用UnionFS这样的技术做出分层的镜像来。</p>\n<p>下图来自Docker的官方文档Layer，其很好的展示了Docker用UnionFS搭建的分层镜像。<br>\n<img src=\"http://zeven.cpolar.cn/2023/05/202305071352484.png\" alt=\"\" loading=\"lazy\"><br>\n关于docker的分层镜像，除了aufs，docker还支持btrfs, devicemapper和vfs，你可以使用 -s 或 –storage-driver= 选项来指定相关的镜像存储。在Ubuntu 14.04下，docker默认Ubuntu的 aufs（在CentOS7下，用的是devicemapper，关于devicemapper，我会以以后的文章中讲解）你可以在下面的目录中查看相关的每个层的镜像：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#ls /sys/fs/aufs/si_b71b209f85ff8e75/</span><br><span class=\"line\">br0      br2      br4      br6      brid1    brid3    brid5    xi_path</span><br><span class=\"line\">br1      br3      br5      brid0    brid2    brid4    brid6</span><br><span class=\"line\"># cat /sys/fs/aufs/si_b71b209f85ff8e75/*</span><br><span class=\"line\">/var/lib/docker/aufs/diff/87315f1367e5703f599168d1e17528a0500bd2e2df7d2fe2aaf9595f3697dbd7=rw</span><br><span class=\"line\">/var/lib/docker/aufs/diff/87315f1367e5703f599168d1e17528a0500bd2e2df7d2fe2aaf9595f3697dbd7-init=ro+wh</span><br><span class=\"line\">/var/lib/docker/aufs/diff/d0955f21bf24f5bfffd32d2d0bb669d0564701c271bc3dfc64cfc5adfdec2d07=ro+wh</span><br><span class=\"line\">/var/lib/docker/aufs/diff/9fec74352904baf5ab5237caa39a84b0af5c593dc7cc08839e2ba65193024507=ro+wh</span><br><span class=\"line\">/var/lib/docker/aufs/diff/a1a958a248181c9aa6413848cd67646e5afb9797f1a3da5995c7a636f050f537=ro+wh</span><br><span class=\"line\">/var/lib/docker/aufs/diff/f3c84ac3a0533f691c9fea4cc2ceaaf43baec22bf8d6a479e069f6d814be9b86=ro+wh</span><br><span class=\"line\">/var/lib/docker/aufs/diff/511136ea3c5a64f264b78b5433614aec563103b4d4702f3ba7d4d2698e22c158=ro+wh</span><br><span class=\"line\">/run/shm/aufs.xino</span><br></pre></td></tr></table></figure>\n<p>你会看到只有最顶上的层（branch）是rw权限，其它的都是ro+wh权限只读的。</p>\n<p>关于docker的aufs的配置，你可以在/var/lib/docker/repositories-aufs这个文件中看到。</p>\n<p>AUFS的一些特性</p>\n<p>AUFS有所有Union FS的特性，把多个目录，合并成同一个目录，并可以为每个需要合并的目录指定相应的权限，实时的添加、删除、修改已经被mount好的目录。而且，他还能在多个可写的branch/dir间进行负载均衡。</p>\n<p>上面的例子，我们已经看到AUFS的mount的示例了。下面我们来看一看被union的目录（分支）的相关权限：<br>\nrw表示可写可读read-write。<br>\nro表示read-only，如果你不指权限，那么除了第一个外ro是默认值，对于ro分支，其永远不会收到写操作，也不会收到查找whiteout的操作。<br>\nrr表示real-read-only，与read-only不同的是，rr标记的是天生就是只读的分支，这样，AUFS可以提高性能，比如不再设置inotify来检查文件变动通知。</p>\n<p>权限中，我们看到了一个术语：whiteout，下面我来解释一下这个术语。<br>\n一般来说ro的分支都会有wh的属性，比如 “[dir]=ro+wh”。所谓whiteout的意思，如果在union中删除的某个文件，实际上是位于一个readonly的分支（目录）上，那么，在mount的union这个目录中你将看不到这个文件，但是read-only这个层上我们无法做任何的修改，所以，我们就需要对这个readonly目录里的文件作whiteout。AUFS的whiteout的实现是通过在上层的可写的目录下建立对应的whiteout隐藏文件来实现的。</p>\n<p>相关术语</p>\n<p>Branch – 就是各个要被union起来的目录（就是我在上面使用的dirs的命令行参数）<br>\nBranch根据被union的顺序形成一个stack，一般来说最上面的是可写的，下面的都是只读的。<br>\nBranch的stack可以在被mount后进行修改，比如：修改顺序，加入新的branch，或是删除其中的branch，或是直接修改branch的权限<br>\nWhiteout 和 Opaque<br>\n如果UnionFS中的某个目录被删除了，那么就应该不可见了，就算是在底层的branch中还有这个目录，那也应该不可见了。<br>\nWhiteout就是某个上层目录覆盖了下层的相同名字的目录。用于隐藏低层分支的文件，也用于阻止readdir进入低层分支。<br>\nOpaque的意思就是不允许任何下层的某个目录显示出来。<br>\n在隐藏低层档的情况下，whiteout的名字是’.`wh.<filename>’。<br>\n在阻止readdir的情况下，名字是’.wh…wh…opq’或者 ’.wh.__dir_opaque’。</p>\n<p>同一个内核版本的所有Linux系统的bootfs是相同的，而rootfs则是不同的。在Docker 中，基础镜像中的roofs会一直保持只读模式，Docker会利用union mount来在这个rootfs上增加更多的只读文件系统，最后它们看起来就像一个文件系统即容器的rootfs。</p>\n<p>关于 Docker的分层镜像，除了 aufs，docker还支持btrfs, devicemapper和vfs，你可以使用 -s 或 –storage-driver= 选项来指定相关的镜像存储。在Ubuntu 14.04下，Docker 默认 Ubuntu的 AUFS。因为 AUFS 还没有进入Linux 内核主干的原因，RedHat 上使用的是 devicemapper。</p>\n<p>镜像(image)是动态的容器的静态表示（specification），包括容器所要运行的应用代码以及运行时的配置。Docker 镜像包括一个或者多个只读层（ read-only layers ），因此，镜像一旦被创建就再也不能被修改了。<br>\n一个运行着的Docker 容器是一个镜像的实例（ instantiation ）。从同一个镜像中运行的容器包含有相同的应用代码和运行时依赖。但是不像镜像是静态的，每个运行着的容器都有一个可写层（ writable layer ，也成为容器层 container layer），它位于底下的若干只读层之上。运行时的所有变化，包括对数据和文件的写和更新，都会保存在这个层中。因此，从同一个镜像运行的多个容器包含了不同的容器层。</p>\n<p>四种单节点网络模式<br>\nBridge 模式<br>\nDocker 容器默认使用 bridge 模式的网络。其特点如下：</p>\n<ul>\n<li>使用一个 linux bridge，默认为 docker0</li>\n<li>使用 veth 对，一头在容器的网络 namespace 中，一头在 docker0 上</li>\n<li>该模式下Docker Container不具有一个公有IP，因为宿主机的IP地址与veth pair的 IP地址不在同一个网段内</li>\n<li>Docker采用 NAT 方式，将容器内部的服务监听的端口与宿主机的某一个端口port 进行“绑定”，使得宿主机以外的世界可以主动将网络报文发送至容器内部</li>\n<li>外界访问容器内的服务时，需要访问宿主机的 IP 以及宿主机的端口 port</li>\n<li>NAT 模式由于是在三层网络上的实现手段，故肯定会影响网络的传输效率。</li>\n<li>容器拥有独立、隔离的网络栈；让容器和宿主机以外的世界通过NAT建立通信</li>\n</ul>\n<p>iptables 的 SNTA 规则，使得从容器离开去外界的网络包的源 IP 地址被转换为 Docker 主机的IP地址：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Chain POSTROUTING (policy ACCEPT)</span><br><span class=\"line\">target     prot opt source               destination</span><br><span class=\"line\">MASQUERADE  all  --  172.17.0.0/16        0.0.0.0/0</span><br><span class=\"line\">MASQUERADE  all  --  172.18.0.0/16        0.0.0.0/0</span><br></pre></td></tr></table></figure>\n<p>Host 模式<br>\nHost 模式并没有为容器创建一个隔离的网络环境。而之所以称之为host模式，是因为该模式下的 Docker 容器会和 host 宿主机共享同一个网络 namespace，故 Docker Container可以和宿主机一样，使用宿主机的eth0，实现和外界的通信。换言之，Docker Container的 IP 地址即为宿主机 eth0 的 IP 地址。其特点包括：</p>\n<ul>\n<li>这种模式下的容器没有隔离的 network namespace</li>\n<li>容器的 IP 地址同 Docker host 的 IP 地址</li>\n<li>需要注意容器中服务的端口号不能与 Docker host 上已经使用的端口号相冲突</li>\n<li>host 模式能够和其它模式共存</li>\n</ul>\n<p>Container 模式<br>\nContainer 网络模式是 Docker 中一种较为特别的网络的模式。处于这个模式下的 Docker 容器会共享其他容器的网络环境，因此，至少这两个容器之间不存在网络隔离，而这两个容器又与宿主机以及除此之外其他的容器存在网络隔离。</p>\n<p>none 模式<br>\n网络模式为 none，即不为 Docker 容器构造任何网络环境。一旦Docker 容器采用了none 网络模式，那么容器内部就只能使用loopback网络设备，不会再有其他的网络资源。Docker Container的none网络模式意味着不给该容器创建任何网络环境，容器只能使用127.0.0.1的本机网络。</p>\n<h2 id=\"原文链接：\">原文链接：<a title=\"#原文链接：\" href=\"#原文链接：\"></a></h2>\n<p><a href=\"%5Bhttps://coolshell.cn/articles/17061.html%5D(https://coolshell.cn/articles/17061.html)\"># DOCKER基础技术：AUFS</a></p>\n","prev":{"title":"AOP实现原理","link":"2018/08/10/AOP实现原理"},"next":{"title":"AUFS基本原理","link":"2018/07/29/AUFS基本原理"},"plink":"https://zinki.github.io/2018/08/10/AUFS DOCKER基础技术/","toc":[{"id":"原文链接：","title":"原文链接：","index":"1"}]}