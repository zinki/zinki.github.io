{"title":"SnowFlakeID生成算法","date":"2021-06-10T11:50:00.000Z","date_formatted":{"ll":"2021年6月10日","L":"2021/06/10","MM-DD":"06-10"},"link":"2021/06/10/SnowFlakeID生成算法","tags":["SnowFlake"],"categories":["工作"],"updated":"2024-10-11T08:02:34.463Z","content":"<blockquote>\n<p>据国家大气研究中心的查尔斯·奈特称，一般的雪花大约由10^19个水分子组成。在雪花形成过程中，会形成不同的结构分支，所以说大自然中不存在两片完全一样的雪花，每一片雪花都拥有自己漂亮独特的形状。雪花算法表示生成的id如雪花般独一无二。</p>\n<p>snowflake是Twitter开源的分布式ID生成算法，结果是一个long型的ID。其核心思想是：使用41bit作为毫秒数，10bit作为机器的ID（5个bit是数据中心，5个bit的机器ID），12bit作为毫秒内的流水号（意味着每个节点在每毫秒可以产生 4096 个 ID），最后还有一个符号位，永远是0。<span id=\"more\"></span></p>\n</blockquote>\n<p>snowflake算法所生成的ID结构：</p>\n<p><img src=\"http://zeven.cpolar.cn/2024/10/202410111010528.png\" alt=\"\" loading=\"lazy\" class=\"φbp\"></p>\n<ul>\n<li>第一位</li>\n</ul>\n<p>占用1bit，其值始终是0，没有实际作用。</p>\n<ul>\n<li>时间戳</li>\n</ul>\n<p>占用41bit，精确到毫秒，总共可以容纳约69 年的时间。</p>\n<ul>\n<li>工作机器id</li>\n</ul>\n<p>占用10bit，其中高位5bit是数据中心ID（datacenterId），低位5bit是工作节点ID（workerId），做多可以容纳1024个节点。</p>\n<ul>\n<li>序列号</li>\n</ul>\n<p>占用12bit，这个值在同一毫秒同一节点上从0开始不断累加，最多可以累加到4095。</p>\n<p>SnowFlake算法在同一毫秒内最多可以生成多少个全局唯一ID呢？只需要做一个简单的乘法：</p>\n<p>同一毫秒的ID数量 = 1024 X 4096 = 4194304</p>\n<p>这个数字在绝大多数并发场景下都是够用的。</p>\n<p>SnowFlake算法的优点：</p>\n<ol>\n<li>\n<p>生成ID时不依赖于DB，完全在内存生成，高性能高可用。</p>\n</li>\n<li>\n<p>ID呈趋势递增，后续插入索引树的时候性能较好。</p>\n</li>\n</ol>\n<p>SnowFlake算法的缺点：</p>\n<p>依赖于系统时钟的一致性。如果某台机器的系统时钟回拨，有可能造成ID冲突，或者ID乱序。</p>\n<blockquote>\n<p>时钟为什么会发生回拨？机器本地时钟可能会因为各种原因发生不准的情况，网络中提供了NTP服务来做时间校准，做校准的时候就会发生时钟的跳跃或者回拨的问题</p>\n</blockquote>\n<p>解决方案：</p>\n<ol>\n<li>\n<p>定义时钟回拨后等待最大值</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">* 时钟回拨最大值 3 毫秒，不建议大于 5 毫秒 </span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">static</span> <span class=\"keyword\">long</span> MAX_BACKWARD_MS =<span class=\"number\">3</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 当前时间戳小于上次时间戳，出现时钟回拨 </span></span><br><span class=\"line\"><span class=\"keyword\">if</span> (currStamp &lt; lastStamp) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 偏移量 </span></span><br><span class=\"line\">    <span class=\"keyword\">long</span> offset = lastStamp - currStamp;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (offset &lt;= MAX_BACKWARD_MS) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 休眠等待 </span></span><br><span class=\"line\">        LockSupport.parkNanos (TimeUnit.MICROSECONDS.toNanos (offset));</span><br><span class=\"line\">        <span class=\"comment\">// 重新获取当前值 </span></span><br><span class=\"line\">        currStamp = getNewStamp ();</span><br><span class=\"line\">        <span class=\"comment\">// 如果仍然小于上次时间戳，可以直接抛异常或者采用扩展字段 extension</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (currStamp &lt; lastStamp) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RuntimeException (<span class=\"string\">&quot;Clock moved backwards.  Refusing to generate id&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p>​利用拓展位</p>\n<p>由于 SnowFlake 最后序列号占用 12 位 bit，一毫秒可以生成 4096 个 ID，一般系统用不到这么大的并发量的的话，可以拿出几位当成时钟回拨扩展位，或者其他几部分也可以拿出几位来用于扩展。在此拿出序列号的 2 位用于时钟回拨的扩展</p>\n</li>\n</ol>\n<h2 id=\"参考\">参考<a title=\"#参考\" href=\"#参考\"></a></h2>\n<p><a href=\"https://segmentfault.com/a/1190000040964518\" target=\"_blank\">讲讲雪花算法，越详细越好</a></p>\n<p><a href=\"http://tanmw.top/archives/8b811d4f.html\" target=\"_blank\">分布式 ID 方案 --SnowFlake（雪花算法）</a></p>\n","prev":{"title":"证书及密钥相关概念","link":"2021/06/20/证书及密钥相关概念"},"next":{"title":"Netty线程模型","link":"2021/05/11/Netty线程模型"},"plink":"https://zinki.github.io/2021/06/10/SnowFlakeID生成算法/","toc":[{"id":"参考","title":"参考","index":"1"}]}