{"title":"接口慢查询分析","date":"2020-05-15T09:10:00.000Z","date_formatted":{"ll":"2020年5月15日","L":"2020/05/15","MM-DD":"05-15"},"link":"2020/05/15/接口慢查询分析","tags":["SQL"],"categories":["工作"],"updated":"2024-10-10T08:03:05.469Z","content":"<p>线上页面打不开定位到接口内一条慢SQL<span id=\"more\"></span>，经过优化得到接口本地测试响应时间90秒，放到UAT环境测试还是打不开</p>\n<p>通过<code>show processlist</code>命令看到SQL执行过程中会不断发起新的查询</p>\n<p><img src=\"https://i.loli.net/2020/10/21/b24Jg1NZKCzphUd.png\" alt=\"\" loading=\"lazy\" class=\"φbp\"></p>\n<p>查询日志可以看出在过六七十秒后会重新请求接口<br>\n经Google得到可能是Nginx的问题<br>\n<a href=\"https://billyhu.com/post/brower-http-request-reissue/\" target=\"_blank\">浏览器的Http请求重发机制</a></p>\n<figure class=\"highlight basic\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  server &#123;</span><br><span class=\"line\">   send_timeout <span class=\"number\">60</span>s;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>由上图可以看出两次请求间隔确实是60秒，所以是Nginx的问题。</p>\n<p>至于接口优化方面，尝试过SQL优化和程序优化两种方式，SQL优化不太可行，程序优化方向中发现查询前面数据集很快，选择把WHERE条件在程序中过滤，整体响应时间缩短到90秒左右，忽略掉查询结果到内存的时间，实际差不多有80秒耗费在程序IO上了。</p>\n<blockquote>\n<p>后来让大佬看过之后，同样选择程序优化，只是把中间过滤条件单独拉出来查询，同样的条件只耗时6秒多</p>\n</blockquote>\n<blockquote>\n<p>由此可以得出：<br>\n1. IO和SQL优化同样重要，优化中应尽量杜绝大批量数据的IO操作<br>\n2. 查询条件尽可能将范围收窄</p>\n</blockquote>\n","prev":{"title":"Java集合相关","link":"2020/06/11/Java集合相关"},"next":{"title":"Service Mesh浅析","link":"2020/02/06/Service Mesh浅析"},"plink":"https://zinki.github.io/2020/05/15/接口慢查询分析/"}