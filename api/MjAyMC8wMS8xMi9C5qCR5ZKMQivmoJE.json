{"title":"B树和B+树","date":"2020-01-12T09:20:00.000Z","date_formatted":{"ll":"2020年1月12日","L":"2020/01/12","MM-DD":"01-12"},"link":"2020/01/12/B树和B+树","tags":["B树"],"categories":["学习"],"updated":"2024-10-10T08:03:05.438Z","content":"<p>我们都知道二叉查找树的查找的时间复杂度是Ｏ(log N),其查找效率已经足够高了，<span id=\"more\"></span>那为什么还有Ｂ树和Ｂ＋树的出现呢？难道它两的时间复杂度比二叉查找树还小吗？</p>\n<p>答案当然不是，Ｂ树和Ｂ＋树的出现是因为另外一个问题，那就是磁盘IO；众所周知，IO操作的效率很低，那么，当在大量数据存储中，查询时我们不能一下子将所有数据加载到内存中，只能逐一加载磁盘页，每个磁盘页对应树的节点。造成大量磁盘IO操作（最坏情况下为树的高度）。平衡二叉树由于树深度过大而造成磁盘IO读写过于频繁，进而导致效率低下。</p>\n<p>所以，我们为了减少磁盘IO的次数，就你必须降低树的深度，将“瘦高”的树变得“矮胖”。一个基本的想法就是：</p>\n<ol>\n<li>每个节点存储多个元素</li>\n<li>摒弃二叉树结构，采用多叉树</li>\n</ol>\n<p>这样就引出来了一个新的查找树结构–多路查找树。 根据AVL给我们的启发，一颗平衡多路查找树(B-树)自然可以使得数据的查找效率保证在O(logN)这样的对数级别上.</p>\n<p>一个m阶的B树具有如下几个特征：B树中所有结点的孩子结点最大值称为B树的阶，通常用m表示。一个结点有k个孩子时，必有k-1个关键字才能将子树中所有关键字划分为k个子集。</p>\n<figure class=\"highlight basic\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1</span>. 根结点至少有两个子女。</span><br><span class=\"line\"><span class=\"number\">2</span>. 每个中间节点都包含k-<span class=\"number\">1</span>个元素和k个孩子，其中 ceil（m/<span class=\"number\">2</span>） ≤ k ≤ m</span><br><span class=\"line\"><span class=\"number\">3</span>. 每一个叶子节点都包含k-<span class=\"number\">1</span>个元素，其中 ceil（m/<span class=\"number\">2</span>） ≤ k ≤ m</span><br><span class=\"line\"><span class=\"number\">4</span>. 所有的叶子结点都位于同一层。</span><br><span class=\"line\"><span class=\"number\">5</span>. 每个节点中的元素从小到大排列，节点当中k-<span class=\"number\">1</span>个元素正好是k个孩子包含的元素的值域划分</span><br></pre></td></tr></table></figure>\n<p>B+树是B树的变种，有着比B树更高的查询效率。一个m阶的B+树具有如下几个特征：</p>\n<figure class=\"highlight basic\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1</span>. 有k个子树的中间节点包含有k个元素（B树中是k-<span class=\"number\">1</span>个元素），每个元素不保存数据，只用来索引，所有数据</span><br><span class=\"line\">都保存在叶子节点。</span><br><span class=\"line\"><span class=\"number\">2</span>. 所有的叶子结点中包含了全部元素的信息，及指向含这些元素记录的指针，且叶子结点本身依关键字的大小</span><br><span class=\"line\">自小而大顺序链接。</span><br><span class=\"line\"><span class=\"number\">3</span>. 所有的中间节点元素都同时存在于子节点，在子节点元素中是最大（或最小）元素。</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>所谓卫星数据，指的是索引元素所指向的数据记录，比如数据库的某一行。在B树中，无论中间节点还是叶子节点都带有卫星数据。</p>\n</blockquote>\n<p>B+树优势</p>\n<ol>\n<li>单一节点存储更多的元素（这样该节点下分支变多了，树变矮胖了），使得查询的IO次数更少。</li>\n<li>所有查询都要查找到叶子节点，查询性能稳定。</li>\n<li>所有叶子节点形成有序链表，便于范围查询。</li>\n</ol>\n<p>B+树最大的性能问题是会产生大量的随机IO，随着新数据的插入，叶子节点会慢慢分裂，逻辑上连续的叶子节点在物理上往往不连续，甚至分离的很远，但做范围查询时，会产生大量读随机IO。</p>\n<p>为了克服B+树的弱点，HBase引入了LSM树的概念，即Log-Structured Merge-Trees。<br>\nLSM树本质上就是在读写之间取得平衡，和B+树相比，它牺牲了部分读性能，用来大幅提高写性能。<br>\n它的原理是把一颗大树拆分成N棵小树， 它首先写入到内存中（内存没有寻道速度的问题，随机写的性能得到大幅提升），在内存中构建一颗有序小树，随着小树越来越大，内存的小树会flush到磁盘上。当读时，由于不知道数据在哪棵小树上，因此必须遍历所有的小树，但在每颗小树内部数据是有序的</p>\n<blockquote>\n<p>注:(批处理是应对内存碎片化的有效方案,也可以大幅提升插入效率,但对于查询和数据处理不是很友好,只能在读写性能之间取一个平衡)</p>\n</blockquote>\n<p>极端的说，基于LSM树实现的HBase的写性能比MySQL高了一个数量级，读性能低了一个数量级。</p>\n<h2 id=\"参考\">参考<a title=\"#参考\" href=\"#参考\"></a></h2>\n<p><a href=\"https://blog.csdn.net/z_ryan/article/details/79685072\" target=\"_blank\">简单剖析B树（B-Tree）与Ｂ+树</a></p>\n","prev":{"title":"Service Mesh浅析","link":"2020/02/06/Service Mesh浅析"},"next":{"title":"OOP-KLASS二分模型","link":"2019/12/10/OOP-KLASS二分模型"},"plink":"https://zinki.github.io/2020/01/12/B树和B+树/","toc":[{"id":"参考","title":"参考","index":"1"}]}