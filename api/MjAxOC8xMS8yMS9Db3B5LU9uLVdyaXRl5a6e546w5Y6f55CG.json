{"title":"Copy-On-Write实现原理","date":"2018-11-21T09:00:00.000Z","date_formatted":{"ll":"2018年11月21日","L":"2018/11/21","MM-DD":"11-21"},"link":"2018/11/21/Copy-On-Write实现原理","tags":["COW"],"categories":["学习"],"updated":"2024-10-10T08:03:05.440Z","content":"<p>Copy-On-Write简称COW，是一种用于程序设计中的优化策略。<span id=\"more\"></span></p>\n<p>COW基本思路是从一开始大家都在共享同一个内容，当某个人想要修改这个内容的时候，才会真正把内容Copy出去形成一个新的内容然后再改，这是一种延时懒惰策略。从JDK1.5开始Java并发包里提供了两个使用CopyOnWrite机制实现的并发容器,它们是CopyOnWriteArrayList和CopyOnWriteArraySet。CopyOnWrite容器非常有用，可以在非常多的并发场景中使用到。</p>\n<h2 id=\"什么是copyonwrite容器\">什么是CopyOnWrite容器<a title=\"#什么是copyonwrite容器\" href=\"#什么是copyonwrite容器\"></a></h2>\n<p>CopyOnWrite容器即写时复制的容器。通俗的理解是当我们往一个容器添加元素的时候，不直接往当前容器添加，而是先将当前容器进行Copy，复制出一个新的容器，然后新的容器里添加元素，添加完元素之后，再将原容器的引用指向新的容器。这样做的好处是我们可以对CopyOnWrite容器进行并发的读，而不需要加锁，因为当前容器不会添加任何元素。所以CopyOnWrite容器也是一种读写分离的思想，读和写不同的容器可以对CopyOnWrite容器进行并发的读，而不需要加锁。CopyOnWrite并发容器用于读多写少的并发场景。比如白名单，黑名单，商品类目的访问和更新场景，不适合需要数据强一致性的场景。</p>\n<p>写时复制是指：在并发访问的情景下，当需要修改JAVA中Containers的元素时，不直接修改该容器，而是先复制一份副本，在副本上进行修改。修改完成之后，将指向原来容器的引用指向新的容器(副本容器)。由于不会修改原始容器，只修改副本容器。因此，可以对原始容器进行并发地读。其次，实现了读操作与写操作的分离，读操作发生在原始容器上，写操作发生在副本容器上。</p>\n<blockquote>\n<p>因为CopyOnWrite的写时复制机制会导致内存占用比较大</p>\n</blockquote>\n<blockquote>\n<p>数据一致性问题：读操作的线程可能不会立即读取到新修改的数据，因为修改操作发生在副本上。但最终修改操作会完成并更新容器，因此这是最终一致性。</p>\n</blockquote>\n<p>CopyOnWriteArrayList.add实现</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">add</span><span class=\"params\">(E e)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> ReentrantLock lock = <span class=\"keyword\">this</span>.lock;</span><br><span class=\"line\">    lock.lock();</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        Object[] elements = getArray();</span><br><span class=\"line\">        <span class=\"keyword\">int</span> len = elements.length;</span><br><span class=\"line\">        Object[] newElements = Arrays.copyOf(elements, len + <span class=\"number\">1</span>);</span><br><span class=\"line\">        newElements[len] = e;</span><br><span class=\"line\">        setArray(newElements);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">        lock.unlock();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>CopyOnWriteArrayList.get实现</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> E <span class=\"title\">get</span><span class=\"params\">(<span class=\"keyword\">int</span> index)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> get(getArray(), index);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"cow在docker中的应用\">COW在Docker中的应用<a title=\"#cow在docker中的应用\" href=\"#cow在docker中的应用\"></a></h2>\n<p>COW一方面带来了容器启动的快捷，另一方也造成了容器镜像大小的增加。每一次 RUN 命令都会在镜像上增加一层，每一层都会占用磁盘空间。举个例子，在 Ubuntu 14.04 基础镜像中运行 RUN apt-get upgrade 会在保留基础层的同时再创建一个新层来放所有新的文件，而不是修改老的文件，因此，新的镜像大小会超过直接在老的文件系统上做更新时的文件大小。因此，为了减少镜像大小起见，所有文件相关的操作，比如删除，释放和移动等，都需要尽可能地放在一个 RUN 指令中进行。<br>\n比如说，通过将上面的示例 Dockerfile 修改为：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">FROM ubuntu:14.04</span><br><span class=\"line\">MAINTAINER sammy <span class=\"string\">&quot;sammy@sammy.com&quot;</span></span><br><span class=\"line\">RUN apt-get update &amp;&amp; apt-get -y install ntp</span><br><span class=\"line\">EXPOSE 5555</span><br><span class=\"line\">CMD [<span class=\"string\">&quot;/usr/sbin/ntpd&quot;</span>]</span><br></pre></td></tr></table></figure>\n<p>结果产生的镜像，不仅层数少了一层（7 -&gt; 6），而且大小减少了 0.001M ：），因为这个例子比较特殊，文件都是添加，而没有更新，因此size 的下降非常小</p>\n<h2 id=\"参考\">参考<a title=\"#参考\" href=\"#参考\"></a></h2>\n<p><a href=\"https://ifeve.com/java-copy-on-write/\" target=\"_blank\">聊聊并发-Java中的Copy-On-Write容器</a></p>\n","prev":{"title":"网络相关知识","link":"2018/12/11/网络相关知识"},"next":{"title":"CAS实现原理","link":"2018/10/13/CAS实现原理"},"plink":"https://zinki.github.io/2018/11/21/Copy-On-Write实现原理/","toc":[{"id":"什么是copyonwrite容器","title":"什么是CopyOnWrite容器","index":"1"},{"id":"cow在docker中的应用","title":"COW在Docker中的应用","index":"2"},{"id":"参考","title":"参考","index":"3"}]}