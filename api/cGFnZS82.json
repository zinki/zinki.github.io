{"per_page":10,"total":8,"current":6,"data":[{"title":"HashMap死循环问题","date":"2018-03-09T12:07:00.000Z","date_formatted":{"ll":"2018年3月9日","L":"2018/03/09","MM-DD":"03-09"},"excerpt":"<p>HashMap在并发执行put操作后get操作会引起死循环, 是因为多线程会导致 HashMap的 Entry链表形成环形数据结构, 一旦形成环形数据结构, Entry 的 next 节点永远不为空, 就会产生死循环获取Entry。","link":"2018/03/09/HashMap死循环问题","tags":["HashMap"],"categories":["学习"]},{"title":"Javascript引擎工作原理","date":"2018-02-06T14:09:00.000Z","date_formatted":{"ll":"2018年2月6日","L":"2018/02/06","MM-DD":"02-06"},"excerpt":"","link":"2018/02/06/Javascript引擎工作原理","tags":["Javascript"],"categories":["学习"]},{"title":"秒杀方案设计","date":"2018-01-17T12:05:00.000Z","date_formatted":{"ll":"2018年1月17日","L":"2018/01/17","MM-DD":"01-17"},"excerpt":"<p>秒杀的核心问题就是极高并发处理，由于系统要在瞬时承受平时数十倍甚至上百倍的流量，这往往超出系统上限，因此处理秒杀的核心思路是流控和性能优化","link":"2018/01/17/秒杀方案设计","tags":["秒杀"],"categories":["工作"]},{"title":"WebSocket原理","date":"2018-01-05T11:10:00.000Z","date_formatted":{"ll":"2018年1月5日","L":"2018/01/05","MM-DD":"01-05"},"excerpt":"<p>WebSocket 是一种在单个TCP连接上进行全双工通信的协议。WebSocket 使得客户端和服务器之间的数据交换变得更加简单，允许服务端主动向客户端推送数据。</p>\n<p>在 WebSocket API 中，浏览器和服务器只需要完成一次握手，两者之间就直接可以创建持久性的连接， 并进行双向数据传输。（维基百科）","link":"2018/01/05/WebSocket原理","tags":["WebSocket"],"categories":["学习"]},{"title":"深入分析ReentrantLock","date":"2017-12-13T12:17:00.000Z","date_formatted":{"ll":"2017年12月13日","L":"2017/12/13","MM-DD":"12-13"},"excerpt":"<p>ReentrantLock是java concurrent包提供的一种锁实现。不同于synchronized，ReentrantLock是从代码层面实现同步的。","link":"2017/12/13/深入分析ReentrantLock","tags":["ReentrantLock"],"categories":["学习"]},{"title":"Nginx部署实践","date":"2017-11-27T11:30:00.000Z","date_formatted":{"ll":"2017年11月27日","L":"2017/11/27","MM-DD":"11-27"},"excerpt":"<p>Nginx是一个高性能的HTTP和反向代理web服务器，同时也提供了IMAP/POP3/SMTP服务。","link":"2017/11/27/Nginx部署实践","tags":["Nginx"],"categories":["学习"]},{"title":"跨域及解决方案","date":"2017-11-05T12:19:00.000Z","date_formatted":{"ll":"2017年11月5日","L":"2017/11/05","MM-DD":"11-05"},"excerpt":"<p>同源策略是浏览器的一项最为基本同时也是必须遵守的安全策略。同源策略的存在，限制了“源”自A的脚本只能操作“同源”页面的DOM，“跨源”操作来源于B的页面将会被拒绝。所谓的“同源”，必须要求相应的URI在如下3个方面均是相同的。","link":"2017/11/05/跨域及解决方案","tags":["jsonp","跨域"],"categories":["学习"]},{"title":"并发常见问题","date":"2017-10-21T14:11:00.000Z","date_formatted":{"ll":"2017年10月21日","L":"2017/10/21","MM-DD":"10-21"},"excerpt":"<h2 id=\"start()方法和run()方法的区别\">start()方法和run()方法的区别<a title=\"#start()方法和run()方法的区别\" href=\"#start()方法和run()方法的区别\"></a></h2>\n<p>只有调用了start()方法，才会表现出多线程的特性，不同线程的run()方法里面的代码交替执行。如果只是调用run()方法，那么代码还是同步执行的，必须等待一个线程的run()方法里面的代码全部执行完毕之后，另外一个线程才可以执行其run()方法里面的代码</p>","link":"2017/10/21/并发常见问题","tags":["多线程","并发"],"categories":["学习"]},{"title":"自定义Feign日志打印","date":"2017-10-09T13:09:00.000Z","date_formatted":{"ll":"2017年10月9日","L":"2017/10/09","MM-DD":"10-09"},"excerpt":"<p>使用Feign进行Rest请求很方便，打印日志比较繁琐。AOP可以解决这个问题，对性能有所损耗；另一种办法是自定义日志输出","link":"2017/10/09/自定义Feign日志打印","tags":["Fegin","Spring boot"],"categories":["工作"]},{"title":"如何让JVM崩溃","date":"2017-09-27T13:00:00.000Z","date_formatted":{"ll":"2017年9月27日","L":"2017/09/27","MM-DD":"09-27"},"excerpt":"<p>A perfect JVM implementation will never crash.<br>\nTo crash a JVM, aside from JNI, you need to find a bug in the VM itself. An infinite loop just consumes CPU. Infinitely allocating memory should just cause OutOfMemoryError’s in a well built JVM. This would probably cause problems for other threads, but a good JVM still should not crash.<br>\nIf you can find a bug in the source code of the VM, and for example cause a segmentation fault in the memory usage of the implementation of the VM, then you can actually crash it.</p>","link":"2017/09/27/如何让JVM崩溃","tags":["JVM"],"categories":["学习"]}]}