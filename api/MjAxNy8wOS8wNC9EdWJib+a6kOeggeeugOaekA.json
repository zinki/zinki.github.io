{"title":"Dubbo源码简析","date":"2017-09-04T02:07:00.000Z","date_formatted":{"ll":"2017年9月4日","L":"2017/09/04","MM-DD":"09-04"},"link":"2017/09/04/Dubbo源码简析","tags":["Dubbo"],"categories":["学习"],"updated":"2024-11-02T11:31:53.868Z","content":"<p>RPC英文全名为Remote Procedure Call，也叫远程过程调用，其实就是一个计算机通信协议，它是一种通过网络从远程计算机程序上请求服务,而不需要了解底层网络技术的协议<span id=\"more\"></span><br>\n<img src=\"http://web.zeven.site/2024/10/202410110940741.png\" alt=\"\" loading=\"lazy\"></p>\n<h2 id=\"模块说明\">模块说明<a title=\"#模块说明\" href=\"#模块说明\"></a></h2>\n<ol>\n<li>dubbo-common 公共逻辑模块：包括 Util 类和通用模型。<br>\n通用模型就是贯穿整个项目的统一格式,例如URL<br>\nURL 作为配置信息的统一格式，所有扩展点都通过传递 URL 携带配置信息。<br>\ndubbo以URL为总线，运行过程中所有的状态数据信息都可以通过URL来获取，比如当前系统采用什么序列化，采用什么通信，采用什么负载均衡等信息，都是通过URL的参数来呈现的，所以在框架运行过程中，运行到某个阶段需要相应的数据，都可以通过对应的Key从URL的参数列表中获取。</li>\n<li>dubbo-remoting 远程通讯模块：相当于 Dubbo 协议的实现，如果 RPC 用 RMI协议则不需要使用此包。</li>\n<li>dubbo-rpc 远程调用模块：抽象各种协议，以及动态代理，只包含一对一的调用，不关心集群的管理。</li>\n<li>dubbo-cluster 集群模块：将多个服务提供方伪装为一个提供方，包括：负载均衡, 容错，路由等，集群的地址列表可以是静态配置的，也可以是由注册中心下发。</li>\n<li>dubbo-registry 注册中心模块：基于注册中心下发地址的集群方式，以及对各种注册中心的抽象。</li>\n<li>dubbo-monitor 监控模块：统计服务调用次数，调用时间的，调用链跟踪的服务。</li>\n<li>dubbo-config 配置模块：是 Dubbo 对外的 API，用户通过 Config 使用Dubbo，隐藏Dubbo 所有细节。</li>\n<li>dubbo-container 容器模块：是一个 Standlone 的容器，以简单的 Main 加载 Spring 启动，因为服务通常不需要 Tomcat/JBoss 等 Web 容器的特性，没必要用 Web 容器去加载服务。</li>\n</ol>\n<h2 id=\"核心领域模型\">核心领域模型<a title=\"#核心领域模型\" href=\"#核心领域模型\"></a></h2>\n<blockquote>\n<p>Protocol 是服务域，它是 Invoker 暴露和引用的主功能入口，它负责 Invoker 的生命周期管理。</p>\n</blockquote>\n<blockquote>\n<p>Invoker 是实体域，它是 Dubbo 的核心模型，其它模型都向它靠扰，或转换成它，它代表一个可执行体，可向它发起 invoke调用，它有可能是一个本地的实现，也可能是一个远程的实现，也可能一个集群实现。</p>\n</blockquote>\n<blockquote>\n<p>Invocation 是会话域，它持有调用过程中的变量，比如方法名，参数等。</p>\n</blockquote>\n<h2 id=\"spi\">SPI<a title=\"#spi\" href=\"#spi\"></a></h2>\n<p>SPI(Service Provider Interface)是Java提供的一种服务加载方式，可以避免在Java代码中写死服务提供者，而是通过SPI服务加载机制进行服务的注册和发现，实现多个模块的解耦。<br>\nJava SPI的具体约定为:在服务提供者提供了服务接口的一种实现之后，在Jar包的META-INF/services/目录里同时创建一个以服务接口命名的文件。该文件里的就是实现该服务接口的具体实现类。在外部程序装配这个模块时，就能通过该Jar包META-INF/services/里的配置文件找到具体的实现类名，并装载实例化，完成模块的注入。基于这样一个约定就能很好地找到服务接口的实现类，而不需要在代码里指定。JDK提供了服务实现查找的一个工具类，即java.util.ServiceLoader.</p>\n<p>Dubbo 并未使用 Java SPI，而是重新实现了一套功能更强的 SPI 机制。Dubbo SPI 的相关逻辑被封装在了 ExtensionLoader 类中，通过 ExtensionLoader，我们可以加载指定的实现类。Dubbo SPI 所需的配置文件需放置在META-INF/dubbo 路径下</p>\n<h2 id=\"消息体\">消息体<a title=\"#消息体\" href=\"#消息体\"></a></h2>\n<p><img src=\"http://web.zeven.site/2024/10/202410110940023.png\" alt=\"\" loading=\"lazy\" class=\"φbp\"></p>\n<p>Dubbo 数据包分为消息头和消息体，消息头用于存储一些元信息，比如魔数（Magic），数据包类型（Request/Response），消息体长度（Data Length）等。消息体中用于存储具体的调用消息，比如方法名称，参数列表等。下面简单列举一下消息头的内容。</p>\n<p>的调用消息，比如方法名称，参数列表等。下面简单列举一下消息头的内容。</p>\n<p><img src=\"http://web.zeven.site/2024/10/202410110941036.png\" alt=\"\" loading=\"lazy\" class=\"φbp\"></p>\n<p>对于双向通信，HeaderExchangeHandler 首先向后进行调用，得到调用结果。然后将调用结果封装到 Response 对象中，最后再将该对象返回给服务消费方。如果请求不合法，或者调用失败，则将错误信息封装到 Response 对象中，并返回给服务消费方</p>\n<h2 id=\"参考\">参考<a title=\"#参考\" href=\"#参考\"></a></h2>\n<p><a href=\"http://dubbo.apache.org/zh-cn/docs/dev/build.html\" target=\"_blank\">Dubbo官方文档</a></p>\n","prev":{"title":"如何让JVM崩溃","link":"2017/09/27/如何让JVM崩溃"},"next":{"title":"Echarts生成定时报表","link":"2017/08/17/Echarts定时报表"},"plink":"https://zinki.github.io/2017/09/04/Dubbo源码简析/","toc":[{"id":"模块说明","title":"模块说明","index":"1"},{"id":"核心领域模型","title":"核心领域模型","index":"2"},{"id":"spi","title":"SPI","index":"3"},{"id":"消息体","title":"消息体","index":"4"},{"id":"参考","title":"参考","index":"5"}]}