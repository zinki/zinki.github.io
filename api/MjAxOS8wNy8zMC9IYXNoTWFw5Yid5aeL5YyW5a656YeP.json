{"title":"HashMap初始化容量","date":"2019-07-30T13:00:00.000Z","date_formatted":{"ll":"2019年7月30日","L":"2019/07/30","MM-DD":"07-30"},"link":"2019/07/30/HashMap初始化容量","tags":["HashMap"],"categories":["学习"],"updated":"2024-10-10T08:03:05.444Z","content":"<p>HashMap初始化容量为2的次幂<span id=\"more\"></span></p>\n<p>hashMap源码获取元素的位置：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">static int indexFor(int h, int length) &#123;</span><br><span class=\"line\">    // assert Integer.bitCount(length) == 1 : &quot;length must be a non-zero power of 2&quot;;</span><br><span class=\"line\">    return h &amp; (length-1);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>解释：</p>\n<blockquote>\n<p>h:为插入元素的hashcode</p>\n</blockquote>\n<blockquote>\n<p>length:为map的容量大小</p>\n</blockquote>\n<blockquote>\n<p>&amp;：与操作 比如 1101 &amp; 1011=1001</p>\n</blockquote>\n<p>如果length为2的次幂  则length-1 转化为二进制必定是11111……的形式，在于h的二进制与操作效率会非常的快，<br>\n而且空间不浪费；</p>\n<p>如果length不是2的次幂，比如length为15，则length-1为14，对应的二进制为1110，在于h与操作，最后一位都为0，而0001，0011，0101，1001，1011，0111，1101这几个位置永远都不能存放元素了，空间浪费相当大，更糟的是这种情况中，数组可以使用的位置比数组长度小了很多，这意味着进一步增加了碰撞的几率，减慢了查询的效率！这样就会造成空间的浪费</p>\n","prev":{"title":"Int绝对值问题","link":"2019/08/29/int绝对值问题"},"next":{"title":"如何实现分布式锁","link":"2019/07/05/如何实现分布式锁"},"plink":"https://zinki.github.io/2019/07/30/HashMap初始化容量/"}