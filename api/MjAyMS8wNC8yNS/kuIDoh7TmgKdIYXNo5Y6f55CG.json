{"title":"一致性Hash原理","date":"2021-04-25T10:30:00.000Z","date_formatted":{"ll":"2021年4月25日","L":"2021/04/25","MM-DD":"04-25"},"link":"2021/04/25/一致性Hash原理","tags":["一致性Hash"],"categories":["学习"],"updated":"2024-11-02T11:31:53.916Z","content":"<blockquote>\n<p>在维基百科中，是这么定义的:<br>\n一致哈希是一种特殊的哈希算法。在使用一致哈希算法后，哈希表槽位数（大小）的改变平均只需要对 K/n个关键字重新映射，其中K是关键字的数量， n是槽位数量。然而在传统的哈希表中，添加或删除一个槽位的几乎需要对所有关键字进行重新映射。</p>\n</blockquote>\n<span id=\"more\"></span>\n<h3 id=\"使用hash时遇到的问题\">使用Hash时遇到的问题<a title=\"#使用hash时遇到的问题\" href=\"#使用hash时遇到的问题\"></a></h3>\n<p>在上述hash取模的过程中，我们虽然不需要对所有Redis服务器进行遍历而提升了性能。但是，使用Hash算法缓存时会出现一些问题，Redis服务器变动时，所有缓存的位置都会发生改变。 比如，现在我们的Redis缓存服务器增加到了8台，我们计算的公式从<code>hash(product.png) % 6 = 5</code>变成了<code>hash(product.png) % 8 = ?</code> 结果肯定不是原来的5了。<br>\n再者，6台的服务器集群中，当某个主从群出现故障时，无法进行缓存，那我们需要把故障机器移除，所以取模数又会从6变成了5。我们计算的公式也会变化。<br>\n由于上面hash算法是使用取模来进行缓存的，为了规避上述情况，Hash一致性算法就诞生了</p>\n<h3 id=\"一致性hash算法原理\">一致性Hash算法原理<a title=\"#一致性hash算法原理\" href=\"#一致性hash算法原理\"></a></h3>\n<p>一致性Hash算法也是使用取模的方法，不过，上述的取模方法是对服务器的数量进行取模，而一致性的Hash算法是对2的32方取模。即一致性Hash算法将整个Hash空间组织成一个虚拟的圆环，Hash函数的值空间为<code>0~2^32-1</code>(一个32位无符号整型)，整个哈希环如下：<br>\n<img src=\"http://web.zeven.site/2024/10/202410111023940.png\" alt=\"\" loading=\"lazy\"></p>\n<p>整个圆环以顺时针方向组织，圆环正上方的点代表0，0点右侧的第一个点代表1，以此类推。<br>\n第二步，我们将各个服务器使用Hash进行一个哈希，具体可以选择服务器的IP或主机名作为关键字进行哈希，这样每台服务器就确定在了哈希环的一个位置上，比如我们有三台机器，使用IP地址哈希后在环空间的位置如图所示<br>\n<img src=\"http://web.zeven.site/2024/10/202410111023890.png\" alt=\"\" loading=\"lazy\"></p>\n<p>现在，我们使用以下算法定位数据访问到相应的服务器：<br>\n将数据Key使用相同的函数Hash计算出哈希值，并确定此数据在环上的位置，从此位置沿环顺时针查找，遇到的服务器就是其应该定位到的服务器。<br>\n例如，现在有<code>ObjectA</code>，<code>ObjectB</code>，<code>ObjectC</code>三个数据对象，经过哈希计算后，在环空间上的位置如下：<br>\n<img src=\"http://web.zeven.site/2024/10/202410111023544.png\" alt=\"\" loading=\"lazy\"></p>\n<p>根据一致性算法，<code>Object -&gt; NodeA，ObjectB -&gt; NodeB, ObjectC -&gt; NodeC</code><br>\n一致性Hash算法的容错性和可扩展性<br>\n现在，假设我们的Node C宕机了，我们从图中可以看到，A、B不会受到影响，只有Object C对象被重新定位到Node A。所以我们发现，在一致性Hash算法中，如果一台服务器不可用，受影响的数据仅仅是此服务器到其环空间前一台服务器之间的数据（这里为Node C到Node B之间的数据），其他不会受到影响。如图所示：</p>\n<p><img src=\"http://web.zeven.site/2024/10/202410111024812.png\" alt=\"\" loading=\"lazy\"><br>\n另外一种情况，现在我们系统增加了一台服务器<code>Node X</code>，如图所示：</p>\n<p><img src=\"http://web.zeven.site/2024/10/202410111024683.png\" alt=\"\" loading=\"lazy\" class=\"φbp\"></p>\n<p>此时对象<code>ObjectA</code>、<code>ObjectB</code>没有受到影响，只有<code>ObjectC</code>重新定位到了新的节点X上。 如上所述：<br>\n一致性Hash算法对于节点的增减都只需重定位环空间中的一小部分数据，有很好的容错性和可扩展性。<br>\n数据倾斜问题<br>\n在一致性Hash算法服务节点太少的情况下，容易因为节点分布不均匀面造成数据倾斜（被缓存的对象大部分缓存在某一台服务器上）问题，如图特例：<br>\n<img src=\"http://web.zeven.site/2024/10/202410111025054.png\" alt=\"\" loading=\"lazy\"></p>\n<p>这时我们发现有大量数据集中在节点A上，而节点B只有少量数据。为了解决数据倾斜问题，一致性Hash算法引入了虚拟节点机制，即对每一个服务器节点计算多个哈希，每个计算结果位置都放置一个此服务节点，称为虚拟节点。<br>\n具体操作可以为服务器IP或主机名后加入编号来实现，实现如图所示：</p>\n<p><img src=\"http://web.zeven.site/2024/10/202410111026936.png\" alt=\"\" loading=\"lazy\" class=\"φbp\"></p>\n<p>数据定位算法不变，只需要增加一步：虚拟节点到实际点的映射。所以加入虚拟节点之后，即使在服务节点很少的情况下，也能做到数据的均匀分布。</p>\n<blockquote>\n<p>每个节点的可虚拟节点数，及总的虚拟节点数，应该有已被实践过的参考范围，而不应该是越多越好。同时，随着实际节点数的变化，对应的总的虚拟节点数也应该是动态的，而不是线性的</p>\n</blockquote>\n<blockquote>\n<p><code>redis</code>，<code>memcache</code>的第三方<code>Java Api</code>，及<code>Guava</code>中都有一致性hash的工具类，可以直接使用，也不用纠结于合理的虚拟节点的数目该怎么取，例如<code>Guava</code>中</p>\n</blockquote>\n<p><code>java</code><br>\n//guava源码说明<br>\npublic static int consistentHash(HashCode hashCode, int buckets) {<br>\nreturn consistentHash(hashCode.padToLong(), buckets);<br>\n}<br>\n//入参 buckets 是实际的集群节点，例如 buckets=3，表示有3台机器 1,2,3  当然通过这三个数字，也要能找到对应的机器信息（IP，端口等）<br>\n//入参 HashCode 这个类中有相应static函数，见下方，可以把实际查找的Key(无论是 int,long,String,byte[]) 转化为HashCode对象。<br>\n//返回值：int, 就是经过一致性hash处理后的buckets 中的一个值。注意该值范围是 0~（buckets-1），类似数组下标从0开始一样。<br>\nHashCode.fromBytes()<br>\nHashCode.fromInt()<br>\nHashCode.fromLong()<br>\nHashCode.fromString()</p>\n<pre><code>\n### 参考\n\n[一致性Hash原理与实现](https://www.jianshu.com/p/528ce5cd7e8f)</code></pre>\n","prev":{"title":"Netty线程模型","link":"2021/05/11/Netty线程模型"},"next":{"title":"Integer取值陷阱","link":"2021/04/11/Integer取值陷阱"},"plink":"https://zinki.github.io/2021/04/25/一致性Hash原理/","toc":[{"id":"使用hash时遇到的问题","title":"使用Hash时遇到的问题","index":"1"},{"id":"一致性hash算法原理","title":"一致性Hash算法原理","index":"2"}]}