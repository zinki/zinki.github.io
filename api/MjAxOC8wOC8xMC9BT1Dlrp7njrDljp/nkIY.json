{"title":"AOP实现原理","date":"2018-08-10T05:10:00.000Z","date_formatted":{"ll":"2018年8月10日","L":"2018/08/10","MM-DD":"08-10"},"link":"2018/08/10/AOP实现原理","tags":["AOP"],"categories":["学习"],"updated":"2024-10-11T01:37:00.515Z","content":"<p>AOP是目前Spring框架中的核心之一，在应用中具有非常重要的作用，也是Spring其他组件的基础。它是一种面向切面编程的思想<span id=\"more\"></span></p>\n<p>AOP的拦截功能是由java中的动态代理来实现的。说白了，就是在目标类的基础上增加切面逻辑，生成增强的目标类（该切面逻辑或者在目标类函数执行之前，或者目标类函数执行之后，或者在目标类函数抛出异常时候执行。不同的切入时机对应不同的Interceptor的种类，如BeforeAdviseInterceptor，AfterAdviseInterceptor以及ThrowsAdviseInterceptor等）。</p>\n<p>那么动态代理是如何实现将切面逻辑（advise）织入到目标类方法中去的呢？下面我们就来详细介绍并实现AOP中用到的两种动态代理。<br>\nAOP的源码中用到了两种动态代理来实现拦截切入功能：jdk动态代理和cglib动态代理。两种方法同时存在，各有优劣。jdk动态代理是由java内部的反射机制来实现的，cglib动态代理底层则是借助asm来实现的。总的来说，反射机制在生成类的过程中比较高效，而asm在生成类之后的相关执行过程中比较高效（可以通过将asm生成的类进行缓存，这样解决asm生成类过程低效问题）。还有一点必须注意：jdk动态代理的应用前提，必须是目标类基于统一的接口。如果没有上述前提，jdk动态代理不能应用。由此可以看出，jdk动态代理有一定的局限性，cglib这种第三方类库实现的动态代理应用更加广泛，且在效率上更有优势。</p>\n<h2 id=\"jdk动态代理实现aop拦截\">jdk动态代理实现AOP拦截<a title=\"#jdk动态代理实现aop拦截\" href=\"#jdk动态代理实现aop拦截\"></a></h2>\n<p>1、为目标类（target）定义统一的接口类Service，这个是jdk动态代理必须的前提。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[java] view plain copy</span><br><span class=\"line\"><span class=\"keyword\">package</span> jdkproxy;  </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/** </span></span><br><span class=\"line\"><span class=\"comment\"> * 该类是所有被代理类的接口类，jdk实现的代理要求被代理类基于统一的接口 </span></span><br><span class=\"line\"><span class=\"comment\"> *  </span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@author</span> typ </span></span><br><span class=\"line\"><span class=\"comment\"> *  </span></span><br><span class=\"line\"><span class=\"comment\"> */</span>  </span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Service</span> </span>&#123;  </span><br><span class=\"line\">    <span class=\"comment\">/** </span></span><br><span class=\"line\"><span class=\"comment\">     * add方法 </span></span><br><span class=\"line\"><span class=\"comment\">     */</span>  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">add</span><span class=\"params\">()</span></span>;  </span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/** </span></span><br><span class=\"line\"><span class=\"comment\">     * update方法 </span></span><br><span class=\"line\"><span class=\"comment\">     */</span>  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">update</span><span class=\"params\">()</span></span>;  </span><br><span class=\"line\">&#125;  </span><br></pre></td></tr></table></figure>\n<p>2、目标类AService，我们的实验目标就是在AService中add和update方法的前后实现拦截，加入自定义切面逻辑advise</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[java] view plain copy</span><br><span class=\"line\"><span class=\"keyword\">package</span> jdkproxy;  </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/** </span></span><br><span class=\"line\"><span class=\"comment\"> * 被代理类，即目标类target </span></span><br><span class=\"line\"><span class=\"comment\"> *  </span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@author</span> typ </span></span><br><span class=\"line\"><span class=\"comment\"> *  </span></span><br><span class=\"line\"><span class=\"comment\"> */</span>  </span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AService</span> <span class=\"keyword\">implements</span> <span class=\"title\">Service</span> </span>&#123;  </span><br><span class=\"line\">    <span class=\"comment\">/* </span></span><br><span class=\"line\"><span class=\"comment\">     * (non-Javadoc) </span></span><br><span class=\"line\"><span class=\"comment\">     *  </span></span><br><span class=\"line\"><span class=\"comment\">     * @see jdkproxy.Service#add() </span></span><br><span class=\"line\"><span class=\"comment\">     */</span>  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">add</span><span class=\"params\">()</span> </span>&#123;  </span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;AService add&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&quot;</span>);  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/* </span></span><br><span class=\"line\"><span class=\"comment\">     * (non-Javadoc) </span></span><br><span class=\"line\"><span class=\"comment\">     *  </span></span><br><span class=\"line\"><span class=\"comment\">     * @see jdkproxy.Service#update() </span></span><br><span class=\"line\"><span class=\"comment\">     */</span>  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">update</span><span class=\"params\">()</span> </span>&#123;  </span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;AService update&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&quot;</span>);  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;  </span><br></pre></td></tr></table></figure>\n<p>3、实现动态代理类MyInvocationHandler，实现InvocationHandler接口，并且实现接口中的invoke方法。仔细看invoke方法，就是在该方法中加入切面逻辑的。目标类方法的执行是由mehod.invoke(target,args)这条语句完成。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[java] view plain copy</span><br><span class=\"line\"><span class=\"keyword\">package</span> jdkproxy;  </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.lang.reflect.InvocationHandler;  </span><br><span class=\"line\"><span class=\"keyword\">import</span> java.lang.reflect.Method;  </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/** </span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@author</span> typ </span></span><br><span class=\"line\"><span class=\"comment\"> * </span></span><br><span class=\"line\"><span class=\"comment\"> */</span>  </span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyInvocationHandler</span> <span class=\"keyword\">implements</span> <span class=\"title\">InvocationHandler</span> </span>&#123;  </span><br><span class=\"line\">    <span class=\"keyword\">private</span> Object target;  </span><br><span class=\"line\"></span><br><span class=\"line\">    MyInvocationHandler() &#123;  </span><br><span class=\"line\">        <span class=\"keyword\">super</span>();  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\"></span><br><span class=\"line\">    MyInvocationHandler(Object target) &#123;  </span><br><span class=\"line\">        <span class=\"keyword\">super</span>();  </span><br><span class=\"line\">        <span class=\"keyword\">this</span>.target = target;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Object <span class=\"title\">invoke</span><span class=\"params\">(Object proxy, Method method, Object[] args)</span>  </span></span><br><span class=\"line\"><span class=\"function\">            <span class=\"keyword\">throws</span> Throwable </span>&#123;  </span><br><span class=\"line\">        <span class=\"comment\">// 程序执行前加入逻辑，MethodBeforeAdviceInterceptor  </span></span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;before-----------------------------&quot;</span>);  </span><br><span class=\"line\">        <span class=\"comment\">// 程序执行  </span></span><br><span class=\"line\">        Object result = method.invoke(target, args);  </span><br><span class=\"line\">        <span class=\"comment\">// 程序执行后加入逻辑，MethodAfterAdviceInterceptor  </span></span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;after------------------------------&quot;</span>);  </span><br><span class=\"line\">        <span class=\"keyword\">return</span> result;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\"></span><br><span class=\"line\">&#125;  </span><br></pre></td></tr></table></figure>\n<p>4、测试类，其中增强的目标对象是由Proxy.newProxyInstance(aService.getClass().getClassLoader(), aService.getClass().getInterfaces(), handler);来生成的。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[java] view plain copy</span><br><span class=\"line\"><span class=\"keyword\">package</span> jdkproxy;  </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.lang.reflect.Proxy;  </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/** </span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@author</span> typ </span></span><br><span class=\"line\"><span class=\"comment\"> * </span></span><br><span class=\"line\"><span class=\"comment\"> */</span>  </span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Test</span> </span>&#123;  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;  </span><br><span class=\"line\">        Service aService = <span class=\"keyword\">new</span> AService();  </span><br><span class=\"line\">        MyInvocationHandler handler = <span class=\"keyword\">new</span> MyInvocationHandler(aService);  </span><br><span class=\"line\">        <span class=\"comment\">// Proxy为InvocationHandler实现类动态创建一个符合某一接口的代理实例  </span></span><br><span class=\"line\">        Service aServiceProxy = (Service) Proxy.newProxyInstance(aService  </span><br><span class=\"line\">                .getClass().getClassLoader(), aService.getClass()  </span><br><span class=\"line\">                .getInterfaces(), handler);  </span><br><span class=\"line\">        <span class=\"comment\">// 由动态生成的代理对象来aServiceProxy 代理执行程序，其中aServiceProxy 符合Service接口  </span></span><br><span class=\"line\">        aServiceProxy.add();  </span><br><span class=\"line\">        System.out.println();  </span><br><span class=\"line\">        aServiceProxy.update();  </span><br><span class=\"line\">        <span class=\"comment\">// 以下是对B的代理  </span></span><br><span class=\"line\">        <span class=\"comment\">// Service bService = new BService();  </span></span><br><span class=\"line\">        <span class=\"comment\">// MyInvocationHandler handler = new MyInvocationHandler(bService);  </span></span><br><span class=\"line\">        <span class=\"comment\">// Service bServiceProxy = (Service) Proxy.newProxyInstance(bService  </span></span><br><span class=\"line\">        <span class=\"comment\">// .getClass().getClassLoader(), bService.getClass()  </span></span><br><span class=\"line\">        <span class=\"comment\">// .getInterfaces(), handler);  </span></span><br><span class=\"line\">        <span class=\"comment\">// bServiceProxy.add();  </span></span><br><span class=\"line\">        <span class=\"comment\">// System.out.println();  </span></span><br><span class=\"line\">        <span class=\"comment\">// bServiceProxy.update();  </span></span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;  </span><br></pre></td></tr></table></figure>\n<p>自此，jdk动态代理来实现AOP拦截机制的代码已经实现，下面我们看一下拦截的结果，程序输出结果如下：</p>\n<figure class=\"highlight basic\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">before-----------------------------</span><br><span class=\"line\">AService add&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class=\"line\">after------------------------------</span><br><span class=\"line\">before-----------------------------</span><br><span class=\"line\">AService update&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class=\"line\">after------------------------------</span><br></pre></td></tr></table></figure>\n<p>可以看到，在目标类AService的add和update方法前后已经加入了自定义的切面逻辑，AOP拦截机制生效了。</p>\n<h2 id=\"cglib动态代理实现aop拦截\">cglib动态代理实现AOP拦截<a title=\"#cglib动态代理实现aop拦截\" href=\"#cglib动态代理实现aop拦截\"></a></h2>\n<p>1、目标类，cglib不需要定义目标类的统一接口</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ß[java] view plain copy</span><br><span class=\"line\"><span class=\"keyword\">package</span> cglibproxy;  </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/** </span></span><br><span class=\"line\"><span class=\"comment\"> * 被代理类，即目标对象target </span></span><br><span class=\"line\"><span class=\"comment\"> *  </span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@author</span> typ </span></span><br><span class=\"line\"><span class=\"comment\"> *  </span></span><br><span class=\"line\"><span class=\"comment\"> */</span>  </span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Base</span> </span>&#123;  </span><br><span class=\"line\">    <span class=\"comment\">/** </span></span><br><span class=\"line\"><span class=\"comment\">     * 一个模拟的add方法 </span></span><br><span class=\"line\"><span class=\"comment\">     */</span>  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">add</span><span class=\"params\">()</span> </span>&#123;  </span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;add ------------&quot;</span>);  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;  </span><br></pre></td></tr></table></figure>\n<p>2、实现动态代理类CglibProxy，需要实现MethodInterceptor接口，实现intercept方法。该代理中在add方法前后加入了自定义的切面逻辑，目标类add方法执行语句为proxy.invokeSuper(object, args);</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[java] view plain copy</span><br><span class=\"line\"><span class=\"keyword\">package</span> cglibproxy;  </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.lang.reflect.Method;  </span><br><span class=\"line\"><span class=\"keyword\">import</span> net.sf.cglib.proxy.MethodInterceptor;  </span><br><span class=\"line\"><span class=\"keyword\">import</span> net.sf.cglib.proxy.MethodProxy;  </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/** </span></span><br><span class=\"line\"><span class=\"comment\"> * 此为代理类，用于在pointcut处添加advise </span></span><br><span class=\"line\"><span class=\"comment\"> *  </span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@author</span> typ </span></span><br><span class=\"line\"><span class=\"comment\"> *  </span></span><br><span class=\"line\"><span class=\"comment\"> */</span>  </span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CglibProxy</span> <span class=\"keyword\">implements</span> <span class=\"title\">MethodInterceptor</span> </span>&#123;  </span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Object <span class=\"title\">intercept</span><span class=\"params\">(Object object, Method method, Object[] args,  </span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">            MethodProxy proxy)</span> <span class=\"keyword\">throws</span> Throwable </span>&#123;  </span><br><span class=\"line\">        <span class=\"comment\">// 添加切面逻辑（advise），此处是在目标类代码执行之前，即为MethodBeforeAdviceInterceptor。  </span></span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;before-------------&quot;</span>);  </span><br><span class=\"line\">        <span class=\"comment\">// 执行目标类add方法  </span></span><br><span class=\"line\">        proxy.invokeSuper(object, args);  </span><br><span class=\"line\">        <span class=\"comment\">// 添加切面逻辑（advise），此处是在目标类代码执行之后，即为MethodAfterAdviceInterceptor。  </span></span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;after--------------&quot;</span>);  </span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\"></span><br><span class=\"line\">&#125;  </span><br></pre></td></tr></table></figure>\n<p>3、获取增强的目标类的工厂Factory，其中增强的方法类对象是有Enhancer来实现的，代码如下所示：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[java] view plain copy</span><br><span class=\"line\"><span class=\"keyword\">package</span> cglibproxy;  </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> net.sf.cglib.proxy.Enhancer;  </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/** </span></span><br><span class=\"line\"><span class=\"comment\"> * 工厂类，生成增强过的目标类（已加入切入逻辑） </span></span><br><span class=\"line\"><span class=\"comment\"> *  </span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@author</span> typ </span></span><br><span class=\"line\"><span class=\"comment\"> *  </span></span><br><span class=\"line\"><span class=\"comment\"> */</span>  </span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Factory</span> </span>&#123;  </span><br><span class=\"line\">    <span class=\"comment\">/** </span></span><br><span class=\"line\"><span class=\"comment\">     * 获得增强之后的目标类，即添加了切入逻辑advice之后的目标类 </span></span><br><span class=\"line\"><span class=\"comment\">     *  </span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> proxy </span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> </span></span><br><span class=\"line\"><span class=\"comment\">     */</span>  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Base <span class=\"title\">getInstance</span><span class=\"params\">(CglibProxy proxy)</span> </span>&#123;  </span><br><span class=\"line\">        Enhancer enhancer = <span class=\"keyword\">new</span> Enhancer();  </span><br><span class=\"line\">        enhancer.setSuperclass(Base.class);  </span><br><span class=\"line\">        <span class=\"comment\">//回调方法的参数为代理类对象CglibProxy，最后增强目标类调用的是代理类对象CglibProxy中的intercept方法  </span></span><br><span class=\"line\">        enhancer.setCallback(proxy);  </span><br><span class=\"line\">        <span class=\"comment\">// 此刻，base不是单纯的目标类，而是增强过的目标类  </span></span><br><span class=\"line\">        Base base = (Base) enhancer.create();  </span><br><span class=\"line\">        <span class=\"keyword\">return</span> base;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;  </span><br></pre></td></tr></table></figure>\n<p>4、测试类</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[java] view plain copy</span><br><span class=\"line\"><span class=\"keyword\">package</span> cglibproxy;  </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/** </span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@author</span> typ </span></span><br><span class=\"line\"><span class=\"comment\"> * </span></span><br><span class=\"line\"><span class=\"comment\"> */</span>  </span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Test</span> </span>&#123;  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;  </span><br><span class=\"line\">        CglibProxy proxy = <span class=\"keyword\">new</span> CglibProxy();  </span><br><span class=\"line\">        <span class=\"comment\">// base为生成的增强过的目标类  </span></span><br><span class=\"line\">        Base base = Factory.getInstance(proxy);  </span><br><span class=\"line\">        base.add();  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;  </span><br></pre></td></tr></table></figure>\n<p>自此，cglib动态代理实现的AOP拦截机制已经基本实现，下面我们来看一下拦截的效果如何，程序执行结果如下：</p>\n<figure class=\"highlight basic\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">before-------------</span><br><span class=\"line\">add ------------</span><br><span class=\"line\">after--------------</span><br></pre></td></tr></table></figure>\n<p>可以看到，在目标类Base的add方法前后已经加入了自定义的切面逻辑，AOP拦截机制生效了。<br>\n此外，需要说明一下的是，cglib动态代理用到了第三方类库，需要在项目中引入两个jar包：cglib.jar和asm.jar。</p>\n<p>java动态代理是利用反射机制生成一个实现代理接口的匿名类，在调用具体方法前调用InvokeHandler来处理。而cglib动态代理是利用asm开源包，对代理对象类的class文件加载进来，通过修改其字节码生成子类来处理。<br>\n1、如果目标对象实现了接口，默认情况下会采用JDK的动态代理实现AOP<br>\n2、如果目标对象实现了接口，可以强制使用CGLIB实现AOP<br>\n3、如果目标对象没有实现了接口，必须采用CGLIB库，spring会自动在JDK动态代理和CGLIB之间转换</p>\n","prev":{"title":"IOC实现原理","link":"2018/08/26/IOC实现原理"},"next":{"title":"AUFS DOCKER基础技术","link":"2018/08/10/AUFS DOCKER基础技术"},"plink":"https://zinki.github.io/2018/08/10/AOP实现原理/","toc":[{"id":"jdk动态代理实现aop拦截","title":"jdk动态代理实现AOP拦截","index":"1"},{"id":"cglib动态代理实现aop拦截","title":"cglib动态代理实现AOP拦截","index":"2"}]}