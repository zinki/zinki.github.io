{"title":"ElasticSearch相关知识","date":"2019-06-15T11:00:00.000Z","date_formatted":{"ll":"2019年6月15日","L":"2019/06/15","MM-DD":"06-15"},"link":"2019/06/15/ElasticSearch相关知识","tags":["ElasticSearch"],"categories":["学习"],"updated":"2024-10-10T08:03:05.442Z","content":"<p>Elasticsearch的核心概念如下：<span id=\"more\"></span></p>\n<blockquote>\n<p>Cluster: 集群，由一个或多个Elasticsearch 节点组成。</p>\n</blockquote>\n<blockquote>\n<p>Node: 节点，组成Elasticsearch集群的服务单元，同一个集群内节点的名字不能重复。通常在一个节点上分配一个或者多个分片。</p>\n</blockquote>\n<blockquote>\n<p>Shards: 分片，当索引上的数据量太大的时候，我们通常会将-一个索引.上的数据进行水平拆分，拆分出来的每个数据块叫作-一个分片。 在一个多分片的索引中写入数据时，通过路由来确定具体写入那一一个分片中，所以在创建索引时需要指定分片的数量，并且分片的数量一旦确定就不能更改。分片后的索引带来了规模上(数据水平切分)和性能上(并行执行)的提升。每个分片都是Lucene中的一个索引文件，每个分片必须<br>\n有一个主分片和零到多个副本分片。</p>\n</blockquote>\n<blockquote>\n<p>Replicas: 备份也叫作副本，是指对主分片的备份。主分片和备份分片都可以对外提供查询服务，写操作时先在主分片上完成，然后分发到备份上。当主分片不可用时，会在备份的分片中选举出-一个作为主分片，所以备份不仅可以提升系统的高可用性能，还可以提升搜索时的并发性能。但是若副本太多的话，在写操作时会增加数据同步的负担。</p>\n</blockquote>\n<blockquote>\n<p>Index: 索引，由一个和多个分片组成，通过索引的名字在集群内进行唯一标识。</p>\n</blockquote>\n<blockquote>\n<p>Type: 类别，指索引内部的逻辑分区，通过Type的名字在索引内进行唯一标识。在查询时如果没有该值，则表示在整个索引中查询。</p>\n</blockquote>\n<blockquote>\n<p>Document: 文档，索引中的每一 条数据叫一个文档，类似于关系型数据库中的-条数据，通过_ id 在Type内进行唯一标识。</p>\n</blockquote>\n<blockquote>\n<p>Settings: 对集群中索引的定义，比如一个索引默认的分片数、副本数等信息。</p>\n</blockquote>\n<blockquote>\n<p>Mapping: 类似于关系型数据库中的表结构信息，用于定义索引中字段(Field) 的存储类型、分词方式、是否存储等信息。Elasticsearch 中的mapping是可以动态识别的。如果没有特殊需求，则不需要手动创建mapping,因为Elasticsearch会自动根据数据格式识别它的类型，但是当需要对某些字段添加特殊属性(比如:定义使用其他分词器、是否分词、是否存储等)时，就需要手动设置mapping了。一个索引的mapping一旦创建，若已经存储了数据，就不可修改了。</p>\n</blockquote>\n<blockquote>\n<p>Analyzer: 字段的分词方式的定义。一个analyzer 通常由一个tokenizer、 零到多个Filter组成。比如默认的标准Analyzer包含一个标准的tokenizer 和三个filter: Standard TokenFilter、Lower Case Token Filter、Stop Token Filter。</p>\n</blockquote>\n<p>Elasticsearch的节点的分类如下:</p>\n<blockquote>\n<p>主节点(Master Node):也叫作主节点，主节点负责创建索引、删除索引、分配分片、追踪集群中的节点状态等工作。Elasticsearch 中的主节点的工作量相对较轻。用户的请求可以发往任何一个节点，并由该节点负责分发请求、收集结果等操作，而并不需要经过主节点转发。通过在配置文件中设置node.master =true来设置该节点成为候选主节点(但该节点并不一-定是主节点，主节点是集群在候选节点中选举出来的)，在Elasticsearch集群中只有候选节点才有选举权和被选举权。其他节点是不参与选举工作的。</p>\n</blockquote>\n<blockquote>\n<p>数据节点 (Data Node):数据节点，负责数据的存储和相关具体操作，比如索引数据的创建、修改、删除、搜索、聚合。所以，数据节点对机器配置要求比较高，首先需要有足够的磁盘空间来存储数据，其次数据操作对系统CPU、Memory和I/O的性能消耗都很大。通常随着集群的扩大，需要增加更多的数据节点来提高可用性。通过在配置文件中设置node.data=true来设置该节点成为数据节点。</p>\n</blockquote>\n<blockquote>\n<p>客户端节 点(Client Node):就是既不做候选主节点也不做数据节点的节点，只负责请<br>\n求的分发、汇总等，也就是下面要说到的协调节点的角色。其实任何一个节点都可以完成这样的工作，单独增加这样的节点更多地是为了提高并发性。<br>\n可在配置文件中设置该节点成为数据节点:</p>\n</blockquote>\n<figure class=\"highlight basic\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">node.master =false</span><br><span class=\"line\">node.<span class=\"keyword\">data</span>=false</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>户端节点(Client Node):就是既不做候选主节点也不做数据节点的节点，只负责请求的分发、汇总等，也就是下面要说到的协调节点的角色。其实任何一个节点都可以完成这样的工作，单独增加这样的节点更多地是为了提高并发性。<br>\n可在配置文件中设置该节点成为数据节点:</p>\n</blockquote>\n<figure class=\"highlight basic\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">node. master =false</span><br><span class=\"line\">node.<span class=\"keyword\">data</span>=false</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>部落节点(Tribe Node):部落节点可以跨越多个集群，它可以接收每个集群的状态，<br>\n然后合并成一个全局集群的状态，它可以读写所有集群节点上的数据，在配置文件中通过如下设置使节点成为部落节点:</p>\n</blockquote>\n<figure class=\"highlight basic\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tribe:</span><br><span class=\"line\">    one:</span><br><span class=\"line\">        cluster .<span class=\"keyword\">name</span>:cluster one</span><br><span class=\"line\">    two:</span><br><span class=\"line\">        cluster. <span class=\"keyword\">name</span>:cluster two</span><br></pre></td></tr></table></figure>\n<p>因为Tribe Node要在Elasticsearch 7.0以后移除，所以不建议使用。</p>\n<blockquote>\n<p>协调节 点(Coordinating Node): 协调节点，是一种角色，而不是真实的Elasticsearch的节点，我们没有办法通过配置项来配置哪个节点为协调节点。集群中的任何节点都可以充当协调节点的角色。当一个节点A收到用户的查询请求后，会把查询语句分发到其他的节点，然后合并各个节点返回的查询结果，最后返回一个完整的数据集给用户。在这个过程中，节点A扮演的就是协调节点的角色。由此可见，协调节点会对CPU、Memory和I/O要求比较高。</p>\n</blockquote>\n<p>Elasticsearch默认的堆内存大小是1GB,由于Elasticsearch是-一个比较耗内存的应用，所以对于大部分应用来说，这个值太小。我们可以通过一些方式来改变堆内存的大小。如果是通过解压安装包安装的Elasticsearch， 则在Elasticsearch 安装包下的config 文件夹中包含一个jvm.option文件，打开该文件，添加如下命令来设置Elasticsearch的堆大小:</p>\n<figure class=\"highlight basic\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-Xms5g</span><br><span class=\"line\">-Xmx5g</span><br><span class=\"line\">或者</span><br><span class=\"line\">-Xms5000m</span><br><span class=\"line\">-Xmx5000m</span><br></pre></td></tr></table></figure>\n<p>该命令表示堆的初始大小(Xms)和可分配的最大内存(Xmx)都是5GB。建议在设置堆大小时让初始大小和最大可分配的值一-样，这样就可以避免在运行时因为改变堆内存的大小而导致系统资源浪费。<br>\n也可以通过设置环境变量的方式设置堆的大小。比如:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">export</span> ES HEAP SIZE=5g</span><br></pre></td></tr></table></figure>\n<p>在启动Elasticsearch时设置堆的大小:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">. /bin/elasticsearch -Xmx5g  -Xms5g</span><br></pre></td></tr></table></figure>\n<p>这种设置方式并不是一劳永逸的，在每次启动Elasticsearch时都需要添加-Xmx5g -Xms5g参数。</p>\n<p>如果服务器有足够多的内存，那么是否给堆内存分配的内存越大越好?虽然内存对Elasticsearch来说是非常重要的，但是答案是否定的!因为Elasticsearch堆内存的分配要考虑以下两个原则。</p>\n<ol>\n<li>\n<p>最好不要超过物理内存的50%。因为Elasticsearch 底层是Lucene实现的。由于Lucene段的不变性，所以我们不用考虑数据的变化，这对缓存来说是非常友好的。操作系统可以把这些文件缓存在操作系统的文件缓存系统(Filesystem Cache)中而非堆内存中，如果我们设置的堆内存过大，导致系统可用的内存太小，就会严重影响Lucene的全文本查询性能。</p>\n</li>\n<li>\n<p>堆内存的大小最好不要超过32GB。在Java中，所有对象都分配在堆上，并且每个对象头都通过-一个Klass Pointer 指针指向它的类元数据，而这个指针在64位的操作系统上为64位，在32位的系统上为32位。32位的操作系统的最大寻址空间为4GB(232)，64位的操作系统可以使用更多的内存(264)。 但是在64位的操作系统上，因为指针本身变大了，所以会有更大的空间浪费在指针本身上，更糟糕的是，更大的指针在主内存和各级缓存(例如LLC、LI等)之间移动数据时，会占用更多的带宽。<br>\nJava使用内存指针压缩(Compressed Oops)技术来解决这个问题。它的指针不再表示对象在内存中的精确位置，而是表示偏移量。这意味着32位的指针可以引用4GB个Byte，而不是4GB个bit。也就是说，堆内存为32GB的物理内存，也可以用32位的指针表示。</p>\n</li>\n</ol>\n<p>所以，在越过那个神奇的边界–32GB 时，指针就会切回为普通对象的指针，每个对象的指针都变长了，就会浪费更多的内存，降低了CPU的性能，还要让GC应对大的内存。事实上，当内存到达40<code>~</code>50GB时，有效的内存才相当于使用内存对象指针压缩技术时的32GB内存，所以在大内存的服务器上设置的堆大小要小于32GB，比如可以设置为31GB:</p>\n<figure class=\"highlight basic\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-Xms31g</span><br><span class=\"line\">-Xmx31g</span><br></pre></td></tr></table></figure>\n<p>虽然32GB是一个很重要的分割线，但是随着硬件成本的下降，现在有大内存的服务器愈发常见，比如一台有128GB内存的服务器。这时我们需要根据以下业务场景来考虑内存的分配情况。</p>\n<ol>\n<li>\n<p>如果业务场景是以全文检索为主的，则依然可以给Elasticsearch 分配小于32GB的堆内存，而把剩下的大部分内存空间留给Lucene，让Luccene通过操作系统的文件缓存系统来缓存更多的segment,使Lucene带来极速的全文检索。</p>\n</li>\n<li>\n<p>如果在业务场景中有很多的排序和聚合，而且大部分聚合计算是在数字、日期、地理点等非分词的字符串上的，则聚合计算将在内存友好的doc values (非堆内存).上完成!我们依然可以为Elasticsearch 分配小于32GB的堆内存，其余部分为操作系统的缓存使用doc values。</p>\n</li>\n<li>\n<p>如果在业务场景中有很多排序和聚合，并且是在分词的字段上进行的，则不幸的是，我们需要fielddata来缓存。但是和doc values不同，fielddata 是分配在堆内存上的，这时就需要分配更多的堆内存了，但是让一个节点拥有太大的堆内存，并不是一种明智的选择。可以考虑在同一台服务上部署多个节点，使得每个节点的内存分配不超过32GB，不会有太多的资源浪费。</p>\n</li>\n</ol>\n<p>使用ES构建mapping时,不是string类型的属性,不允许分词操作</p>\n<p>常用命令</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">curl -u elastic:elastic -XPOST <span class=\"string\">&#x27;http://10.113.9.95:9200/user_label_1/user_label_1/1787395/_update&#x27;</span> -d <span class=\"string\">&#x27;&#123;&quot;doc&quot;:&#123;&quot;user_id&quot;:&quot;1787395&quot;,&quot;is_pay_member&quot;:&quot;1&quot;,&quot;vip_staff_id&quot;:&quot;cs6426&quot;&#125;&#125;&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\">curl -u elastic:elastic -XPUT <span class=\"string\">&#x27;http://10.113.9.95:9200/user_label_1/user_label_1/id&#x27;</span> -d <span class=\"string\">&#x27;&#123;&quot;user_id&quot;:&quot;10085&quot;,&quot;vip_staff_id&quot;:&quot;cs6428&quot;&#125;&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\">curl  -u elastic:elastic -XDELETE http://10.113.9.95:9200/user_label_1/user_label_1/10085/</span><br><span class=\"line\"></span><br><span class=\"line\"> curl -u elastic:elastic -XGET http://10.113.9.95:9200/user_label_1/user_label_1/_search?q=user_id:10085</span><br></pre></td></tr></table></figure>\n","prev":{"title":"如何实现分布式锁","link":"2019/07/05/如何实现分布式锁"},"next":{"title":"Zookeeper相关知识","link":"2019/05/21/Zookeepe相关知识"},"plink":"https://zinki.github.io/2019/06/15/ElasticSearch相关知识/"}