{"title":"数据库相关知识","date":"2019-10-05T09:10:00.000Z","date_formatted":{"ll":"2019年10月5日","L":"2019/10/05","MM-DD":"10-05"},"link":"2019/10/05/数据库相关知识","tags":["数据库"],"categories":["学习"],"updated":"2024-10-10T08:03:05.471Z","content":"<p>SQL标准中规定的RR并不能消除幻读，但是MySQL的RR可以，<span id=\"more\"></span>靠的就是next-key lock，而next-key lock区别于普通行锁的核心，就是GAP锁。<br>\nNext-Key锁由行锁 + Gap锁组成。<br>\nGAP(间隙)锁的中心思想，就是不仅对第一次查询查出来的记录加锁，而且对查询条件这个范围加锁，从而避免了幻读。<br>\n间隙锁是对索引记录中的一段连续区域的锁；当使用类似 SELECT * FROM users WHERE id BETWEEN 10 AND 20 FOR UPDATE; 的 SQL 语句时，就会阻止其他事务向表中插入 id = 15 的记录，因为整个范围都被间隙锁锁定了。</p>\n<p>Innodb的实现方式是：</p>\n<ol>\n<li>事务以排他锁的形式修改原始数据</li>\n<li>把修改前的数据存放于undo log，通过回滚指针与主数据关联</li>\n<li>修改成功（commit）啥都不做，失败则恢复undo log中的数据（rollback）</li>\n</ol>\n<p>InnoDB的MVCC,是通过在每行记录后面保存两个隐藏的列来实现的,这两个列，分别保存了这个行的创建时间，一个保存的是行的删除时间。这里存储的并不是实际的时间值,而是系统版本号(可以理解为事务的ID)，每开始一个新的事务，系统版本号就会自动递增，事务开始时刻的系统版本号会作为事务的ID.</p>\n<p>理想MVCC难以实现的根本原因在于企图通过乐观锁代替二段提交。修改两行数据，但为了保证其一致性，与修改两个分布式系统中的数据并无区别，而二提交是目前这种场景保证一致性的唯一手段。二段提交的本质是锁定，乐观锁的本质是消除锁定，二者矛盾，故理想的MVCC难以真正在实际中被应用，Innodb只是借了MVCC这个名字，提供了读的非阻塞而已。</p>\n<p>既然 InnoDB 中实现的锁是悲观的，那么不同事务之间就可能会互相等待对方释放锁造成死锁，最终导致事务发生错误；想要在 MySQL 中制造死锁的问题其实非常容易<br>\n<img src=\"https://i.loli.net/2020/06/09/wiMehDsWtkjXOc7.jpg\" alt=\"\" loading=\"lazy\"><br>\nInnoDB一般都能自动检测到，并使一个事务释放锁并回退，另一个事务获得锁，继续完成事务</p>\n<p>概括来讲，SQL的游标是一种临时的数据库对象，即可以用来存放在数据库表中的数据行副本，也可以指向存储在数据库中的数据行的指针。游标提供了在逐行的基础上操作表中数据的方法。<br>\n游标的一个常见用途就是保存查询结果，以便以后使用。游标的结果集是由SELECT语句产生，如果处理过程需要重复使用一个记录集，那么创建一次游标而重复使用若干次，比重复查询数据库要快的多。<br>\n数据量大的时候，尽量避免使用游标，游标使用时会对行加锁，可能会影响其他业务的正常进行。而且，数据量大时其效率也较低效。另外，内存也是其中一个限制。因为游标其实是相当于把磁盘数据整体放入了内存中，如果游标数据量大则会造成内存不足。</p>\n<ol>\n<li>对于复合索引,在查询使用时,最好将条件顺序按找索引的顺序,这样效率最高;<br>\nselect * from table1 where col1=A AND col2=B AND col3=D<br>\n如果使用 where col2=B AND col1=A 或者 where col2=B 将不会使用索引</li>\n<li>何时是用复合索引<br>\n根据where条件建索引是极其重要的一个原则;<br>\n注意不要过多用索引,否则对表更新的效率有很大的影响,因为在操作表的时候要化大量时间花在创建索引中</li>\n<li>复合索引会替代单一索引么<br>\n如果索引满足窄索引的情况下可以建立复合索引,这样可以节约空间和时间</li>\n</ol>\n<p>解析器按照从右到左的顺序处理FROM子句中的表名，FROM子句中写在最后的表(基础表 driving table)将被最先处理，在FROM子句中包含多个表的情况下,你必须选择记录条数最少的表作为基础表。如果有3个以上的表连接查询, 那就需要选择交叉表(intersection table)作为基础表, 交叉表是指那个被其他表所引用的表。</p>\n<p>WHERE子句中的连接顺序：<br>\n采用自下而上的顺序解析WHERE子句,根据这个原理,表之间的连接必须写在其他WHERE条件之前,那些可以过滤掉最大数量记录的条件必须写在WHERE子句的末尾</p>\n<p>mybatis缓存机制<br>\n一级缓存是SqlSession级别的缓存，缓存的数据只在SqlSession内有效<br>\n二级缓存是mapper级别的缓存，同一个namespace公用这一个缓存，所以对SqlSession是共享的；使用 LRU 机制清理缓存，通过 cacheEnabled 参数开启。</p>\n<h2 id=\"参考\">参考<a title=\"#参考\" href=\"#参考\"></a></h2>\n<p><a href=\"https://draveness.me/mysql-innodb/\" target=\"_blank\">浅入浅出MySQ和InnoDB</a></p>\n","prev":{"title":"大数据日知录笔记","link":"2019/11/16/大数据日知录笔记"},"next":{"title":"class文件基本结构","link":"2019/09/11/class文件基本结构"},"plink":"https://zinki.github.io/2019/10/05/数据库相关知识/","toc":[{"id":"参考","title":"参考","index":"1"}]}