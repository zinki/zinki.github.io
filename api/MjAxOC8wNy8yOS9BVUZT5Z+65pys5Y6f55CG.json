{"title":"AUFS基本原理","date":"2018-07-29T11:30:00.000Z","date_formatted":{"ll":"2018年7月29日","L":"2018/07/29","MM-DD":"07-29"},"link":"2018/07/29/AUFS基本原理","tags":["AUFS","Docker"],"categories":["学习","转载"],"updated":"2024-10-11T04:16:58.196Z","content":"<p>AUFS是一种<code>Union File System</code>，所谓UnionFS就是把不同物理位置的目录合并mount到同一个目录中。UnionFS的一个最主要的应用是，把一张<code>CD/DVD</code>和一个硬盘目录给联合 mount在一起，然后，你就可以对这个只读的<code>CD/DVD上</code>的文件进行修改（当然，修改的文件存于硬盘上的目录里）。<span id=\"more\"></span></p>\n<p><img src=\"!%5B%5D(http://zeven.site:7521/2024/10/202410110935580.png)\" alt=\"image.png\" loading=\"lazy\" class=\"φbp\"></p>\n<h3 id=\"aufs-简介\">AUFS 简介<a title=\"#aufs-简介\" href=\"#aufs-简介\"></a></h3>\n<p>AUFS又叫<code>Another UnionFS</code>，后来叫<code>Alternative UnionFS</code>，后来可能觉得不够霸气，叫成<code>Advance UnionFS</code>。是个叫<code>Junjiro Okajima（岡島順治郎）</code>在2006年开发的，AUFS完全重写了早期的<code>UnionFS 1.x</code>，其主要目的是为了可靠性和性能，并且引入了一些新的功能，比如可写分支的负载均衡。AUFS在使用上全兼容UnionFS，而且比之前的UnionFS在稳定性和性能上都要好很多，后来的UnionFS 2.x开始抄AUFS中的功能。但是他居然没有进到Linux主干里，就是因为Linus不让，基本上是因为代码量比较多，而且写得烂（相对于只有3000行的union mount和10000行的UnionFS，以及其它平均下来只有6000行代码左右的VFS，AUFS居然有30000行代码），所以，岡島不断地改进代码质量，不断地提交，不断地被Linus拒掉，所以，到今天AUFS都还进不了Linux主干（今天你可以看到AUFS的代码其实还好了，比起OpenSSL好N倍，要么就是Linus对代码的质量要求非常高，要么就是Linus就是不喜欢AUFS）。<br>\n不过，好在有很多发行版都用了AUFS，比如：<code>Ubuntu 10.04</code>，<code>Debian6.0</code>, <code>Gentoo Live CD</code>支持AUFS，所以，也OK了。</p>\n<h3 id=\"示例\">示例<a title=\"#示例\" href=\"#示例\"></a></h3>\n<p>好了，扯完这些闲话，我们还是看一个示例吧（环境：<code>Ubuntu 14.04</code>）</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ tree</span><br><span class=\"line\">.</span><br><span class=\"line\">├── fruits</span><br><span class=\"line\">│   ├── apple</span><br><span class=\"line\">│   └── tomato</span><br><span class=\"line\">└── vegetables</span><br><span class=\"line\">    ├── carrots</span><br><span class=\"line\">    └── tomato</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 创建一个mount目录</span></span><br><span class=\"line\">$ mkdir mnt</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 把水果目录和蔬菜目录union mount到 ./mnt目录中</span></span><br><span class=\"line\">$ sudo mount -t aufs -o <span class=\"built_in\">dirs</span>=./fruits:./vegetables none ./mnt</span><br><span class=\"line\"><span class=\"comment\">#  查看./mnt目录</span></span><br><span class=\"line\">$ tree ./mnt</span><br><span class=\"line\">./mnt</span><br><span class=\"line\">├── apple</span><br><span class=\"line\">├── carrots</span><br><span class=\"line\">└── tomato</span><br></pre></td></tr></table></figure>\n<p>我们可以看到在<code>./mnt</code>目录下有三个文件，苹果apple、胡萝卜carrots和蕃茄tomato。水果和蔬菜的目录被union到了<code>./mnt</code>目录下了。</p>\n<p>我们来修改一下其中的文件内容：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ <span class=\"built_in\">echo</span> mnt &gt; ./mnt/apple</span><br><span class=\"line\">$ cat ./mnt/apple</span><br><span class=\"line\">mnt</span><br><span class=\"line\">$ cat ./fruits/apple</span><br><span class=\"line\">mnt</span><br></pre></td></tr></table></figure>\n<p>上面的示例，我们可以看到<code>./mnt/apple</code>的内容改了，<code>./fruits/apple</code>的内容也改了。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ <span class=\"built_in\">echo</span> mnt_carrots &gt; ./mnt/carrots</span><br><span class=\"line\">$ cat ./vegetables/carrots</span><br><span class=\"line\"></span><br><span class=\"line\">$ cat ./fruits/carrots</span><br><span class=\"line\">mnt_carrots</span><br></pre></td></tr></table></figure>\n<p>上面的示例，我们可以看到，我们修改了<code>./mnt/carrots</code>的文件内容，<code>./vegetables/carrots</code>并没有变化，反而是<code>./fruits/</code>carrots的目录中出现了carrots文件，其内容是我们在<code>./mnt/carrots</code>里的内容。</p>\n<p>也就是说，我们在mount aufs命令中，我们没有指它vegetables和fruits的目录权限，默认上来说，命令行上第一个（最左边）的目录是可读可写的，后面的全都是只读的。（一般来说，最前面的目录应该是可写的，而后面的都应该是只读的）</p>\n<p>所以，如果我们像下面这样指定权限来mount aufs，你就会发现有不一样的效果（记得先把上面<code>./fruits/carrots</code>的文件删除了）：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ sudo mount -t aufs -o <span class=\"built_in\">dirs</span>=./fruits=rw:./vegetables=rw none ./mnt</span><br><span class=\"line\"></span><br><span class=\"line\">$ <span class=\"built_in\">echo</span> <span class=\"string\">&quot;mnt_carrots&quot;</span> &gt; ./mnt/carrots</span><br><span class=\"line\"></span><br><span class=\"line\">$ cat ./vegetables/carrots</span><br><span class=\"line\">mnt_carrots</span><br><span class=\"line\"></span><br><span class=\"line\">$ cat ./fruits/carrots</span><br><span class=\"line\">cat: ./fruits/carrots: No such file or directory</span><br></pre></td></tr></table></figure>\n<p>现在，在这情况下，如果我们要修改<code>./mnt/tomato</code>这个文件，那么究竟是哪个文件会被改写？</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ <span class=\"built_in\">echo</span> <span class=\"string\">&quot;mnt_tomato&quot;</span> &gt; ./mnt/tomato</span><br><span class=\"line\"></span><br><span class=\"line\">$ cat ./fruits/tomato</span><br><span class=\"line\">mnt_tomato</span><br><span class=\"line\"></span><br><span class=\"line\">$ cat ./vegetables/tomato</span><br><span class=\"line\">I am a vegetable</span><br></pre></td></tr></table></figure>\n<p>可见，如果有重复的文件名，在mount命令行上，越往前的就优先级越高。</p>\n<h3 id=\"用处\">用处<a title=\"#用处\" href=\"#用处\"></a></h3>\n<p>那么，这种UnionFS有什么用？</p>\n<p>历史上，有一个叫Knoppix的Linux发行版，其主要用于Linux演示、光盘教学、系统急救，以及商业产品的演示，不需要硬盘安装，直接把<code>CD/DVD</code>上的image运行在一个可写的存储设备上（比如一个U盘上），其实，也就是把<code>CD/DVD</code>这个文件系统和USB这个可写的系统给联合mount起来，这样你对<code>CD/DVD</code>上的image做的任何改动都会在被应用在U盘上，于是乎，你可以对<code>CD/DVD</code>上的内容进行任意的修改，因为改动都在U盘上，所以你改不坏原来的东西。</p>\n<p>我们可以再发挥一下想像力，你也可以把一个目录，比如你的源代码，作为一个只读的template，和另一个你的working directory给union在一起，然后你就可以做各种修改而不用害怕会把源代码改坏了。有点像一个ad hoc snapshot。</p>\n<p>Docker把UnionFS的想像力发挥到了容器的镜像。你是否还记得我在介绍Linux Namespace上篇中用mount namespace和chroot山寨了一镜像。现在当你看过了这个UnionFS的技术后，你是不是就明白了，你完全可以用UnionFS这样的技术做出分层的镜像来。</p>\n<p>下图来自Docker的官方文档Layer，其很好的展示了Docker用UnionFS搭建的分层镜像。</p>\n<p><img src=\"http://zeven.site:7521/2024/10/202410110936326.png\" alt=\"\" loading=\"lazy\" class=\"φbp\"></p>\n<h3 id=\"参考\">参考<a title=\"#参考\" href=\"#参考\"></a></h3>\n<p><a href=\"https://coolshell.cn/articles/17061.html\" target=\"_blank\">DOCKER基础技术：AUFS</a></p>\n","prev":{"title":"AUFS DOCKER基础技术","link":"2018/08/10/AUFS DOCKER基础技术"},"next":{"title":"Transactional注解不起作用如何排查","link":"2018/07/17/Transactional注解不起作用如何排查"},"plink":"https://zinki.github.io/2018/07/29/AUFS基本原理/","toc":[{"id":"aufs-简介","title":"AUFS 简介","index":"1"},{"id":"示例","title":"示例","index":"2"},{"id":"用处","title":"用处","index":"3"},{"id":"参考","title":"参考","index":"4"}]}