{"per_page":10,"total":8,"current":1,"data":[{"title":"JVM简述","date":"2024-10-10T03:24:21.517Z","date_formatted":{"ll":"2024年10月10日","L":"2024/10/10","MM-DD":"10-10"},"excerpt":"<p>一、什么是JVM</p>\n<p>JVM是Java Virtual Machine（Java 虚拟机）的缩写，JVM是一种用于计算设备的规范，它是一个虚构出来的计算机，是通过在实际的计算机上仿真模拟各种计算机功能来实现的。</p>\n<p>Java语言的一个非常重要的特点就是平台无关性。而使用Java虚拟机是实现这一特点的关键。一般的高级语言如果要在不同的平台上运行，至少需要编译成不同的目标代码。而引入Java语言虚拟机后，Java语言在不同平台上运行时不需要重新编译。Java语言使用Java虚拟机屏蔽了与具体平台相关的信息，使得Java语言编译程序只需生成在Java虚拟机上运行的目标代码（字节码），就可以在多种平台上不加修改地运行。Java虚拟机在执行字节码时，把字节码解释成具体平台上的机器指令执行。这就是Java的能够“一次编译，到处运行”的原因。</p>\n<p>二、JVM总体概述</p>\n<p>JVM总体上是由类装载子系统（ClassLoader）、运行时数据区、执行引擎、垃圾收集这四个部分组成。其中我们最为关注的运行时数据区，也就是JVM的内存部分则是由方法区（Method Area）、JAVA堆（Java Heap）、虚拟机栈（JVM Stack）、程序计数器、本地方法栈（Native Method Stack）这几部分组成。</p>\n<p>三、JVM体系结构<br>\n<img src=\"http://zeven.cpolar.cn/2023/05/20230504110143.png\" alt loading=\"lazy\"></p>\n<p>3.1 类装载子系统</p>\n<p>Class Loader类加载器负责加载.class文件，class文件在文件开头有特定的文件标示，并且ClassLoader负责class文件的加载等，至于它是否可以运行，则由Execution Engine决定。</p>\n<p>3.2 运行时数据区</p>\n<p>栈管运行，堆管存储。JVM调优主要是优化Java堆和方法区。</p>","link":"2024/10/10/JVM简述"},{"title":"一致性Hash原理与实现","date":"2023-10-25T10:30:00.000Z","date_formatted":{"ll":"2023年10月25日","L":"2023/10/25","MM-DD":"10-25"},"excerpt":"<h3 id=\"前言\">前言<a title=\"#前言\" href=\"#前言\"></a></h3>\n<p>互联网公司中，绝大部分都没有马爸爸系列的公司那样财大气粗，他们即没有强劲的服务器、也没有钱去购买昂贵的海量数据库。那他们是怎么应对大数据量高并发的业务场景的呢？<br>\n 这个和当前的开源技术、海量数据架构都有着不可分割的关系。比如通过mysql、nginx等开源软件，通过架构和低成本的服务器搭建千万级别的用户访问系统。<br>\n 怎么样搭建一个好的系统架构，这个话题我们能聊上个七天七夜。这里我主要结合Redis集群来讲一下一致性Hash的相关问题。</p>\n<h3 id=\"redis集群的使用\">Redis集群的使用<a title=\"#redis集群的使用\" href=\"#redis集群的使用\"></a></h3>\n<p>我们在使用Redis的过程中，为了保证Redis的高可用，我们一般会对Redis做主从复制，组成Master-Master或者Master-Slave的形式，进行数据的读写分离，如下图1-1所示：<br>\n<img src=\"http://zeven.cpolar.cn/2023/05/20230506122227.png\" alt=\"Master-Slave模式\" loading=\"lazy\"><br>\n当缓存数据量超过一定的数量时，我们就要对Redis集群做分库分表的操作。</p>\n<p>来个栗子，我们有一个电商平台，需要使用Redis存储商品的图片资源，存储的格式为键值对，key值为图片名称，Value为该图片所在的文件服务器的路径，我们需要根据文件名，查找到文件所在的文件服务器上的路径，我们的图片数量大概在3000w左右，按照我们的规则进行分库，规则就是随机分配的，我们以每台服务器存500w的数量，部署12台缓存服务器，并且进行主从复制，架构图如下图1-2所示：</p>\n<p><img src=\"http://zeven.cpolar.cn/2023/05/20230506122301.png\" alt=\"Redis分库分表\" loading=\"lazy\" class=\"φbp\"></p>\n<p>由于我们定义的规则是随机的，所以我们的数据有可能存储在任何一组Redis中，比如我们需要查询&quot;product.png&quot;的图片，由于规则的随机性，我们需要遍历所有Redis服务器，才能查询得到。这样的结果显然不是我们所需要的。所以我们会想到按某一个字段值进行Hash值、取模。所以我们就看看使用Hash的方式是怎么进行的。</p>\n<h3 id=\"使用hash的redis集群\">使用Hash的Redis集群<a title=\"#使用hash的redis集群\" href=\"#使用hash的redis集群\"></a></h3>\n<p>如果我们使用Hash的方式，每一张图片在进行分库的时候都可以定位到特定的服务器，示意图如图1-3所示：<br>\n<img src=\"http://zeven.cpolar.cn/2023/05/20230506122340.png\" alt=\"使用Hash方式的命中缓存\" loading=\"lazy\"><br>\n从上图中，我们需要查询的是图product.png，由于我们有6台主服务器，所以计算的公式为：hash(product.png) % 6 = 5, 我们就可以定位到是5号主从，这们就省去了遍历所有服务器的时间，从而大大提升了性能。</p>\n<h3 id=\"使用hash时遇到的问题\">使用Hash时遇到的问题<a title=\"#使用hash时遇到的问题\" href=\"#使用hash时遇到的问题\"></a></h3>","link":"2023/10/25/一致性Hash原理与实现","tags":["一致性Hash"],"categories":["学习","转载"]},{"title":"一次数据库连接池优化的实践剖析","date":"2023-08-20T03:35:00.000Z","date_formatted":{"ll":"2023年8月20日","L":"2023/08/20","MM-DD":"08-20"},"excerpt":"<h2 id=\"问题背景：mysql-线程数只升不降\">问题背景：MySQL 线程数只升不降<a title=\"#问题背景：mysql-线程数只升不降\" href=\"#问题背景：mysql-线程数只升不降\"></a></h2>\n<p>一段时间以来，XXX 部门开放平台 OPENXXX 系统在业务高峰频繁出现 MySQL 线程数升高的现象。升高本身不是问题，问题是随着业务高峰过去，QPS 下来后 ，MySQL 线程数却依然居高不下，这是什么原因？</p>\n<p>思考方向上，大家都知道，MySQL 是通过线程池来进行线程管理的，基于过往经验，上述情况很可能是线程池的配置策略不合理导致线程创建后无法及时释放，而实际上线程的利用率是很低的————这一点通过分析系统线程也可以看到，waiting 态线程占据 MySQL 总线程数的一半有余（见下图）。</p>\n<p>落地实践上，方向虽然是明确的，但具体是 MySQL 的哪一项策略配置不合理、又该做怎样的调整，需要做细致的调研分析才能回答。由此发起 MySQL 线程的优化治理专项。</p>\n<h2 id=\"追根溯源：问题根源的分析定位\"><img src=\"http://zeven.cpolar.cn/2024/07/202407062210578.png\" alt><br>\n追根溯源：问题根源的分析定位<a title=\"#追根溯源：问题根源的分析定位\" href=\"#追根溯源：问题根源的分析定位\"></a></h2>\n<p>对比业务高峰前后的 MySQL 线程，发现飙升的主要是 [MySQL Statement Cancellation Timer] ，由此引出第一阶段问题，[MySQL Statement Cancellation Timer] 线程是从哪里来的？</p>\n<h3 id=\"一、timer-线程生命周期\">一、Timer 线程生命周期<a title=\"#一、timer-线程生命周期\" href=\"#一、timer-线程生命周期\"></a></h3>\n<p>走读代码流程，梳理得到 Timer 线程的生命周期，如下图所示（Timer 节点以及问题节点已标识）——<br>\n<img src=\"http://zeven.cpolar.cn/2024/07/202407062213258.png\" alt loading=\"lazy\"></p>\n<h3 id=\"二、生命周期详细解读\">二、生命周期详细解读<a title=\"#二、生命周期详细解读\" href=\"#二、生命周期详细解读\"></a></h3>\n<h4 id=\"timer-线程创建链路\">Timer 线程创建链路<a title=\"#timer-线程创建链路\" href=\"#timer-线程创建链路\"></a></h4>","link":"2023/08/20/一次数据库连接池优化的实践剖析","tags":["数据库","线程池"],"categories":["工作","转载"]},{"title":"MySQL沉浸式面试","date":"2023-07-26T02:10:00.000Z","date_formatted":{"ll":"2023年7月26日","L":"2023/07/26","MM-DD":"07-26"},"excerpt":"<p>今天我们来聊聊MySQL原理<br>\n<img src=\"http://zeven.cpolar.cn/2023/05/20230506114707.png\" alt loading=\"lazy\"></p>\n<p>基础篇主要是侧重基础知识，原理篇是有一定基础后的递进，通过学习本篇，不仅可以进一步了解MySQL的各项特性，还能为接下来的容灾调优打下坚实的基础</p>\n<p>ACID与隔离级别<br>\n那你先来说说MySQL的四种隔离级别吧。<br>\nSQL标准定义了4类隔离级别，包括一些具体规则，用来限定事务之间的隔离性。<br>\n这四种级别分别是读未提交、读已提交、可重复读、串型化。<br>\n读未提交，顾名思义，就是可以读到还没有提交的数据；读已提交会读到其它事务已经提交的数据；可重复读确保了同一事务中，读取同一条数据时，会看到同样的数据行；串型化通过强制事务排序，使其不可能相互冲突。</p>\n<p>重点介绍下Repeatable Read吧。<br>\nRepeatable Read就是可重复读。它确保了在同一事务中，读取同一条数据时，会看到同样的数据行。<br>\n它也是MyQL的默认事务隔离级别，这种级别事务之间影响很小，通常已经能够满足日常需要了。<br>\n<img src=\"http://zeven.cpolar.cn/2023/05/20230506114828.png\" alt loading=\"lazy\"><br>\n说出四种隔离级别只是最低要求，能每一项具体去阐述特性就算过关。如果还能指出存在的问题、依赖的技术，那么就是妥妥的加分了！</p>\n<p>下面我们来聊聊InnoDB中ACID的实现吧，先说一下原子性是怎么实现的。<br>\n事务要么失败，要么成功，不能做一半。聪明的InnoDB，在干活儿之前，先将要做的事情记录到一个叫undo log的日志文件中，如果失败了或者主动rollback，就可以通过undo log的内容，将事务回滚。</p>\n<p>那undo log里面具体记录了什么信息呢？<br>\nundo log属于逻辑日志，它记录的是sql执行相关的信息。当发生回滚时，InnoDB会根据undo log的内容做与之前相反的工作，使数据回到之前的状态。。。</p>\n<p><img src=\"http://zeven.cpolar.cn/2023/05/20230506114917.png\" alt loading=\"lazy\"><br>\n那持久性又是怎么实现的？<br>\n持久性是用来保证一旦给客户返回成功，数据就不会消失，持久存在。最简单的做法，是每次写完磁盘落地之后，再给客户返回成功。但如果每次读写数据都需要磁盘IO，效率就会很低。<br>\n为此，追求极致的InnoDB提供了缓冲。当向数据库写入数据时，会首先写入缓冲池，缓冲池中修改的数据会定期刷新到磁盘中，这一过程称为刷脏。</p>\n<p>如果MySQL宕机，那此时Buffer Pool中修改的数据不是丢失了吗？<br>\nInnodb引入了redo log来解决这个问题。当数据修改时，会先在redo log记录这次操作，然后再修改缓冲池中的数据，当事务提交时，会调用fsync接口对redo log进行刷盘。<br>\n如果MySQL宕机，重启时可以读取redo log中的数据，对数据库进行恢复。由于redo log是WAL日志，也就是预写式日志，所有修改先写入日志，所以保证了数据不会因MySQL宕机而丢失，从而满足了持久性要求。</p>\n<p><img src=\"http://zeven.cpolar.cn/2023/05/20230506114955.png\" alt loading=\"lazy\"><br>\n按你所说，redo log 也需要写磁盘，为什么不直接将数据写磁盘呢？</p>\n<p>嗯。。。主要是有以下两方面的原因：</p>","link":"2023/07/26/MySQL沉浸式面试","tags":["MYSQL"],"categories":["转载"]},{"title":"Luhn算法使用","date":"2022-02-21T11:30:00.000Z","date_formatted":{"ll":"2022年2月21日","L":"2022/02/21","MM-DD":"02-21"},"excerpt":"<p>银行卡号码的校验采用Luhn算法，校验过程大致如下：</p>\n<ol>\n<li>\n<p>从右到左给卡号字符串编号，最右边第一位是1，最右边第二位是2，最右边第三位是3….</p>\n</li>\n<li>\n<p>从右向左遍历，对每一位字符t执行第三个步骤，并将每一位的计算结果相加得到一个数s。</p>\n</li>\n<li>\n<p>对每一位的计算规则：如果这一位是奇数位，则返回t本身，如果是偶数位，则先将t乘以2得到一个数n，如果n是一位数（小于10），直接返回n，否则将n的个位数和十位数相加返回。</p>\n</li>\n<li>\n<p>如果s能够整除10，则此号码有效，否则号码无效。</p>\n</li>\n</ol>\n<p>因为最终的结果会对10取余来判断是否能够整除10，所以又叫做模10算法。","link":"2022/02/21/Luhn算法使用","tags":["算法"],"categories":["工作"]},{"title":"循环链表实践","date":"2022-01-20T03:35:00.000Z","date_formatted":{"ll":"2022年1月20日","L":"2022/01/20","MM-DD":"01-20"},"excerpt":"<p>工作中涉及到针对证件号做软加密需求，要求是密文必须唯一，开始是通过数据库去重来实现，每次都要去数据库查询是否存在，存在的话重新生成，直到生成可用密文，这样有性能瓶颈。</p>\n<p>需要更换密文生成方式，后采用根据字符映射的方式，鉴于过于简单，所以添加偏移量增加复杂度。经过评估，双向循环链表很适合这种场景。","link":"2022/01/20/循环链表实践","tags":["加密","链表"],"categories":["工作"]},{"title":"Markdown图片解析","date":"2022-01-11T11:00:00.000Z","date_formatted":{"ll":"2022年1月11日","L":"2022/01/11","MM-DD":"01-11"},"excerpt":"<p>最近想对图床做个备份，刚好再看Python，遂参考网上代码写了解析Markdown文件并下载图片的Python脚本。","link":"2022/01/11/Markdown图片解析","tags":["Markdown","Python"],"categories":["学习"]},{"title":"X509证书解析","date":"2021-12-21T03:00:00.000Z","date_formatted":{"ll":"2021年12月21日","L":"2021/12/21","MM-DD":"12-21"},"excerpt":"<p>X.509是密码学里公钥证书的格式标准。X.509证书已应用在包括TLS/SSL在内的众多网络协议里，同时它也用在很多非在线应用场景里，比如电子签名服务。X.509证书里含有公钥、身份信息（比如网络主机名，组织的名称或个体名称等）和签名信息（可以是证书签发机构CA的签名，也可以是自签名）","link":"2021/12/21/X509证书解析","tags":["证书"],"categories":["工作"]},{"title":"负载相关知识","date":"2021-11-19T09:20:00.000Z","date_formatted":{"ll":"2021年11月19日","L":"2021/11/19","MM-DD":"11-19"},"excerpt":"<p>负载这一块的知识有些乱, 听人家常说软负载、硬负载，四层负载，七层负载、客户端负载,服务端负载之类的,所以梳理一下。</p>\n<p>负载均衡在系统架构中是一个非常重要,通过负载均衡可以提高系统的高可用，缓解网络、硬件资源的限制。","link":"2021/11/19/负载相关知识","tags":["负载"],"categories":["学习"]},{"title":"Markdown常用语法","date":"2021-10-25T11:40:00.000Z","date_formatted":{"ll":"2021年10月25日","L":"2021/10/25","MM-DD":"10-25"},"excerpt":"<p>Markdown 是一种纯文本格式的标记语言，通过简单的标记语法，它可以使普通文本内容具有一定的格式。","link":"2021/10/25/Markdown常用语法","tags":["Markdown"],"categories":["学习"]}]}