{"title":"并发常见问题","date":"2017-10-21T14:11:00.000Z","date_formatted":{"ll":"2017年10月21日","L":"2017/10/21","MM-DD":"10-21"},"link":"2017/10/21/并发常见问题","tags":["多线程","并发"],"categories":["学习"],"updated":"2024-10-11T04:22:19.801Z","content":"<h2 id=\"start()方法和run()方法的区别\">start()方法和run()方法的区别<a title=\"#start()方法和run()方法的区别\" href=\"#start()方法和run()方法的区别\"></a></h2>\n<p>只有调用了start()方法，才会表现出多线程的特性，不同线程的run()方法里面的代码交替执行。如果只是调用run()方法，那么代码还是同步执行的，必须等待一个线程的run()方法里面的代码全部执行完毕之后，另外一个线程才可以执行其run()方法里面的代码</p>\n<span id=\"more\"></span>\n<h2 id=\"yield-join区别\">Yield join区别<a title=\"#yield-join区别\" href=\"#yield-join区别\"></a></h2>\n<p>一个调用yield()方法使当前线程从执行状态(运行状态)变为可执行态(就绪状态)。cpu会从众多的可执行态里选择<br>\n线程实例的方法join()方法可以使得一个线程在另一个线程结束后再执行</p>\n<h2 id=\"runnable接口和callable接口的区别\">Runnable接口和Callable接口的区别<a title=\"#runnable接口和callable接口的区别\" href=\"#runnable接口和callable接口的区别\"></a></h2>\n<p>Runnable接口中的run()方法的返回值是void，它做的事情只是纯粹地去执行run()方法中的代码而已；Callable接口中的call()方法是有返回值的，是一个泛型，和Future、FutureTask配合可以用来获取异步执行的结果。</p>\n<blockquote>\n<p>这其实是很有用的一个特性，因为多线程相比单线程更难、更复杂的一个重要原因就是因为多线程充满着未知性，某条线程是否执行了？某条线程执行了多久？某条线程执行的时候我们期望的数据是否已经赋值完毕？无法得知，我们能做的只是等待这条多线程的任务执行完毕而已。而Callable+Future/FutureTask却可以获取多线程运行的结果，可以在等待时间太长没获取到需要的数据的情况下取消该线程的任务，真的是非常有用。</p>\n</blockquote>\n<h2 id=\"cyclicbarrier和countdownlatch的区别\">CyclicBarrier和CountDownLatch的区别<a title=\"#cyclicbarrier和countdownlatch的区别\" href=\"#cyclicbarrier和countdownlatch的区别\"></a></h2>\n<p>两个看上去有点像的类，都在java.util.concurrent下，都可以用来表示代码运行到某个点上，二者的区别在于：</p>\n<ol>\n<li>CyclicBarrier的某个线程运行到某个点上之后，该线程即停止运行，直到所有的线程都到达了这个点，所有线程才重新运行；CountDownLatch则不是，某线程运行到某个点上之后，只是给某个数值-1而已，该线程继续运行</li>\n<li>CyclicBarrier只能唤起一个任务，CountDownLatch可以唤起多个任务</li>\n<li>CyclicBarrier可重用，CountDownLatch不可重用，计数值为0该CountDownLatch就不可再用了</li>\n</ol>\n<h2 id=\"volatile关键字的作用\">volatile关键字的作用<a title=\"#volatile关键字的作用\" href=\"#volatile关键字的作用\"></a></h2>\n<p>理解volatile关键字的作用的前提是要理解Java内存模型</p>\n<ol>\n<li>多线程主要围绕可见性和原子性两个特性而展开，使用volatile关键字修饰的变量，保证了其在多线程之间的可见性，即每次读取到volatile变量，一定是最新的数据</li>\n<li>代码底层执行不像我们看到的高级语言—-Java程序这么简单，它的执行是Java代码–&gt;字节码–&gt;根据字节码执行对应的C/C++代码–&gt;C/C++代码被编译成汇编语言–&gt;和硬件电路交互，现实中，为了获取更好的性能JVM可能会对指令进行重排序，多线程下可能会出现一些意想不到的问题。使用volatile则会对禁止语义重排序，当然这也一定程度上降低了代码执行效率</li>\n</ol>\n<blockquote>\n<p>从实践角度而言，volatile的一个重要作用就是和CAS结合，保证了原子性，详细的可以参见java.util.concurrent.atomic包下的类，比如AtomicInteger。</p>\n</blockquote>\n<h2 id=\"什么是线程安全\">什么是线程安全<a title=\"#什么是线程安全\" href=\"#什么是线程安全\"></a></h2>\n<p>如果你的代码在多线程下执行和在单线程下执行永远都能获得一样的结果，那么你的代码就是线程安全的<br>\n线程安全的几个级别<br>\n（1）不可变<br>\n像String、Integer、Long这些，都是final类型的类，任何一个线程都改变不了它们的值，要改变除非新创建一个，因此这些不可变对象不需要任何同步手段就可以直接在多线程环境下使用<br>\n（2）绝对线程安全<br>\n不管运行时环境如何，调用者都不需要额外的同步措施。要做到这一点通常需要付出许多额外的代价，Java中标注自己是线程安全的类，实际上绝大多数都不是线程安全的，不过绝对线程安全的类，Java中也有，比方说CopyOnWriteArrayList、CopyOnWriteArraySet<br>\n（3）相对线程安全<br>\n相对线程安全也就是我们通常意义上所说的线程安全，像Vector这种，add、remove方法都是原子操作，不会被打断，但也仅限于此，如果有个线程在遍历某个Vector、有个线程同时在add这个Vector，99%的情况下都会出现ConcurrentModificationException，也就是fail-fast机制。<br>\n（4）线程非安全<br>\n这个就没什么好说的了，ArrayList、LinkedList、HashMap等都是线程非安全的类</p>\n<blockquote>\n<p>fail-fast 机制是java集合(Collection)中的一种错误机制。当多个线程对同一个集合的内容进行操作时，就可能会产生fail-fast事件。例如：当某一个线程A通过iterator去遍历某集合的过程中，若该集合的内容被其他线程所改变了；那么线程A访问集合时，就会抛出ConcurrentModificationException异常，产生fail-fast事件。</p>\n</blockquote>\n<h2 id=\"java中如何获取到线程dump文件\">Java中如何获取到线程dump文件<a title=\"#java中如何获取到线程dump文件\" href=\"#java中如何获取到线程dump文件\"></a></h2>\n<p>死循环、死锁、阻塞、页面打开慢等问题，打线程dump是最好的解决问题的途径。所谓线程dump也就是线程堆栈，获取到线程堆栈有两步:</p>\n<ol>\n<li>获取到线程的pid，可以通过使用jps命令，在Linux环境下还可以使用ps -ef | grep java</li>\n<li>打印线程堆栈，可以通过使用jstack pid命令，在Linux环境下还可以使用kill -3 pid<br>\n另外提一点，Thread类提供了一个getStackTrace()方法也可以用于获取线程堆栈。这是一个实例方法，因此此方法是和具体线程实例绑定的，每次获取获取到的是具体某个线程当前运行的堆栈</li>\n</ol>\n<h2 id=\"sleep方法和wait方法有什么区别\">sleep方法和wait方法有什么区别<a title=\"#sleep方法和wait方法有什么区别\" href=\"#sleep方法和wait方法有什么区别\"></a></h2>\n<p>这个问题常问，sleep方法和wait方法都可以用来放弃CPU一定的时间，不同点在于如果线程持有某个对象的监视器，sleep方法不会放弃这个对象的监视器，wait方法会放弃这个对象的监视器</p>\n<h2 id=\"threadlocal有什么用\">ThreadLocal有什么用<a title=\"#threadlocal有什么用\" href=\"#threadlocal有什么用\"></a></h2>\n<p>简单说ThreadLocal就是一种以空间换时间的做法，在每个Thread里面维护了一个以开地址法实现的ThreadLocal.ThreadLocalMap，把数据进行隔离，数据不共享，自然就没有线程安全方面的问题了</p>\n<p>##为什么wait()方法和notify()/notifyAll()方法要在同步块中被调用<br>\n这是JDK强制的，wait()方法和notify()/notifyAll()方法在调用前都必须先获得对象的锁</p>\n<h2 id=\"wait()方法和notify()/notifyall()方法在放弃对象监视器时有什么区别\">wait()方法和notify()/notifyAll()方法在放弃对象监视器时有什么区别<a title=\"#wait()方法和notify()/notifyall()方法在放弃对象监视器时有什么区别\" href=\"#wait()方法和notify()/notifyall()方法在放弃对象监视器时有什么区别\"></a></h2>\n<p>wait()方法和notify()/notifyAll()方法在放弃对象监视器的时候的区别在于：wait()方法立即释放对象监视器，notify()/notifyAll()方法则会等待线程剩余代码执行完毕才会放弃对象监视器。</p>\n<h2 id=\"为什么要使用线程池\">为什么要使用线程池<a title=\"#为什么要使用线程池\" href=\"#为什么要使用线程池\"></a></h2>\n<p>避免频繁地创建和销毁线程，达到线程对象的重用。另外，使用线程池还可以根据项目灵活地控制并发的数目。</p>\n<h2 id=\"怎么检测一个线程是否持有对象监视器\">怎么检测一个线程是否持有对象监视器<a title=\"#怎么检测一个线程是否持有对象监视器\" href=\"#怎么检测一个线程是否持有对象监视器\"></a></h2>\n<p>Thread类提供了一个holdsLock(Object obj)方法，当且仅当对象obj的监视器被某条线程持有的时候才会返回true，注意这是一个static方法，这意味着“某条线程”指的是当前线程。</p>\n<h2 id=\"synchronized和reentrantlock的区别\">synchronized和ReentrantLock的区别<a title=\"#synchronized和reentrantlock的区别\" href=\"#synchronized和reentrantlock的区别\"></a></h2>\n<p>synchronized是和if、else、for、while一样的关键字，ReentrantLock是类，这是二者的本质区别。既然ReentrantLock是类，那么它就提供了比synchronized更多更灵活的特性，可以被继承、可以有方法、可以有各种各样的类变量，ReentrantLock比synchronized的扩展性体现在几点上：</p>\n<ol>\n<li>ReentrantLock可以对获取锁的等待时间进行设置，这样就避免了死锁</li>\n<li>ReentrantLock可以获取各种锁的信息</li>\n<li>ReentrantLock可以灵活地实现多路通知<br>\n另外，二者的锁机制其实也是不一样的。ReentrantLock底层调用的是Unsafe的park方法加锁，synchronized操作的应该是对象头中mark word，这点我不能确定。</li>\n</ol>\n<h2 id=\"concurrenthashmap的并发度是什么\">ConcurrentHashMap的并发度是什么<a title=\"#concurrenthashmap的并发度是什么\" href=\"#concurrenthashmap的并发度是什么\"></a></h2>\n<p>ConcurrentHashMap的并发度就是segment的大小，默认为16，这意味着最多同时可以有16条线程操作ConcurrentHashMap，这也是ConcurrentHashMap对Hashtable的最大优势，任何情况下，Hashtable能同时有两条线程获取Hashtable中的数据吗</p>\n<h2 id=\"readwritelock是什么\">ReadWriteLock是什么<a title=\"#readwritelock是什么\" href=\"#readwritelock是什么\"></a></h2>\n<p>首先明确一下，不是说ReentrantLock不好，只是ReentrantLock某些时候有局限。如果使用ReentrantLock，可能本身是为了防止线程A在写数据、线程B在读数据造成的数据不一致，但这样，如果线程C在读数据、线程D也在读数据，读数据是不会改变数据的，没有必要加锁，但是还是加锁了，降低了程序的性能。<br>\n因为这个，才诞生了读写锁ReadWriteLock。ReadWriteLock是一个读写锁接口，ReentrantReadWriteLock是ReadWriteLock接口的一个具体实现，实现了读写的分离，读锁是共享的，写锁是独占的，读和读之间不会互斥，读和写、写和读、写和写之间才会互斥，提升了读写的性能。</p>\n<h2 id=\"linux环境下如何查找哪个线程使用cpu最长\">Linux环境下如何查找哪个线程使用CPU最长<a title=\"#linux环境下如何查找哪个线程使用cpu最长\" href=\"#linux环境下如何查找哪个线程使用cpu最长\"></a></h2>\n<ol>\n<li>获取项目的pid，jps或者ps -ef | grep java</li>\n<li>top -H -p pid，顺序不能改变</li>\n</ol>\n<h2 id=\"怎么唤醒一个阻塞的线程\">怎么唤醒一个阻塞的线程<a title=\"#怎么唤醒一个阻塞的线程\" href=\"#怎么唤醒一个阻塞的线程\"></a></h2>\n<p>如果线程是因为调用了wait()、sleep()或者join()方法而导致的阻塞，可以中断线程，并且通过抛出InterruptedException来唤醒它；如果线程遇到了IO阻塞，无能为力，因为IO是操作系统实现的，Java代码并没有办法直接接触到操作系统</p>\n<h2 id=\"java中用到的线程调度算法是什么\">Java中用到的线程调度算法是什么<a title=\"#java中用到的线程调度算法是什么\" href=\"#java中用到的线程调度算法是什么\"></a></h2>\n<p>抢占式。一个线程用完CPU之后，操作系统会根据线程优先级、线程饥饿情况等数据算出一个总的优先级并分配下一个时间片给某个线程执行</p>\n<h2 id=\"thread.sleep(0)的作用是什么\">Thread.sleep(0)的作用是什么<a title=\"#thread.sleep(0)的作用是什么\" href=\"#thread.sleep(0)的作用是什么\"></a></h2>\n<p>由于Java采用抢占式的线程调度算法，因此可能会出现某条线程常常获取到CPU控制权的情况，为了让某些优先级比较低的线程也能获取到CPU控制权，可以使用Thread.sleep(0)手动触发一次操作系统分配时间片的操作，这也是平衡CPU控制权的一种操作。</p>\n<h2 id=\"什么是自旋\">什么是自旋<a title=\"#什么是自旋\" href=\"#什么是自旋\"></a></h2>\n<p>很多synchronized里面的代码只是一些很简单的代码，执行时间非常快，此时等待的线程都加锁可能是一种不太值得的操作，因为线程阻塞涉及到用户态和内核态切换的问题。既然synchronized里面的代码执行得非常快，不妨让等待锁的线程不要被阻塞，而是在synchronized的边界做忙循环，这就是自旋。如果做了多次忙循环发现还没有获得锁，再阻塞，这样可能是一种更好的策略。</p>\n<h2 id=\"什么是cas\">什么是CAS<a title=\"#什么是cas\" href=\"#什么是cas\"></a></h2>\n<p>CAS，全称为Compare and Swap，即比较-替换。假设有三个操作数：内存值V、旧的预期值A、要修改的值B，当且仅当预期值A和内存值V相同时，才会将内存值修改为B并返回true，否则什么都不做并返回false。当然CAS一定要volatile变量配合，这样才能保证每次拿到的变量是主内存中最新的那个值，否则旧的预期值A对某条线程来说，永远是一个不会变的值A，只要某次CAS操作失败，永远都不可能成功</p>\n<h2 id=\"什么是aqs\">什么是AQS<a title=\"#什么是aqs\" href=\"#什么是aqs\"></a></h2>\n<p>简单说一下AQS，AQS全称为AbstractQueuedSychronizer，翻译过来应该是抽象队列同步器。</p>\n<p>如果说java.util.concurrent的基础是CAS的话，那么AQS就是整个Java并发包的核心了，ReentrantLock、CountDownLatch、Semaphore等等都用到了它。AQS实际上以双向队列的形式连接所有的Entry，比方说ReentrantLock，所有等待的线程都被放在一个Entry中并连成双向队列，前面一个线程使用ReentrantLock好了，则双向队列实际上的第一个Entry开始运行。</p>\n<p>AQS定义了对双向队列所有的操作，而只开放了tryLock和tryRelease方法给开发者使用，开发者可以根据自己的实现重写tryLock和tryRelease方法，以实现自己的并发功能。</p>\n<h2 id=\"单例模式的线程安全性\">单例模式的线程安全性<a title=\"#单例模式的线程安全性\" href=\"#单例模式的线程安全性\"></a></h2>\n<p>老生常谈的问题了，首先要说的是单例模式的线程安全意味着：某个类的实例在多线程环境下只会被创建一次出来。单例模式有很多种的写法，我总结一下：</p>\n<ol>\n<li>饿汉式单例模式的写法：线程安全</li>\n<li>懒汉式单例模式的写法：非线程安全</li>\n<li>双检锁单例模式的写法：线程安全</li>\n</ol>\n<h2 id=\"semaphore有什么作用\">Semaphore有什么作用<a title=\"#semaphore有什么作用\" href=\"#semaphore有什么作用\"></a></h2>\n<p>Semaphore就是一个信号量，它的作用是限制某段代码块的并发数。Semaphore有一个构造函数，可以传入一个int型整数n，表示某段代码最多只有n个线程可以访问，如果超出了n，那么请等待，等到某个线程执行完毕这段代码块，下一个线程再进入。由此可以看出如果Semaphore构造函数中传入的int型整数n=1，相当于变成了一个synchronized了。</p>\n<h2 id=\"同步方法和同步块，哪个是更好的选择\">同步方法和同步块，哪个是更好的选择<a title=\"#同步方法和同步块，哪个是更好的选择\" href=\"#同步方法和同步块，哪个是更好的选择\"></a></h2>\n<p>同步块，这意味着同步块之外的代码是异步执行的，这比同步整个方法更提升代码的效率。请知道一条原则：同步的范围越小越好。</p>\n<p>虽说同步的范围越少越好，但是在Java虚拟机中还是存在着一种叫做锁粗化的优化方法，这种方法就是把同步范围变大。这是有用的，比方说StringBuffer，它是一个线程安全的类，自然最常用的append()方法是一个同步方法，我们写代码的时候会反复append字符串，这意味着要进行反复的加锁-&gt;解锁，这对性能不利，因为这意味着Java虚拟机在这条线程上要反复地在内核态和用户态之间进行切换，因此Java虚拟机会将多次append方法调用的代码进行一个锁粗化的操作，将多次的append的操作扩展到append方法的头尾，变成一个大的同步块，这样就减少了加锁–&gt;解锁的次数，有效地提升了代码执行的效率。</p>\n<h2 id=\"可重入锁指同一个线程可以再次获得之前已经获得的锁。\">可重入锁指同一个线程可以再次获得之前已经获得的锁。<a title=\"#可重入锁指同一个线程可以再次获得之前已经获得的锁。\" href=\"#可重入锁指同一个线程可以再次获得之前已经获得的锁。\"></a></h2>\n<p>可重入锁可以用户避免死锁。<br>\nJava中的可重入锁：synchronized 和 java.util.concurrent.locks.ReentrantLock</p>\n<h2 id=\"锁的实现：\">锁的实现：<a title=\"#锁的实现：\" href=\"#锁的实现：\"></a></h2>\n<p>Synchronized是依赖于JVM实现的，而ReenTrantLock是JDK实现的<br>\n在Synchronized优化以前，synchronized的性能是比ReenTrantLock差很多的，但是自从Synchronized引入了偏向锁，轻量级锁（自旋锁）后，两者的性能就差不多了，在两种方法都可用的情况下，官方甚至建议使用synchronized，其实synchronized的优化我感觉就借鉴了ReenTrantLock中的CAS技术</p>\n<p>所谓死锁： 是指两个或两个以上的进程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象，若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的进程称为死锁进程。</p>\n<p>查看死锁方法:Jconsole</p>\n<p><img src=\"http://zeven.site:7521/2024/10/202410111013517.png\" alt=\"\" loading=\"lazy\" class=\"φbp\"></p>\n<p>Jstack<br>\n先用jps查出现有线程<br>\n然后 jstack -l PID 查看find one dead lock之类的</p>\n<h2 id=\"参考\">参考<a title=\"#参考\" href=\"#参考\"></a></h2>\n<p><a href=\"http://www.importnew.com/12773.html\" target=\"_blank\">Java线程面试题</a></p>\n","prev":{"title":"跨域及解决方案","link":"2017/11/05/跨域及解决方案"},"next":{"title":"自定义Feign日志打印","link":"2017/10/09/自定义Feign日志打印"},"plink":"https://zinki.github.io/2017/10/21/并发常见问题/","toc":[{"id":"start()方法和run()方法的区别","title":"start()方法和run()方法的区别","index":"1"},{"id":"yield-join区别","title":"Yield join区别","index":"2"},{"id":"runnable接口和callable接口的区别","title":"Runnable接口和Callable接口的区别","index":"3"},{"id":"cyclicbarrier和countdownlatch的区别","title":"CyclicBarrier和CountDownLatch的区别","index":"4"},{"id":"volatile关键字的作用","title":"volatile关键字的作用","index":"5"},{"id":"什么是线程安全","title":"什么是线程安全","index":"6"},{"id":"java中如何获取到线程dump文件","title":"Java中如何获取到线程dump文件","index":"7"},{"id":"sleep方法和wait方法有什么区别","title":"sleep方法和wait方法有什么区别","index":"8"},{"id":"threadlocal有什么用","title":"ThreadLocal有什么用","index":"9"},{"id":"wait()方法和notify()/notifyall()方法在放弃对象监视器时有什么区别","title":"wait()方法和notify()&#x2F;notifyAll()方法在放弃对象监视器时有什么区别","index":"10"},{"id":"为什么要使用线程池","title":"为什么要使用线程池","index":"11"},{"id":"怎么检测一个线程是否持有对象监视器","title":"怎么检测一个线程是否持有对象监视器","index":"12"},{"id":"synchronized和reentrantlock的区别","title":"synchronized和ReentrantLock的区别","index":"13"},{"id":"concurrenthashmap的并发度是什么","title":"ConcurrentHashMap的并发度是什么","index":"14"},{"id":"readwritelock是什么","title":"ReadWriteLock是什么","index":"15"},{"id":"linux环境下如何查找哪个线程使用cpu最长","title":"Linux环境下如何查找哪个线程使用CPU最长","index":"16"},{"id":"怎么唤醒一个阻塞的线程","title":"怎么唤醒一个阻塞的线程","index":"17"},{"id":"java中用到的线程调度算法是什么","title":"Java中用到的线程调度算法是什么","index":"18"},{"id":"thread.sleep(0)的作用是什么","title":"Thread.sleep(0)的作用是什么","index":"19"},{"id":"什么是自旋","title":"什么是自旋","index":"20"},{"id":"什么是cas","title":"什么是CAS","index":"21"},{"id":"什么是aqs","title":"什么是AQS","index":"22"},{"id":"单例模式的线程安全性","title":"单例模式的线程安全性","index":"23"},{"id":"semaphore有什么作用","title":"Semaphore有什么作用","index":"24"},{"id":"同步方法和同步块，哪个是更好的选择","title":"同步方法和同步块，哪个是更好的选择","index":"25"},{"id":"可重入锁指同一个线程可以再次获得之前已经获得的锁。","title":"可重入锁指同一个线程可以再次获得之前已经获得的锁。","index":"26"},{"id":"锁的实现：","title":"锁的实现：","index":"27"},{"id":"参考","title":"参考","index":"28"}]}