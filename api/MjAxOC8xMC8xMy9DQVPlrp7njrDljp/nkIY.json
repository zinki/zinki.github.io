{"title":"CAS实现原理","date":"2018-10-13T12:00:00.000Z","date_formatted":{"ll":"2018年10月13日","L":"2018/10/13","MM-DD":"10-13"},"link":"2018/10/13/CAS实现原理","tags":["CAS"],"categories":["学习"],"updated":"2024-10-10T08:03:05.439Z","content":"<p>CAS 指的是现代 CPU 广泛支持的一种对内存中的共享数据进行操作的一种特殊指令，在大多数处理器架构，包括IA32、Space中采用的都是CAS指令<span id=\"more\"></span></p>\n<p>CAS的语义是“我认为V的值应该为A，如果是，那么将V的值更新为B，否则不修改并告诉V的值实际为多少”，CAS是项乐观锁技术，当多个线程尝试使用CAS同时更新同一个变量时，只有其中一个线程能更新变量的值，而其它线程都失败，失败的线程并不会被挂起，而是被告知这次竞争中失败，并可以再次尝试。CAS有3个操作数，内存值V，旧的预期值A，要修改的新值B。当且仅当预期值A和内存值V相同时，将内存值V修改为B，否则什么都不做。</p>\n<p>CAS无锁算法的C实现如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">compare_and_swap</span> <span class=\"params\">(<span class=\"keyword\">int</span>* reg, <span class=\"keyword\">int</span> oldval, <span class=\"keyword\">int</span> newval)</span> </span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">  ATOMIC();</span><br><span class=\"line\">  <span class=\"keyword\">int</span> old_reg_val = *reg;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (old_reg_val == oldval) </span><br><span class=\"line\">     *reg = newval;</span><br><span class=\"line\">  END_ATOMIC();</span><br><span class=\"line\">  <span class=\"keyword\">return</span> old_reg_val;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>虽然使用CAS可以实现非阻塞式的原子性操作，但是会产生ABA问题</p>\n<ol>\n<li>\n<p>现有一个用单向链表实现的堆栈，栈顶为A。这时线程T1已经知道A.next为B，然后希望用CAS将栈顶替换为B：head.compareAndSet(A,B);</p>\n</li>\n<li>\n<p>在T1执行上面这条指令之前，线程T2介入，将A、B出栈，再依次入栈D、C、A，而对象B此时处于游离状态。</p>\n</li>\n<li>\n<p>此时轮到线程T1执行CAS操作，检测发现栈顶仍为A，所以CAS成功，栈顶变为B。但实际上B.next为null，此时堆栈中只有B一个元素，C和D组成的链表不再存在于堆栈中，C、D被丢掉了。</p>\n</li>\n</ol>\n<p>以上就是由于ABA问题带来的隐患，各种乐观锁的实现中通常都会用版本戳version来对记录或对象标记，避免并发操作带来的问题。</p>\n","prev":{"title":"Copy-On-Write实现原理","link":"2018/11/21/Copy-On-Write实现原理"},"next":{"title":"自定义SQL打印","link":"2018/09/20/自定义SQL打印"},"plink":"https://zinki.github.io/2018/10/13/CAS实现原理/"}