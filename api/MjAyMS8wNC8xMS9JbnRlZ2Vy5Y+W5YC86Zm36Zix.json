{"title":"Integer取值陷阱","date":"2021-04-11T05:00:00.000Z","date_formatted":{"ll":"2021年4月11日","L":"2021/04/11","MM-DD":"04-11"},"link":"2021/04/11/Integer取值陷阱","tags":["Integer"],"categories":["学习"],"updated":"2024-10-10T08:03:05.446Z","content":"<p>Java中Integer类型1000!=1000,而100==100<br>\n原因是Integer.java有一个内部私有类IntegerCache.java，它缓存了从-128到127之间的所有的整数对象。<span id=\"more\"></span></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Integer a= 100,b=100;</span><br><span class=\"line\">Integer c= 1000,d=1000;</span><br><span class=\"line\">System.out.println(a == b);</span><br><span class=\"line\">System.out.println(c == d);</span><br></pre></td></tr></table></figure>\n<p>所以事情就成了，所有的小整数在内部缓存，然后当我们声明类似<code>Integer c = 100;</code><br>\n的时候，它实际上在内部做的是：<br>\n<code>Integer i = Integer.valueOf(100);</code><br>\n现在，如果我们去看valueOf()方法，我们可以看到：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public static Integer valueOf(int i) &#123;</span><br><span class=\"line\">    if (i &gt;= IntegerCache.low &amp;&amp; i</span><br><span class=\"line\">    return IntegerCache.cache[i + (-IntegerCache.low)];</span><br><span class=\"line\">    return new Integer(i);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>IntegerCache是一个私有静态内部类</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">private static class IntegerCache &#123;</span><br><span class=\"line\">    static final int low = -128;</span><br><span class=\"line\">    static final int high;</span><br><span class=\"line\">    static final Integer cache[];</span><br><span class=\"line\">    static &#123;</span><br><span class=\"line\">        //high value may be configured by property</span><br><span class=\"line\">        int h = 127;</span><br><span class=\"line\">        String integerCacheHighPropValue =</span><br><span class=\"line\">            sun.misc.VM.getSavedProperty(</span><br><span class=\"line\">            &quot;java.lang.Integer.IntegerCache.high&quot;);</span><br><span class=\"line\">        if(integerCacheHighPropValue != null) &#123;</span><br><span class=\"line\">            int i = parseInt(integerCacheHighPropValue);</span><br><span class=\"line\">            i = Math.max(i, 127);</span><br><span class=\"line\">            //Maximum array size is Integer.MAX_VALUE</span><br><span class=\"line\">            h = Math.min(i, Integer.MAX_VALUE - (-low) -1);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        high = h;</span><br><span class=\"line\">        cache = new Integer[(high - low) + 1];</span><br><span class=\"line\">        int j = low;</span><br><span class=\"line\">        for(int k = 0; k &lt; cache.length; k++)</span><br><span class=\"line\">            cache[k] = new Integer(j++);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    private IntegerCache() &#123;&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>如果值的范围在-128到127之间，它就从高速缓存返回实例。<br>\n合乎逻辑的理由是，在此范围内的<code>小</code>整数使用率比<code>大</code>整数要高，因此，使用相同的底层对象是有价值的，可以减少潜在的内存占用。</p>\n</blockquote>\n<blockquote>\n<p>对于==，如果作用于基本数据类型的变量，则直接比较其存储的值是否相等；<br>\n如果作用于引用类型的变量，则比较的是所指向的对象的地址<br>\n对于equals方法，注意：equals方法不能作用于基本数据类型的变量<br>\n如果没有对equals方法进行重写，则比较的是引用类型的变量所指向的对象的地址；<br>\n诸如String、Date等类对equals方法进行了重写的话，比较的是所指向的对象的内容。</p>\n</blockquote>\n","prev":{"title":"一致性Hash原理","link":"2021/04/25/一致性Hash原理"},"next":{"title":"线程池设置线程名称","link":"2021/03/20/线程池设置线程名称"},"plink":"https://zinki.github.io/2021/04/11/Integer取值陷阱/"}