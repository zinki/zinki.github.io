{"title":"如何实现分布式锁","date":"2019-07-05T02:00:00.000Z","date_formatted":{"ll":"2019年7月5日","L":"2019/07/05","MM-DD":"07-05"},"link":"2019/07/05/如何实现分布式锁","tags":["分布式锁"],"categories":["学习"],"updated":"2024-10-10T08:03:05.466Z","content":"<p>在分布式定时任务实现原理中最重要的就是分布式锁，<span id=\"more\"></span>而分布式锁是控制分布式系统之间同步访问共享资源的一种方式，在分布式系统中常常需要协调它们的动作。如果在不同的系统或者同一个系统的不同主机之间共享了一个或一组资源，那么访问这些资源的时候，往往需要互斥来防止彼此干扰来保证一致性，在这种情况下便需要用到分布式锁。<br>\n分布式锁有3种实现方式，如下所述。</p>\n<ol>\n<li>\n<p>基于数据库的实现方式<br>\n该实现方式完全依靠数据库的唯一索引来实现， 当想要获得锁时，便向数据库中插入一条记录，成功插入则获得锁，执行完成后删除对应的行数据来释放锁。</p>\n</li>\n<li>\n<p>基于Redis的实现方式<br>\n这基于Redis的setnx命令实现的，当缓存里的key不存在时，才会设置成功,并且返回true,否则直接返回false。如果返回true,则表示获取到了锁，否则获取锁失败。为了防止死锁，我们再使用expire命令对这个key设置一个超时时间。</p>\n</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Aspect</span></span><br><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"meta\">@Slf4j</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">RepeatSubmitAspect</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> RedisUtils redisUtils;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Pointcut(&quot;@annotation(noRepeatSubmit)&quot;)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">pointCut</span><span class=\"params\">(NoRepeatSubmit noRepeatSubmit)</span> </span>&#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Around(&quot;pointCut(noRepeatSubmit)&quot;)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Object <span class=\"title\">around</span><span class=\"params\">(ProceedingJoinPoint pjp, NoRepeatSubmit noRepeatSubmit)</span> <span class=\"keyword\">throws</span> Throwable </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        log.info(<span class=\"string\">&quot;请求参数,&#123;&#125;&quot;</span>,JSON.toJSONString(pjp.getArgs()));</span><br><span class=\"line\"></span><br><span class=\"line\">        Integer lockSeconds = noRepeatSubmit.lockTime();</span><br><span class=\"line\"></span><br><span class=\"line\">        HttpServletRequest request = RequestUtils.getRequest();</span><br><span class=\"line\"></span><br><span class=\"line\">        String key = CACHE_PREFIX + request.getServletPath() + BizConstant.COLON + JSON.toJSONString(pjp.getArgs());</span><br><span class=\"line\"></span><br><span class=\"line\">        Boolean flag = redisUtils.getRedisTemplate().opsForValue().setIfAbsent(key, key, lockSeconds, TimeUnit.SECONDS);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (flag) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> pjp.proceed();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            log.error(key, <span class=\"string\">&quot;短时间内不可重复提交&quot;</span>);</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RuntimeException(<span class=\"string\">&quot;短时间内不可重复提交&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ol start=\"3\">\n<li>基于ZooKeeper的实现方式<br>\nZooKeeper是一个为分布式应用提供-致性服务的开源组件，它内部是一一个分层的文件系统目录树结构，规定在同一个目录下只能有一个唯一文件名。 ZooKeeper 的节点有如下几种类型。</li>\n</ol>\n<blockquote>\n<p>永久节点:节点创建后，不会因为会话失效而消失。</p>\n</blockquote>\n<blockquote>\n<p>临时节点:与永久节点相反，如果客户端连接失效，则立即删除节点。</p>\n</blockquote>\n<blockquote>\n<p>顺序节点:在指定创建这类节点时，ZooKeeper会自动在节点名后加一个数字后缀，并且是有序的。<br>\n在创建一个节点时，还可以注册一个该节点的监视器(watcher)， 在节点状态发生改变时，监视器会被触发，同时ZooKeeper会向客户端发送一条通知 (仅会发送一次)。</p>\n</blockquote>\n<p>根据ZooKeeper的这些特性，实现分布式锁的步骤如下。<br>\n(1)创建一个锁目录lock。<br>\n(2)如果线程A需要获得锁，就在lock目录下创建临时顺序节点。<br>\n(3)再查询锁目录下所有的子节点，寻找比自己小的兄弟节点，如果不存在，则说明当前线程的顺序号最小，因此可以获得锁。<br>\n(4)线程B如果也想获取锁，则同样需要查询所有节点，判断自己是不是最小的节点，如果不是，则设置监听比自己值小的节点(只关注比自己值小的节点)。<br>\n(5)线程A在处理完后，删除自己的节点，线程B监听到变更事件，判断自己是不是最小的节点，如果是，则获得锁。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">tryLock</span><span class=\"params\">(<span class=\"keyword\">long</span> timeout, TimeUnit unit)</span> <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> interProcessMutex.acquire(timeout, unit);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">        log.error(e.getMessage(), e);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">unlock</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        interProcessMutex.release();</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (Throwable e) &#123;</span><br><span class=\"line\">        log.error(e.getMessage(), e);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">        executorService.schedule(<span class=\"keyword\">new</span> Cleaner(client, path), </span><br><span class=\"line\">        delayTimeForClean, TimeUnit.MILLISECONDS);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","prev":{"title":"HashMap初始化容量","link":"2019/07/30/HashMap初始化容量"},"next":{"title":"ElasticSearch相关知识","link":"2019/06/15/ElasticSearch相关知识"},"plink":"https://zinki.github.io/2019/07/05/如何实现分布式锁/"}