{"title":"WebSocket原理","date":"2018-01-05T11:10:00.000Z","date_formatted":{"ll":"2018年1月5日","L":"2018/01/05","MM-DD":"01-05"},"link":"2018/01/05/WebSocket原理","tags":["WebSocket"],"categories":["学习"],"updated":"2024-10-11T08:03:01.213Z","content":"<p>WebSocket 是一种在单个TCP连接上进行全双工通信的协议。WebSocket 使得客户端和服务器之间的数据交换变得更加简单，允许服务端主动向客户端推送数据。</p>\n<p>在 WebSocket API 中，浏览器和服务器只需要完成一次握手，两者之间就直接可以创建持久性的连接， 并进行双向数据传输。（维基百科） <span id=\"more\"></span></p>\n<h2 id=\"背景\">背景<a title=\"#背景\" href=\"#背景\"></a></h2>\n<p>在 WebSocket 协议出现以前，创建一个和服务端进双通道通信的 web 应用，需要依赖HTTP协议，进行不停的轮询，这会导致一些问题：</p>\n<p>服务端被迫维持来自每个客户端的大量不同的连接</p>\n<p>大量的轮询请求会造成高开销，比如会带上多余的header，造成了无用的数据传输。</p>\n<p>所以，为了解决这些问题，WebSocket 协议应运而生。</p>\n<h2 id=\"基础帧结构分析\">基础帧结构分析<a title=\"#基础帧结构分析\" href=\"#基础帧结构分析\"></a></h2>\n<p><img src=\"http://zeven.cpolar.cn/2024/10/202410111011376.png\" alt=\"\" loading=\"lazy\" class=\"φbp\"></p>\n<p>FIN:占用1 bit,表示这是消息的最后一个片段。第一个片段也有可能是最后一个片段。<br>\nRSV1，RSV2，RSV3: 每个1 bit<br>\n必须设置为0，除非扩展了非0值含义的扩展。如果收到了一个非0值但是没有扩展任何非0值的含义，接收终端必须断开WebSocket连接。<br>\nOpcode: 4 bit,操作码，如果收到一个未知的操作码，接收终端必须断开WebSocket连接。<br>\n%x0 表示一个持续帧<br>\n​\t%x1 表示一个文本帧<br>\n​\t%x2 表示一个二进制帧<br>\n​\t%x3-7 预留给以后的非控制帧<br>\n​\t%x8 表示一个连接关闭包<br>\n​\t%x9 表示一个ping包<br>\n​\t%xA 表示一个pong包<br>\n​\t%xB-F 预留给以后的控制帧<br>\nMask: 1 bit，mask标志位，定义“有效负载数据”是否添加掩码。如果设置为1，那么掩码的键值存在于Masking-Key中。<br>\nPayload length: 7 bits, 7+16 bits, or 7+64 bits，以字节为单位的“有效负载数据”长度。<br>\nMasking-Key: 0 or 4 bytes，<br>\n​\t所有从客户端发往服务端的数据帧都已经与一个包含在这一帧中的32 bit的掩码进行过了运算。如果mask标志位（1 bit）为1，那么这个字段存在，如果标志位为0，那么这个字段不存在。<br>\n备注：载荷数据的长度，不包括mask key的长度。。<br>\nPayload data： 有效负载数据</p>\n<blockquote></blockquote>\n<p>为什么需要掩码？<br>\n为了安全，但并不是为了防止数据泄密，而是为了防止早期版本的协议中存在的代理缓存污染攻击（proxy cache poisoning attacks）等问题。</p>\n<blockquote></blockquote>\n<h2 id=\"抓包\">抓包<a title=\"#抓包\" href=\"#抓包\"></a></h2>\n<p>请求<br>\n<img src=\"http://zeven.cpolar.cn/2024/10/202410111011260.png\" alt=\"\" loading=\"lazy\"></p>\n<p>响应<br>\n<img src=\"http://zeven.cpolar.cn/2024/10/202410111011549.png\" alt=\"\" loading=\"lazy\"></p>\n<p>这里的请求与响应就是反应了 WebSocket 的一次握手，我们根据上图可以简单抽象一下 WebSocket 的请求和响应格式： 客户端握手请求格式：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GET /chat HTTP/1.1</span><br><span class=\"line\">Host: server.example.com</span><br><span class=\"line\">Upgrade: websocket</span><br><span class=\"line\">Connection: Upgrade</span><br><span class=\"line\">Sec-WebSocket-Key: dGhlIHNhbXBsZSBub25jZQ==</span><br><span class=\"line\">Origin: http://example.com</span><br><span class=\"line\">Sec-WebSocket-Protocol: chat, superchat</span><br><span class=\"line\">Sec-WebSocket-Version: 13</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>服务端握手响应：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">HTTP/1.1 101 Switching Protocols</span><br><span class=\"line\">Upgrade: websocket</span><br><span class=\"line\">Connection: Upgrade</span><br><span class=\"line\">Sec-WebSocket-Accept: s3pPLMBiTxaQ9kYGzzhZRbK+xOo=</span><br><span class=\"line\">Sec-WebSocket-Protocol: chat</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>我们重点说明下结果请求字段：<br>\nUpgrade：表示HTTP协议升级为webSocket<br>\nconnection:Upgrade 请求升级。<br>\nSec-WebSocket-Key： 用于服务端进行标识认证，生成全局唯一id,GUID。<br>\nSec-WebSocket-Version： 版本<br>\nSec-WebSocket-Protocol: 请求服务端使用指定的子协议。如果指定了这个字段，服务器需要包含相同的字段，并且从子协议的之中选择一个值作为建立连接的响应。<br>\nSec-WebSocket-Extensions: WebSocket的扩展。<br>\nSec-WebSocket-Accept: s3pPLMBiTxaQ9kYGzzhZRbK+xOo= 生成的全局唯一id，GUID。<br>\nGUID的生成算法<br>\n算法思想：通过 Sec-WebSocket-Key 传入的<br>\n值，dGhlIHNhbXBsZSBub25jZQ==，连接服务端生成的字符串，拼接格式如下</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dGhlIHNhbXBsZSBub25jZQ==258EAFA5-E914-47DA-95CA-</span><br><span class=\"line\"> C5AB0DC85B11</span><br></pre></td></tr></table></figure>\n<p>然后采用SHA-1哈希算法，然后用base64编码生成最终的 Sec-WebSocket-Accept的值，生成的值就是</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">s3pPLMBiTxaQ9kYGzzhZRbK+xOo=</span><br></pre></td></tr></table></figure>\n<blockquote></blockquote>\n<p>（注意，这里SHA1哈希算法生成的结果必须是二进制的哈希结果，比如<br>\nPython代码中的</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">h = hashlib.sha1(&quot;dGhlIHNhbXBsZSBub25jZQ==258EAFA5-E914-47DA-95CA-C5AB0DC85B11&quot;)</span><br><span class=\"line\">.digest()</span><br></pre></td></tr></table></figure>\n<p>如果用在线处理工具生成，生成的Hash是16进制的哈希，用 Base64就会生成错误结果）。</p>\n<blockquote></blockquote>\n<h2 id=\"总结\">总结<a title=\"#总结\" href=\"#总结\"></a></h2>\n<blockquote>\n<p>WebSocket 是为了在 web 应用上进行双通道通信而产生的协议，相比于轮询HTTP请求的方式，WebSocket 有节省服务器资源，效率高等优点。</p>\n</blockquote>\n<blockquote>\n<p>WebSocket 中的掩码是为了防止早期版本中存在中间缓存污染攻击等问题而设置的，客户端向服务端发送数据需要掩码，服务端向客户端发送数据不需要掩码。</p>\n</blockquote>\n<blockquote>\n<p>WebSocket 中 Sec-WebSocket-Key 的生成算法是拼接服务端和客户端生成的字符串，进行SHA1哈希算法，再用base64编码。</p>\n</blockquote>\n<blockquote>\n<p>WebSocket 协议握手是依靠 HTTP 协议的，依靠于 HTTP 响应101进行协议升级转换。</p>\n</blockquote>\n<h2 id=\"参考\">参考<a title=\"#参考\" href=\"#参考\"></a></h2>\n<p><a href=\"https://juejin.im/post/5c693a4f51882561fb1db0ff\" target=\"_blank\">简单聊聊WebSocket</a></p>\n","prev":{"title":"秒杀方案设计","link":"2018/01/17/秒杀方案设计"},"next":{"title":"深入分析ReentrantLock","link":"2017/12/13/深入分析ReentrantLock"},"plink":"https://zinki.github.io/2018/01/05/WebSocket原理/","toc":[{"id":"背景","title":"背景","index":"1"},{"id":"基础帧结构分析","title":"基础帧结构分析","index":"2"},{"id":"抓包","title":"抓包","index":"3"},{"id":"总结","title":"总结","index":"4"},{"id":"参考","title":"参考","index":"5"}]}