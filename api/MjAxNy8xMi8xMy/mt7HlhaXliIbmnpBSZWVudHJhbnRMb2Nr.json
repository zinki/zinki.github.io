{"title":"深入分析ReentrantLock","date":"2017-12-13T12:17:00.000Z","date_formatted":{"ll":"2017年12月13日","L":"2017/12/13","MM-DD":"12-13"},"link":"2017/12/13/深入分析ReentrantLock","tags":["ReentrantLock"],"categories":["学习"],"updated":"2024-11-02T11:31:53.934Z","content":"<p>ReentrantLock是java concurrent包提供的一种锁实现。不同于synchronized，ReentrantLock是从代码层面实现同步的。 <span id=\"more\"></span></p>\n<p><img src=\"http://web.zeven.site/2024/10/202410111017306.png\" alt=\"\" loading=\"lazy\" class=\"φbp\"></p>\n<p>Lock定义了锁的接口规范。 <br>\nReentrantLock实现了Lock接口。 <br>\nAbstractQueuedSynchronizer中以队列的形式实现线程之间的同步。 <br>\nReentrantLock的方法都依赖于AbstractQueuedSynchronizer的实现。<br>\nLock接口定义了如下方法：</p>\n<p><img src=\"http://web.zeven.site/2024/10/202410111017757.png\" alt=\"\" loading=\"lazy\" class=\"φbp\"></p>\n<h2 id=\"lock()方法的实现\">lock()方法的实现<a title=\"#lock()方法的实现\" href=\"#lock()方法的实现\"></a></h2>\n<p>进入lock()方法，发现其内部调用的是sync.lock();</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">lock</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    sync.lock();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>sync是在ReentrantLock的构造函数中实现的。其中fair参数的不同可实现公平锁和非公平锁。由于在锁释放的阶段，锁处于无线程占有的状态，此时其他线程和在队列中等待的线程都可以抢占该锁，从而出现公平锁和非公平锁的区别。 <br>\n非公平锁：当锁处于无线程占有的状态，此时其他线程和在队列中等待的线程都可以抢占该锁。 <br>\n公平锁：当锁处于无线程占有的状态，在其他线程抢占该锁的时候，都需要先进入队列中等待。 <br>\n本文以非公平锁NonfairSync的sync实例进行分析。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ReentrantLock</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    sync = <span class=\"keyword\">new</span> NonfairSync();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ReentrantLock</span><span class=\"params\">(<span class=\"keyword\">boolean</span> fair)</span> </span>&#123;</span><br><span class=\"line\">    sync = (fair)? <span class=\"keyword\">new</span> FairSync() : <span class=\"keyword\">new</span> NonfairSync();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>由图可知，NonfairSync继承自Sync，因此也继承了AbstractQueuedSynchronizer中的所有方法实现。接着进入NonfairSync的lock()方法。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">lock</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">           <span class=\"comment\">// 利用cas置状态位，如果成功，则表示占有锁成功</span></span><br><span class=\"line\">           <span class=\"keyword\">if</span> (compareAndSetState(<span class=\"number\">0</span>, <span class=\"number\">1</span>))</span><br><span class=\"line\">               <span class=\"comment\">// 记录当前线程为锁拥有者</span></span><br><span class=\"line\">               setExclusiveOwnerThread(Thread.currentThread());</span><br><span class=\"line\">           <span class=\"keyword\">else</span></span><br><span class=\"line\">               acquire(<span class=\"number\">1</span>);</span><br><span class=\"line\">       &#125;</span><br></pre></td></tr></table></figure>\n<p>在lock方法中，利用cas实现ReentrantLock的状态置位（cas即compare and swap，它是CPU的指令，因此赋值操作都是原子性的）。如果成功，则表示占有锁成功，并记录当前线程为锁拥有者。当占有锁失败，则调用acquire(1)方法继续处理。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">acquire</span><span class=\"params\">(<span class=\"keyword\">int</span> arg)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//尝试获得锁，如果失败，则加入到队列中进行等待</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class=\"line\">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class=\"line\">        selfInterrupt();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>acquire()是AbstractQueuedSynchronizer的方法。它首先会调用tryAcquire()去尝试获得锁，如果获得锁失败，则将当前线程加入到CLH队列中进行等待。tryAcquire()方法在NonfairSync中有实现，但最终调用的还是Sync中的nonfairTryAcquire()方法。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> <span class=\"title\">tryAcquire</span><span class=\"params\">(<span class=\"keyword\">int</span> acquires)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> nonfairTryAcquire(acquires);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> <span class=\"title\">nonfairTryAcquire</span><span class=\"params\">(<span class=\"keyword\">int</span> acquires)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> Thread current = Thread.currentThread();</span><br><span class=\"line\">    <span class=\"comment\">// 获得状态</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> c = getState();</span><br><span class=\"line\">    <span class=\"comment\">// 如果状态为0，则表示该锁未被其他线程占有</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (c == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 此时要再次利用cas去尝试占有锁</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (compareAndSetState(<span class=\"number\">0</span>, acquires)) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 标记当前线程为锁拥有者</span></span><br><span class=\"line\">            setExclusiveOwnerThread(current);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 如果当前线程已经占有了，则state + 1,记录占有次数</span></span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> nextc = c + acquires;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (nextc &lt; <span class=\"number\">0</span>) <span class=\"comment\">// overflow</span></span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> Error(<span class=\"string\">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 此时无需利用cas去赋值，因为该锁肯定被当前线程占有</span></span><br><span class=\"line\">        setState(nextc);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在nonfairTryAcquire()中，首先会去获得锁的状态，如果为0，则表示锁未被其他线程占有，此时会利用cas去尝试将锁的状态置位，并标记当前线程为锁拥有者；如果锁的状态大于0，则会判断锁是否被当前线程占有，如果是，则state + 1，这也是为什么lock()的次数要和unlock()次数对等；如果占有锁失败，则返回false。 <br>\n在nonfairTryAcquire()返回false的情况下，会继续调用acquireQueued(addWaiter(Node.EXCLUSIVE), arg))方法，将当前线程加入到队列中继续尝试获得锁。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> Node <span class=\"title\">addWaiter</span><span class=\"params\">(Node mode)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//　创建当前线程的节点</span></span><br><span class=\"line\">    Node node = <span class=\"keyword\">new</span> Node(Thread.currentThread(), mode);</span><br><span class=\"line\">    <span class=\"comment\">// Try the fast path of enq; backup to full enq on failure</span></span><br><span class=\"line\">    Node pred = tail;</span><br><span class=\"line\">    <span class=\"comment\">// 如果尾节点不为空</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (pred != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 则将当前线程的节点加入到尾节点之后，成为新的尾节点</span></span><br><span class=\"line\">        node.prev = pred;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (compareAndSetTail(pred, node)) &#123;</span><br><span class=\"line\">            pred.next = node;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> node;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    enq(node);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> node;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> Node <span class=\"title\">enq</span><span class=\"params\">(<span class=\"keyword\">final</span> Node node)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// CAS方法有可能失败，因此要循环调用，直到当前线程的节点加入到队列中</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (;;) &#123;</span><br><span class=\"line\">        Node t = tail;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (t == <span class=\"keyword\">null</span>) &#123; <span class=\"comment\">// Must initialize</span></span><br><span class=\"line\">            Node h = <span class=\"keyword\">new</span> Node(); <span class=\"comment\">// Dummy header，头节点为虚拟节点</span></span><br><span class=\"line\">            h.next = node;</span><br><span class=\"line\">            node.prev = h;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (compareAndSetHead(h)) &#123;</span><br><span class=\"line\">                tail = node;  </span><br><span class=\"line\">                <span class=\"keyword\">return</span> h;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            node.prev = t;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (compareAndSetTail(t, node)) &#123;</span><br><span class=\"line\">                t.next = node;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> t;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>addWaiter()是AbstactQueuedSynchronizer的方法，会以节点的形式来标记当前线程，并加入到尾节点中。enq()方法是在节点加入到尾节点失败的情况下，通过for(;;)循环反复调用cas方法，直到节点加入成功。由于enq()方法是非线程安全的，所以在增加节点的时候，需要使用cas设置head节点和tail节点。此时添加成功的结点状态为Node.EXCLUSIVE。 <br>\n在节点加入到队列成功之后，会接着调用acquireQueued()方法去尝试获得锁。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> <span class=\"title\">acquireQueued</span><span class=\"params\">(<span class=\"keyword\">final</span> Node node, <span class=\"keyword\">int</span> arg)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">boolean</span> interrupted = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (;;) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 获得前一个节点</span></span><br><span class=\"line\">            <span class=\"keyword\">final</span> Node p = node.predecessor();</span><br><span class=\"line\">            <span class=\"comment\">// 如果前一个节点是头结点，那么直接去尝试获得锁</span></span><br><span class=\"line\">            <span class=\"comment\">// 因为其他线程有可能随时会释放锁，没必要Park等待</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class=\"line\">                setHead(node);</span><br><span class=\"line\">                p.next = <span class=\"keyword\">null</span>; <span class=\"comment\">// help GC</span></span><br><span class=\"line\">                <span class=\"keyword\">return</span> interrupted;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class=\"line\">                parkAndCheckInterrupt())</span><br><span class=\"line\">                interrupted = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (RuntimeException ex) &#123;</span><br><span class=\"line\">        cancelAcquire(node);</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> ex;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在acquireQueued()方法中，会利用for (;;)一直去获得锁，如果前一个节点为head节点，则表示可以直接尝试去获得锁了，因为占用锁的线程随时都有可能去释放锁并且该线程是被unpark唤醒的CLH队列中的第一个节点，获得锁成功后返回。 <br>\n如果该线程的节点在CLH队列中比较靠后或者获得锁失败，即其他线程依然占用着锁，则会接着调用shouldParkAfterFailedAcquire()方法来阻塞当前线程，以让出CPU资源。在阻塞线程之前，会执行一些额外的操作以提高CLH队列的性能。由于队列中前面的节点有可能在等待过程中被取消掉了，因此当前线程的节点需要提前，并将前一个节点置状态位为SIGNAL，表示可以阻塞当前节点。因此该函数在判断到前一个节点为SIGNAL时，直接返回true即可。此处虽然存在对CLH队列的同步操作，但由于局部变量节点肯定是不一样的，所以对CLH队列操作是线程安全的。由于在compareAndSetWaitStatus(pred, ws, Node.SIGNAL)执行之前可能发生pred节点抢占锁成功或pred节点被取消掉，因此此处需要返回false以允许该节点可以抢占锁。 <br>\n当shouldParkAfterFailedAcquire()返回true时，会进入parkAndCheckInterrupt()方法。parkAndCheckInterrupt()方法最终调用safe.park()阻塞该线程，以免该线程在等待过程中无线循环消耗cpu资源。至此，当前线程便被park了。那么线程何时被unpark，这将在unlock()方法中进行。 <br>\n这里有一个小细节需要注意，在线程被唤醒之后，会调用Thread.interrupted()将线程中断状态置位为false，然后记录下中断状态并返回上层函数去抛出异常。我想这样设计的目的是为了可以让该线程可以完成抢占锁的操作，从而可以使当前节点称为CLH的虚拟头节点。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">boolean</span> <span class=\"title\">shouldParkAfterFailedAcquire</span><span class=\"params\">(Node pred, Node node)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> ws = pred.waitStatus;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (ws == Node.SIGNAL)</span><br><span class=\"line\">        <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">         * This node has already set status asking a release</span></span><br><span class=\"line\"><span class=\"comment\">         * to signal it, so it can safely park</span></span><br><span class=\"line\"><span class=\"comment\">         */</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (ws &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 如果前面的节点是CANCELLED状态，则一直提前</span></span><br><span class=\"line\">        <span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">            node.prev = pred = pred.prev;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">while</span> (pred.waitStatus &gt; <span class=\"number\">0</span>);</span><br><span class=\"line\">        pred.next = node;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        compareAndSetWaitStatus(pred, ws, Node.SIGNAL);</span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> <span class=\"title\">parkAndCheckInterrupt</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    LockSupport.park(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> Thread.interrupted();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">park</span><span class=\"params\">(Object blocker)</span> </span>&#123;</span><br><span class=\"line\">    Thread t = Thread.currentThread();</span><br><span class=\"line\">    setBlocker(t, blocker);</span><br><span class=\"line\">    unsafe.park(<span class=\"keyword\">false</span>, <span class=\"number\">0L</span>);</span><br><span class=\"line\">    setBlocker(t, <span class=\"keyword\">null</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"unlock()方法的实现\">unlock()方法的实现<a title=\"#unlock()方法的实现\" href=\"#unlock()方法的实现\"></a></h2>\n<p>同lock()方法，unlock()方法依然调用的是sync.release(1)。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> <span class=\"title\">release</span><span class=\"params\">(<span class=\"keyword\">int</span> arg)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 释放锁</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (tryRelease(arg)) &#123;</span><br><span class=\"line\">        Node h = head;</span><br><span class=\"line\">        <span class=\"comment\">// 此处有个疑问，为什么需要判断h.waitStatus != 0</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (h != <span class=\"keyword\">null</span> &amp;&amp; h.waitStatus != <span class=\"number\">0</span>)</span><br><span class=\"line\">            unparkSuccessor(h);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> <span class=\"title\">tryRelease</span><span class=\"params\">(<span class=\"keyword\">int</span> releases)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> c = getState() - releases;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (Thread.currentThread() != getExclusiveOwnerThread())</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalMonitorStateException();</span><br><span class=\"line\">    <span class=\"keyword\">boolean</span> free = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (c == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        free = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        setExclusiveOwnerThread(<span class=\"keyword\">null</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    setState(c);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> free;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>可以看到，tryRelease()方法实现了锁的释放，逻辑上即是将锁的状态置为0。当释放锁成功之后，通常情况下不需要唤醒队列中线程，因此队列中总是有一个线程处于活跃状态。</p>\n<h2 id=\"总结\">总结<a title=\"#总结\" href=\"#总结\"></a></h2>\n<p>ReentrantLock的锁资源以state状态描述，利用CAS则实现对锁资源的抢占，并通过一个CLH队列阻塞所有竞争线程，在后续则逐个唤醒等待中的竞争线程。ReentrantLock继承AQS完全从代码层面实现了java的同步机制，相对于synchronized，更容易实现对各类锁的扩展。同时，AbstractQueuedSynchronizer中的Condition配合ReentrantLock使用，实现了wait/notify的功能。</p>\n<h2 id=\"参考\">参考<a title=\"#参考\" href=\"#参考\"></a></h2>\n<p><a href=\"https://blog.csdn.net/jiangjiajian2008/article/details/52226189\" target=\"_blank\">深入分析ReentrantLock</a></p>\n","prev":{"title":"WebSocket原理","link":"2018/01/05/WebSocket原理"},"next":{"title":"Nginx部署实践","link":"2017/11/27/Nginx部署实践"},"plink":"https://zinki.github.io/2017/12/13/深入分析ReentrantLock/","toc":[{"id":"lock()方法的实现","title":"lock()方法的实现","index":"1"},{"id":"unlock()方法的实现","title":"unlock()方法的实现","index":"2"},{"id":"总结","title":"总结","index":"3"},{"id":"参考","title":"参考","index":"4"}]}