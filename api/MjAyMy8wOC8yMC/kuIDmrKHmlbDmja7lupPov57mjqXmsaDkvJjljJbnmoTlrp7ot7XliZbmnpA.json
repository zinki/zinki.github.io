{"title":"一次数据库连接池优化的实践剖析","date":"2023-08-20T03:35:00.000Z","date_formatted":{"ll":"2023年8月20日","L":"2023/08/20","MM-DD":"08-20"},"link":"2023/08/20/一次数据库连接池优化的实践剖析","tags":["数据库","线程池"],"categories":["转载"],"updated":"2024-10-11T08:44:53.347Z","content":"<p>一段时间以来，XXX 部门开放平台 OPENXXX 系统在业务高峰频繁出现 MySQL 线程数升高的现象。升高本身不是问题，问题是随着业务高峰过去，QPS 下来后 ，MySQL 线程数却依然居高不下，这是什么原因？</p>\n<span id=\"more\"></span>\n<p>思考方向上，大家都知道，MySQL 是通过线程池来进行线程管理的，基于过往经验，上述情况很可能是线程池的配置策略不合理导致线程创建后无法及时释放，而实际上线程的利用率是很低的————这一点通过分析系统线程也可以看到，waiting 态线程占据 MySQL 总线程数的一半有余（见下图）。</p>\n<p>落地实践上，方向虽然是明确的，但具体是 MySQL 的哪一项策略配置不合理、又该做怎样的调整，需要做细致的调研分析才能回答。由此发起 MySQL 线程的优化治理专项。</p>\n<h2 id=\"追根溯源：问题根源的分析定位\"><img src=\"http://zeven.cpolar.cn/2024/07/202407062210578.png\" alt=\"\"><br>\n追根溯源：问题根源的分析定位<a title=\"#追根溯源：问题根源的分析定位\" href=\"#追根溯源：问题根源的分析定位\"></a></h2>\n<p>对比业务高峰前后的 MySQL 线程，发现飙升的主要是 [MySQL Statement Cancellation Timer] ，由此引出第一阶段问题，[MySQL Statement Cancellation Timer] 线程是从哪里来的？</p>\n<h3 id=\"一、timer-线程生命周期\">一、Timer 线程生命周期<a title=\"#一、timer-线程生命周期\" href=\"#一、timer-线程生命周期\"></a></h3>\n<p>走读代码流程，梳理得到 Timer 线程的生命周期，如下图所示（Timer 节点以及问题节点已标识）——<br>\n<img src=\"http://zeven.cpolar.cn/2024/07/202407062213258.png\" alt=\"\" loading=\"lazy\"></p>\n<h3 id=\"二、生命周期详细解读\">二、生命周期详细解读<a title=\"#二、生命周期详细解读\" href=\"#二、生命周期详细解读\"></a></h3>\n<h4 id=\"timer-线程创建链路\">Timer 线程创建链路<a title=\"#timer-线程创建链路\" href=\"#timer-线程创建链路\"></a></h4>\n<p>dump 现场线程，配合线程 stack 走读 mysql connector jar 的代码。<br>\n<img src=\"http://zeven.cpolar.cn/2024/07/202407062214861.png\" alt=\"\" loading=\"lazy\"><br>\n1、定位代码，java.util.TimerThread#run—— TimerThread 是 mysql-connector-java-xxx.jar 中的 Timer 的一个内部类，等待 Timer 队列中的任务以执行、调度<br>\n<img src=\"http://zeven.cpolar.cn/2024/07/202407062222724.png\" alt=\"\" loading=\"lazy\"></p>\n<p>2、顺藤摸瓜，可以追到 [MySQL Statement Cancellation Timer] 线程的生成链路</p>\n<p>com.mysql.jdbc.ConnectionImpl#getCancelTimer<br>\n<img src=\"http://zeven.cpolar.cn/2024/07/202407062222644.png\" alt=\"\" loading=\"lazy\"></p>\n<p>3、查看 getCancelTimer 的上游调用 ，主要是 mysql-connector-java-xxx.jar 中的主管 sql 查询的 Statement<br>\n<img src=\"http://zeven.cpolar.cn/2024/07/202407062223261.png\" alt=\"\" loading=\"lazy\"><br>\ncom.mysql.jdbc.StatementImpl#executeQuery<br>\n<img src=\"http://zeven.cpolar.cn/2024/07/202407062223950.png\" alt=\"\" loading=\"lazy\"><br>\n<strong>小结</strong></p>\n<p>走读 [MySQL Statement Cancellation Timer] 线程的调用链逻辑，可以抽象 3 点核心信息——</p>\n<ul>\n<li>Timer 线程是 mysql connection 连接维度的</li>\n<li>应用开启 mysql 的 queryTimeouts 且 timeoutInMillis != 0 的话，伴随每一个连接的创建，都会同步开启一个 Timer 线程，以进行超时控制</li>\n<li>Timer 线程便是之前通过 jstack 抓取到的 DB 异常线程 [MySQL Statement Cancellation Timer]</li>\n</ul>\n<p>可以推断 OPENXXX 应用必定开启了 queryTimeout。查看 mybatis-config.xml，确定在每次 DB 查询的时候，均插上了 queryTimeout——defaultStatementTimeout 设置对全局 sql 生效，包括 insert、select、update<br>\n<img src=\"http://zeven.cpolar.cn/2024/07/202407062224358.png\" alt=\"\" loading=\"lazy\"></p>\n<h4 id=\"timer-线程销毁链路\">Timer 线程销毁链路<a title=\"#timer-线程销毁链路\" href=\"#timer-线程销毁链路\"></a></h4>\n<p>jdk 规范保证，任何线程都有自身的退出机制。查看 Statement 中 cancelTask 的执行过程，依次追溯。</p>\n<p>1、com.mysql.jdbc.StatementImpl.CancelTask#run——调用 Connection 进行 cancel<br>\n![[Pasted image 20240706222430.png]]</p>\n<p>2、com.mysql.jdbc.ConnectionImpl#close<br>\n<img src=\"http://zeven.cpolar.cn/2024/07/202407062224680.png\" alt=\"\" loading=\"lazy\"></p>\n<p>3、com.mysql.jdbc.ConnectionImpl#realClose——关闭 Timer 线程<br>\n<img src=\"http://zeven.cpolar.cn/2024/07/202407062224274.png\" alt=\"\" loading=\"lazy\"><br>\n<strong>小结</strong></p>\n<p>至此获取到 [MySQL Statement Cancellation Timer] 线程的 cancel 链路，走读代码逻辑，抽象核心信息——连接关闭时，会调用 Connection.close 方法 cancel 掉 Timer 线程，即 [MySQL Statement Cancellation Timer] 线程。</p>\n<h3 id=\"三、核心问题总结定位\">三、核心问题总结定位<a title=\"#三、核心问题总结定位\" href=\"#三、核心问题总结定位\"></a></h3>\n<p>连接创建时，queryTimeout 会使 jdbc driver 新建 cancelTask 并使用 Timer 进行调度，一旦 sql 查询超时则执行 cancel 动作；连接关闭时，调用 Connection 以 cancel 掉 Timer 线程。</p>\n<p>问题来到第二个阶段：既然连接超时关闭的时候，才会将 Timer 线程 cancel 掉，那么控制超时的具体是哪些策略呢？</p>\n<h2 id=\"超时策略：mysql-线程数下降的关键\">超时策略：MySQL 线程数下降的关键<a title=\"#超时策略：mysql-线程数下降的关键\" href=\"#超时策略：mysql-线程数下降的关键\"></a></h2>\n<p>对于选型关系型数据库的应用而言，数据库的连接关闭策略自上而下由两层组成：1、JDBC；2、Mysql，经由各层的一系列超时参数进行控制。需要注意的是，网络文档对各层各参数的释义大多不够精准，甚至相互矛盾。以下参数分析均来自官方文档，并随载官方链接以便详细查阅。</p>\n<h3 id=\"一、jdbc-层（c3p0）\">一、JDBC 层（c3p0）<a title=\"#一、jdbc-层（c3p0）\" href=\"#一、jdbc-层（c3p0）\"></a></h3>\n<p><strong>连接超时参数</strong></p>\n<ul>\n<li>maxIdleTime：在从池中剔除连接之前，允许连接闲置多少秒</li>\n</ul>\n<p><strong>有效性检测参数</strong></p>\n<ol>\n<li>idleConnecnTestPeriod：定时检测池中空闲连接的周期，用以校验连接的有效性</li>\n<li>testConnectionOnCheckin：连接提交时，异步校验其有效性</li>\n<li>testConnectionOnCheckout：连接回收时，同步校验其有效性</li>\n<li>preferredTestQuery：连接的有效性校验语句。JDBC4 的连接包括一个名为 isvalid（）的方法，该方法可作为快速、可靠的连接测试来执行</li>\n</ol>\n<p><strong>解读一下</strong></p>\n<ol>\n<li>testConnectionOnCheckin 是一个异步检测参数而非同步参数，connection 提交指的是 connection 连接到 mysql server 而非执行任务</li>\n<li>3个检测参数是搭配使用的——连接提交后，会开启连接状态的定期检测机制（testConnectionOnCheckin 为 true），即每 30 秒（idleConnectionTestPeriod=30）通过 SELECT 1（preferredTestQuery=SELECT 1）语句检测一次连接状态，从而降低 Communications link failure 的发生概率</li>\n</ol>\n<p><strong>关于参数的 Q&amp;A</strong></p>\n<p>设置完连接超时参数 maxIdleTime 之后，有必要设置有效性检测参数么——两者的关系是：连接空闲超过 maxIdleTime 后，就会被 mysql server 断开。但此时连接池并没有回收这个连接，直到连接池检测到该连接已被废弃后，才会进行回收。在这个时间段内，如果客户端使用了这个连接，就会报错：Communications link failure。<br>\n<img src=\"http://zeven.cpolar.cn/2024/07/202407062226902.png\" alt=\"\" loading=\"lazy\"></p>\n<h3 id=\"二、db-server-层\">二、DB Server 层<a title=\"#二、db-server-层\" href=\"#二、db-server-层\"></a></h3>\n<p>wait_timeout]：mysql server 关闭连接之前，允许连接闲置多少秒。默认是 28800，单位秒，即 8 个小时</p>\n<h3 id=\"三、超时策略探究总结\">三、超时策略探究总结<a title=\"#三、超时策略探究总结\" href=\"#三、超时策略探究总结\"></a></h3>\n<p>既然 jdbc 层面以及 mysql 层面都有完备的连接关闭策略，那么问题来到第三个阶段：OPENXXX 系统自身的配置策略是怎样的？</p>\n<h2 id=\"系统分析：openxxx-的超时关闭策略\">系统分析：OPENXXX 的超时关闭策略<a title=\"#系统分析：openxxx-的超时关闭策略\" href=\"#系统分析：openxxx-的超时关闭策略\"></a></h2>\n<p>依据上文调研的连接关闭策略，摸查 OPENXXX 应用，1、JDBC；2、Mysql。</p>\n<h3 id=\"一、jdbc-层（c3p0）-1\">一、JDBC 层（c3p0）<a title=\"#一、jdbc-层（c3p0）-1\" href=\"#一、jdbc-层（c3p0）-1\"></a></h3>\n<p>OPENXXX 在 jdbc 层面未配置连接关闭策略（无 maxIdleTime），如此一来，只能依赖下层 mysql 的 timeout 机制进行连接的关闭。但实际上，mysql server 能否关掉连接呢？</p>\n<h3 id=\"二、db-server-层-1\">二、DB Server 层<a title=\"#二、db-server-层-1\" href=\"#二、db-server-层-1\"></a></h3>\n<p>1、查询 mysql server 的 wait_timeout 参数，观察 DB 设定的连接超时配置——[select variable_name,variable_value from information_schema.session_variables where variable_name like ‘wait_timeout’]</p>\n<p>![[Pasted image 20240706222925.png]]</p>\n<p>2、查询 mysql server 的 Threads_connected 参数，观察 DB 当前打开的连接数——[show status where <code>variable_name</code> = ‘Threads_connected’]</p>\n<p><img src=\"http://zeven.cpolar.cn/2024/07/202407062229927.png\" alt=\"\" loading=\"lazy\" class=\"φbp\"></p>\n<p>3、查询 DB 日常的 qps</p>\n<p>![[Pasted image 20240706222951.png]]</p>\n<p>4、汇总信息：connectionSize～800，qps～800，keepAliveTime～28800s。由此计算线程释放的概率：(qps _keepAliveTime) / connectionSize，即 800_28800/800=28800——意味着每个连接在关闭之前，有 28800 次机会拿到任务而不被终止。这种概率下，连接是不可能释放的，连接空置率也会很高。</p>\n<h3 id=\"三、系统分析判断印证\">三、系统分析判断印证<a title=\"#三、系统分析判断印证\" href=\"#三、系统分析判断印证\"></a></h3>\n<ul>\n<li>查询 DB 日常的总连接数，可以看到连接无法主动释放</li>\n</ul>\n<p>![[Pasted image 20240706223005.png]]</p>\n<ul>\n<li>查询 DB 当前所有连接的运行情况，可以看到连接空置率很高，绝大多数处于 idle 状态——[show full processlist] 查看，其中 Command 标识连接的运行状态，比如：Sleep，Query，Connect 等</li>\n</ul>\n<p><img src=\"http://zeven.cpolar.cn/2024/07/202407062230436.png\" alt=\"\" loading=\"lazy\" class=\"φbp\"></p>\n<h2 id=\"解决方案：恰当的超时关闭策略\">解决方案：恰当的超时关闭策略<a title=\"#解决方案：恰当的超时关闭策略\" href=\"#解决方案：恰当的超时关闭策略\"></a></h2>\n<p>通过配置 jdbc 层的连接关闭策略，及时关掉空闲连接，从而确保 timer 线程的 cancle。问题来到第四个阶段：如何配置 OPENXXX 的连接关闭策略？</p>\n<h3 id=\"一、建议方案\">一、建议方案<a title=\"#一、建议方案\" href=\"#一、建议方案\"></a></h3>\n<p>实际上，官方已经给出了建议：</p>\n<p>The most reliable time to test Connections is on check-out. But this is also the most costly choice from a client-performance perspective. Most applications should work quite reliably using a combination of idleConnectionTestPeriod and testConnectionOnCheckin. Both the idle test and the check-in test are performed asynchronously, which can lead to better performance, both perceived and actual.</p>\n<p>最可靠的连接测试时机是在 connection 回收时进行（testConnectionOnCheckout），但从系统性能的角度来看，这也是最耗费性能的选择。大多数应用程序应该组合使用 idleConnectionTestPeriod 和 testconConnectionCheckin，一方面可以保证系统非常可靠地运行，另一方面空闲测试和提交测试都是异步执行的，这会带来更好的系统性能。</p>\n<p>Set idleConnectionTestPeriod to 30, fire up you application and observe. This is a pretty robust setting, all Connections will tested on check-in and every 30 seconds thereafter while in the pool. Your application should experience broken or stale Connections only very rarely, and the pool should recover from a database shutdown and restart quickly</p>\n<p>将 idleConnectionTestPeriod 设置为 30，启动系统并观察。这是一个非常健壮的设置，所有连接都将在提交时进行测试，之后每隔 30 秒在池中进行一次测试。这样应用程序可以很少拿到断开或过时的连接，并且可以在 DB 重启之后支持连接的快速恢复。</p>\n<h3 id=\"二、策略配置\">二、策略配置<a title=\"#二、策略配置\" href=\"#二、策略配置\"></a></h3>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;property name=&quot;preferredTestQuery&quot;&gt;SELECT 1&lt;/property&gt; &lt;!-- 有效性检测语句 --&gt;  </span><br><span class=\"line\">&lt;property name=&quot;testConnectionOnCheckin&quot;&gt;true&lt;/property&gt; &lt;!-- 提交连接时校验连接的有效性。Default: false --&gt;=  </span><br><span class=\"line\">&lt;property name=&quot;idleConnectionTestPeriod&quot;&gt;30&lt;/property&gt; &lt;!-- 每 30 秒检查连接池中的空闲连接。若为 0 则永不检测。Default: 0 --&gt;  </span><br><span class=\"line\">&lt;property name=&quot;maxIdleTime&quot;&gt;30&lt;/property&gt; &lt;!-- 最大空闲时间，30 秒内未使用连接被丢弃。若为 0 则永不丢弃。Default: 0 --&gt;</span><br></pre></td></tr></table></figure>\n<h2 id=\"测试验证：超时策略的有效性验证\">测试验证：超时策略的有效性验证<a title=\"#测试验证：超时策略的有效性验证\" href=\"#测试验证：超时策略的有效性验证\"></a></h2>\n<p>test 环境进行测试，验证配置策略的有效性，三步走：<br>\n1、高 qps，mock db 流量，重复发起 query 请求——观察 cat 堆栈，是否生成大量的 [MySQL Statement Cancellation Timer]<br>\n2、低 qps，mock db 流量，间隔发起 query 请求——观察 cat 堆栈，是否开始缩减 [MySQL Statement Cancellation Timer]<br>\n3、无 qps，关闭 db 流量——观察 cat 堆栈，无 [MySQL Statement Cancellation Timer]</p>\n<h3 id=\"一、测试代码展示\">一、测试代码展示<a title=\"#一、测试代码展示\" href=\"#一、测试代码展示\"></a></h3>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Controller</span><br><span class=\"line\">@RequestMapping(&quot;/dbtimer&quot;)</span><br><span class=\"line\">public class DBTimerController &#123;</span><br><span class=\"line\">    @Resource</span><br><span class=\"line\">    private PushCallbackService callbackService;</span><br><span class=\"line\">    @Autowired</span><br><span class=\"line\">    private MccClient mccClient;</span><br><span class=\"line\">    private static final Logger LOGGER = LoggerFactory.getLogger(DBTimerController.class);</span><br><span class=\"line\">    private static final ExecutorService executorService = Executors.newFixedThreadPool(50);//创建线程池</span><br><span class=\"line\"></span><br><span class=\"line\">    @ResponseBody</span><br><span class=\"line\">    @RequestMapping(value = &quot;/dbtest&quot;, method = RequestMethod.GET)</span><br><span class=\"line\">    @Ignore(&quot;工具接口,无需鉴权&quot;)</span><br><span class=\"line\">    public void dbTest() &#123;</span><br><span class=\"line\">        TimerQ timerQ = new TimerQ();</span><br><span class=\"line\">        for (int i = 0; i &lt; 50; i++) &#123;</span><br><span class=\"line\">            executorService.execute(new TimerR(timerQ));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    @ResponseBody</span><br><span class=\"line\">    @RequestMapping(value = &quot;/dbtestdown&quot;, method = RequestMethod.GET)</span><br><span class=\"line\">    @Ignore(&quot;工具接口,无需鉴权&quot;)</span><br><span class=\"line\">    public void dbTestDown() &#123;</span><br><span class=\"line\">        executorService.shutdown();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    class TimerQ &#123;</span><br><span class=\"line\">        public void queryTimer() throws InterruptedException &#123;</span><br><span class=\"line\">            int i = 1;</span><br><span class=\"line\">            while (Boolean.valueOf(mccClient.getValue(&quot;mcc_timer_query_switch&quot;))) &#123;</span><br><span class=\"line\">                CallbackLog callbackLog = callbackService.querybyid(i);</span><br><span class=\"line\">                if (callbackLog==null) &#123;</span><br><span class=\"line\">                    continue;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                LOGGER.warn(&quot;query timer, callbackInfo:&#123;&#125;&quot;, callbackLog.getId());</span><br><span class=\"line\">                ++i;</span><br><span class=\"line\">                if (Boolean.valueOf(mccClient.getValue(&quot;mcc_timer_sleep_switch&quot;))) &#123;</span><br><span class=\"line\">                    Thread.sleep(Long.valueOf(mccClient.getValue(&quot;mcc_timer_time_switch&quot;)));</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    class TimerR implements Runnable &#123;</span><br><span class=\"line\">        private TimerQ timerQ;</span><br><span class=\"line\"></span><br><span class=\"line\">        public TimerR(TimerQ timerQ) &#123;</span><br><span class=\"line\">            this.timerQ = timerQ;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        @Override</span><br><span class=\"line\">        public void run() &#123;</span><br><span class=\"line\">            try &#123;</span><br><span class=\"line\">                timerQ.queryTimer();</span><br><span class=\"line\">            &#125; catch (InterruptedException e) &#123;</span><br><span class=\"line\">                e.printStackTrace();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"二、3-重场景验证\">二、3 重场景验证<a title=\"#二、3-重场景验证\" href=\"#二、3-重场景验证\"></a></h3>\n<p>1、初始阶段<br>\nMySQL Statement Cancellation Timer 线程数为 0<br>\n2、高 qps——生成大量的 [MySQL Statement Cancellation Timer]<br>\nMySQL Statement Cancellation Timer 线程数为 50<br>\n3、低 qps——[MySQL Statement Cancellation Timer] 开始缩减<br>\nMySQL Statement Cancellation Timer 线程数为 35<br>\n4、无 qps——无 [MySQL Statement Cancellation Timer]<br>\nMySQL Statement Cancellation Timer 线程数为 0</p>\n<h3 id=\"三、上线效果展示\">三、上线效果展示<a title=\"#三、上线效果展示\" href=\"#三、上线效果展示\"></a></h3>\n<p>详见 OPENXXX 系统 DB 异常线程优化案——总结报告。一句话总结：DB 连接超时策略的引入，可以及时有效的关闭连接，进而关闭 [MySQL Statement Cancellation Timer]，使得 OPENXXX 系统线程表现出了良好的业务弹性，且未损失原有的 sql 性能。</p>\n<h2 id=\"个人总结：抽象提炼优化方法\">个人总结：抽象提炼优化方法<a title=\"#个人总结：抽象提炼优化方法\" href=\"#个人总结：抽象提炼优化方法\"></a></h2>\n<p>本次问题的表象是明确的，但掩藏的内核是艰深的。历经「三方包代码（原理）— jdbc（c3p0 文档）— mysql server(manual 文档) — openXXX(分析) — 测试（验证）」，个人尽力呈现本次优化实践从调研到上线的完整过程，亦收获良多。同时在这里抽象、提炼一下，主要是个人对于 DB 线程调优的提纲式整理，方便各位同学进行参考，寻找优化思路——<br>\n<img src=\"http://zeven.cpolar.cn/2024/07/202407062232736.png\" alt=\"\" loading=\"lazy\"></p>\n<h2 id=\"原文链接\">原文链接<a title=\"#原文链接\" href=\"#原文链接\"></a></h2>\n<p><a href=\"https://segmentfault.com/a/1190000020162800\" target=\"_blank\">一次数据库连接池优化的实践剖析</a></p>\n","prev":{"title":"JVM简述","link":"2024/08/15/JVM简述"},"next":{"title":"MySQL沉浸式面试","link":"2023/07/26/MySQL沉浸式面试"},"plink":"https://zinki.github.io/2023/08/20/一次数据库连接池优化的实践剖析/","toc":[{"id":"追根溯源：问题根源的分析定位","title":"\n\n追根溯源：问题根源的分析定位","index":"1","children":[{"id":"一、timer-线程生命周期","title":"一、Timer 线程生命周期","index":"1.1"},{"id":"二、生命周期详细解读","title":"二、生命周期详细解读","index":"1.2"},{"id":"三、核心问题总结定位","title":"三、核心问题总结定位","index":"1.3"}]},{"id":"超时策略：mysql-线程数下降的关键","title":"超时策略：MySQL 线程数下降的关键","index":"2","children":[{"id":"一、jdbc-层（c3p0）","title":"一、JDBC 层（c3p0）","index":"2.1"},{"id":"二、db-server-层","title":"二、DB Server 层","index":"2.2"},{"id":"三、超时策略探究总结","title":"三、超时策略探究总结","index":"2.3"}]},{"id":"系统分析：openxxx-的超时关闭策略","title":"系统分析：OPENXXX 的超时关闭策略","index":"3","children":[{"id":"一、jdbc-层（c3p0）-1","title":"一、JDBC 层（c3p0）","index":"3.1"},{"id":"二、db-server-层-1","title":"二、DB Server 层","index":"3.2"},{"id":"三、系统分析判断印证","title":"三、系统分析判断印证","index":"3.3"}]},{"id":"解决方案：恰当的超时关闭策略","title":"解决方案：恰当的超时关闭策略","index":"4","children":[{"id":"一、建议方案","title":"一、建议方案","index":"4.1"},{"id":"二、策略配置","title":"二、策略配置","index":"4.2"}]},{"id":"测试验证：超时策略的有效性验证","title":"测试验证：超时策略的有效性验证","index":"5","children":[{"id":"一、测试代码展示","title":"一、测试代码展示","index":"5.1"},{"id":"二、3-重场景验证","title":"二、3 重场景验证","index":"5.2"},{"id":"三、上线效果展示","title":"三、上线效果展示","index":"5.3"}]},{"id":"个人总结：抽象提炼优化方法","title":"个人总结：抽象提炼优化方法","index":"6"},{"id":"原文链接","title":"原文链接","index":"7"}]}