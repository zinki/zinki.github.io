{"title":"线程池及异步使用","date":"2021-08-29T11:30:00.000Z","date_formatted":{"ll":"2021年8月29日","L":"2021/08/29","MM-DD":"08-29"},"link":"2021/08/29/线程池及异步使用","tags":["线程池"],"categories":["工作"],"updated":"2024-10-11T02:20:25.402Z","content":"<p>异步执行程序在实践中经常使用，除Spring自带@Async注解外，可以通过自定义线程池来实现，自由度更高。<span id=\"more\"></span></p>\n<p><code>java</code><br>\n/**<br>\n* 线程池核心线程数<br>\n*/<br>\nprivate static int CORE_POOL_SIZE = 10;</p>\n<pre><code>private static ThreadPoolExecutor threadPoolExecutor;\n\nstatic &#123;\n    threadPoolExecutor = new ThreadPoolExecutor(CORE_POOL_SIZE, CORE_POOL_SIZE\n            , CardConstants.TEN, TimeUnit.SECONDS,\n            new LinkedBlockingQueue&lt;&gt;(),new ThreadFactoryBuilder().setNamePrefix(&quot;async-&quot;).build());\n&#125;\n\n\n/**\n * 异步执行方法\n * @param runnable\n * @return\n */\npublic static void execute(Runnable runnable) &#123;\n    threadPoolExecutor.execute(runnable);\n&#125;\n</code></pre>\n<pre><code>\n调试时注意到进程在执行完成后不会消亡\n\n### 原因\n\nJVM退出的条件是当前不存在用户线程，而线程池默认的ThreadFactory创建的线程是用户线程。\n\n首先我们需要了解线程池在什么情况下会自动关闭。**ThreadPoolExecutor** 类（这是我们最常用的线程池实现类）的源码注释中有这么一句话：\n\n&gt; A pool that is no longer referenced in a program and has no remaining threads will be shutdown automatically.\n&gt; \n&gt; 没有引用指向且没有剩余线程的线程池将会自动关闭。\n\n由于核心线程一直存在，所以线程池不会关闭。\n\n### 解决办法\n\n1. 手动关闭线程池 `threadPoolExecutor.shutdown();`\n\n2. 核心线程数量设置为0，超时时间后线程池会自动关闭\n\n3. 设置属性`allowCoreThreadTimeOut `来实现\n\n### 参考\n\n[Java 线程池会自动关闭吗](https://segmentfault.com/a/1190000021225019)\n\n[使用线程池时候当程序结束时候记得调用shutdown关闭线程池](https://cloud.tencent.com/developer/article/1330497)\n</code></pre>\n","prev":{"title":"PowerMock基础教程","link":"2021/09/15/PowerMock基础教程"},"next":{"title":"Git批量更新脚本","link":"2021/08/19/git批量更新脚本"},"plink":"https://zinki.github.io/2021/08/29/线程池及异步使用/"}