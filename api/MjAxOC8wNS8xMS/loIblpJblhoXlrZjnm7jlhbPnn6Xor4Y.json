{"title":"堆外内存相关知识","date":"2018-05-11T11:20:00.000Z","date_formatted":{"ll":"2018年5月11日","L":"2018/05/11","MM-DD":"05-11"},"link":"2018/05/11/堆外内存相关知识","tags":["堆外内存"],"categories":["学习"],"updated":"2024-10-11T08:03:54.461Z","content":"<p>堆外内存是把内存对象分配在Java虚拟机的堆以外的内存，这些内存直接受操作系统管理（而不是虚拟机），这样做的结果就是能够在一定程度上减少垃圾回收对应用程序造成的影响。<span id=\"more\"></span></p>\n<h2 id=\"定义\">定义<a title=\"#定义\" href=\"#定义\"></a></h2>\n<p>创建Java.nio.DirectByteBuffer时分配的内存。</p>\n<h2 id=\"优缺点\">优缺点<a title=\"#优缺点\" href=\"#优缺点\"></a></h2>\n<p>优点： 提升了IO效率（避免了数据从用户态向内核态的拷贝）；减少了GC次数（节约了大量的堆内内存）。<br>\n缺点：分配和回收堆外内存比分配和回收堆内存耗时；（解决方案：通过对象池避免频繁地创建和销毁堆外内存）</p>\n<h2 id=\"为什么堆外内存能够提升io效率？\">为什么堆外内存能够提升IO效率？<a title=\"#为什么堆外内存能够提升io效率？\" href=\"#为什么堆外内存能够提升io效率？\"></a></h2>\n<p>堆内内存由JVM管理，属于“用户态”；而堆外内存由OS管理，属于“内核态”。如果从堆内向磁盘写数据时，数据会被先复制到堆外内存，即内核缓冲区，然后再由OS写入磁盘，使用堆外内存避免了数据从用户内向内核态的拷贝。</p>\n<h2 id=\"申请\">申请<a title=\"#申请\" href=\"#申请\"></a></h2>\n<p>JDK的ByteBuffer类提供了一个接口allocateDirect(int capacity)进行堆外内存的申请，底层通过unsafe.allocateMemory(size)实现。Netty、Mina等框架提供的接口也是基于ByteBuffer封装的。</p>\n<h2 id=\"释放\">释放<a title=\"#释放\" href=\"#释放\"></a></h2>\n<p>JDK中使用DirectByteBuffer对象来表示堆外内存，每个DirectByteBuffer对象在初始化时，都会创建一个对应的Cleaner对象，用于保存堆外内存的元信息（开始地址、大小和容量等），当DirectByteBuffer被GC回收后，Cleaner对象被放入ReferenceQueue中，然后由ReferenceHandler守护线程调用unsafe.freeMemory(address)，回收堆外内存。</p>\n<h2 id=\"主动回收(推荐)\">主动回收(推荐)<a title=\"#主动回收(推荐)\" href=\"#主动回收(推荐)\"></a></h2>\n<p>对于Sun的JDK，只要从DirectByteBuffer里取出那个sun.misc.Cleaner，然后调用它的clean()就行；<br>\n基于 GC 回收：堆内的DirectByteBuffer对象被GC时，会调用cleaner回收其引用的堆外内存。问题是YGC只会将将新生代里的不可达的DirectByteBuffer对象及其堆外内存回收，如果有大量的DirectByteBuffer对象移到了old区，但是又一直没有做CMS GC或者FGC，而只进行YGC，物理内存会被慢慢耗光，触发OOM；</p>\n<h2 id=\"堆外内存溢出\">堆外内存溢出<a title=\"#堆外内存溢出\" href=\"#堆外内存溢出\"></a></h2>\n<p>Java.nio.DirectByteBuffer所需的内存超过了物理分配的堆外内存，出现”java.lang.OutOfMemoryError: Direct buffer memory”。</p>\n<h2 id=\"使用注意\">使用注意<a title=\"#使用注意\" href=\"#使用注意\"></a></h2>\n<p>java.nio.DirectByteBuffer对象在创建过程中会先通过Unsafe接口直接通过os::malloc来分配内存，然后将内存的起始地址和大小存到java.nio.DirectByteBuffer对象里，这样就可以直接操作这些内存。这些内存只有在DirectByteBuffer回收掉之后才有机会被回收，因此如果这些对象大部分都移到了old，但是一直没有触发CMS GC或者Full GC，那么悲剧将会发生，因为你的物理内存被他们耗尽了，因此为了避免这种悲剧的发生，通过-XX:MaxDirectMemorySize来指定最大的堆外内存大小，当使用达到了阈值的时候将调用System.gc来做一次full gc，以此来回收掉没有被使用的堆外内存。<br>\n堆外内存默认大小</p>\n<blockquote>\n<p>堆外内存默认值： (-Xmx值) - (1个survivor大小)</p>\n</blockquote>\n<h2 id=\"关于堆外内存的回收\">关于堆外内存的回收<a title=\"#关于堆外内存的回收\" href=\"#关于堆外内存的回收\"></a></h2>\n<p>堆外内存的回收其实依赖于我们的GC机制(堆外内存不会对GC造成什么影响)<br>\n首先我们要知道在java层面和我们在堆外分配的这块内存关联的只有与之关联的DirectByteBuffer对象了，它记录了这块内存的基地址以及大小，那么既然和GC也有关，那就是GC能通过操作DirectByteBuffer对象来间接操作对应的堆外内存了。<br>\nDirectByteBuffer对象在创建的时候关联了一个PhantomReference，说到PhantomReference它其实主要是用来跟踪对象何时被回收的，它不能影响GC决策.<br>\nGC过程中如果发现某个对象除了只有PhantomReference引用它之外，并没有其他的地方引用它了，那将会把这个引用放到java.lang.ref.Reference.pending队列里，在GC完毕的时候通知ReferenceHandler这个守护线程去执行一些后置处理, 而DirectByteBuffer关联的PhantomReference是PhantomReference的一个子类，在最终的处理里会通过Unsafe的free接口来释放DirectByteBuffer对应的堆外内存块</p>\n<blockquote>\n<p>为什么Cleaner对象能够被放入ReferenceQueue中？<br>\nCleaner对象关联了一个PhantomReference引用，如果GC过程中某个对象除了只有PhantomReference引用它之外，并没有其他地方引用它了，那将会把这个引用放到java.lang.ref.Reference.pending队列里，在GC完毕的时候通知ReferenceHandler这个守护线程去执行一些后置处理，在最终的处理里会通过Unsafe的free接口来释放DirectByteBuffer对应的堆外内存块。</p>\n</blockquote>\n<h2 id=\"为什么要主动调用system.gc\">为什么要主动调用System.gc<a title=\"#为什么要主动调用system.gc\" href=\"#为什么要主动调用system.gc\"></a></h2>\n<p>System.gc()会对新生代的老生代都会进行内存回收，这样会比较彻底地回收DirectByteBuffer对象以及他们关联的堆外内存.<br>\nDirectByteBuffer对象本身其实是很小的，但是它后面可能关联了一个非常大的堆外内存，因此我们通常称之为<code>冰山对象</code>.<br>\n我们做ygc的时候会将新生代里的不可达的DirectByteBuffer对象及其堆外内存回收了，但是无法对old里的DirectByteBuffer对象及其堆外内存进行回收，这也是我们通常碰到的最大的问题.<br>\n如果有大量的DirectByteBuffer对象移到了old，但是又一直没有做cms gc或者full gc，而只进行ygc，那么我们的物理内存可能被慢慢耗光，但是我们还不知道发生了什么，因为heap明明剩余的内存还很多(前提是我们禁用了System.gc – JVM参数DisableExplicitGC)。</p>\n","prev":{"title":"Java字节码相关知识","link":"2018/06/15/Java字节码相关知识"},"next":{"title":"Spring boot配置","link":"2018/04/09/Spring boot 配置"},"plink":"https://zinki.github.io/2018/05/11/堆外内存相关知识/","toc":[{"id":"定义","title":"定义","index":"1"},{"id":"优缺点","title":"优缺点","index":"2"},{"id":"为什么堆外内存能够提升io效率？","title":"为什么堆外内存能够提升IO效率？","index":"3"},{"id":"申请","title":"申请","index":"4"},{"id":"释放","title":"释放","index":"5"},{"id":"主动回收(推荐)","title":"主动回收(推荐)","index":"6"},{"id":"堆外内存溢出","title":"堆外内存溢出","index":"7"},{"id":"使用注意","title":"使用注意","index":"8"},{"id":"关于堆外内存的回收","title":"关于堆外内存的回收","index":"9"},{"id":"为什么要主动调用system.gc","title":"为什么要主动调用System.gc","index":"10"}]}