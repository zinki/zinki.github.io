{"title":"Zookeeper相关知识","date":"2019-05-21T02:00:00.000Z","date_formatted":{"ll":"2019年5月21日","L":"2019/05/21","MM-DD":"05-21"},"link":"2019/05/21/Zookeepe相关知识","tags":["Zookeeper"],"categories":["学习"],"updated":"2024-10-10T08:03:05.461Z","content":"<p>ZooKeeper是一个分布式开源框架，提供了协调分布式应用的基本服务，<span id=\"more\"></span>它向外部应用暴露一组通用服务——分布式同步（Distributed Synchronization）、命名服务（Naming Service）、集群维护（Group Maintenance）等，简化分布式应用协调及其管理的难度，提供高性能的分布式服务。ZooKeeper本身可以以Standalone模式安装运行，不过它的长处在于通过分布式ZooKeeper集群（一个Leader，多个Follower），基于一定的策略来保证ZooKeeper集群的稳定性和可用性，从而实现分布式应用的可靠性。</p>\n<p>Zookeeper 为分布式系统提供了高效可靠且易于使用的协同服务，它可以为分布式应用提供相当多的服务，诸如统一命名服务，配置管理，状态同步和组服务等。Zookeeper 接口简单，开发人员不必过多地纠结在分布式系统编程难于处理的同步和一致性问题上，你可以使用 Zookeeper 提供的现成(off-the-shelf)服务来实现分布式系统的配置管理，组管理，Leader 选举等功能。</p>\n<p>一般而言，Zookeeper 应用程序分为两部分，其中一部分维护与服务器端的连接，另外一部分监视 Znode 节点的数据。在本程序中，Executor 类负责维护 Zookeeper连接，DataMonitor 类监视 Zookeeper 目录树中的数据， 同时，Executor 包含了主线程和程序主要的执行逻辑，它负责少量的用户交互，以及与可执行程序的交互，该可执行程序接受你向它传入的参数，并且会根据被监视的 Znode 节点的状态变化停止或重启。</p>\n<p>zookeeper是以Fast Paxos算法为基础，paxos算法存在活锁的问题，即当有多个proposer交错提交时，有可能互相排斥导致没有一个proposer能提交成功，而Fase Paxos作了一些优化，通过选举产生一个leader，只有leader才能提交proposer，具体的可以看一下Fast Paxos算法。</p>\n<p>简单的选举算法可以依赖很多计算机硬件因素作为选举因子，比如IP地址、CPU核数、内存大小、自定义序列号等等，比如采用自定义序列号</p>\n<p>Zookeeper通过心跳检测客户端是否存活,心跳出现超时可能是master挂了，但是也可能是master，Zookeeper之间网络出现了问题，这种情况就是假死，Zookeeper认为其挂掉了然后通知其他节点进行切换，这样slaver中就有一个成为了master，但是原本的master并未死掉,client也获得master切换的消息，但是仍然会有一些延时,导致短时间内出现数据同步问题,这种情况叫作脑裂</p>\n<p>避免方法是在slaver切换的时候不在检查到老的master出现问题后马上切换，而是在休眠一段足够的时间，确保老的master已经获知变更并且做了相关的shutdown清理工作了然后再注册成为master就能避免这类问题了，这个休眠时间一般定义为与Zookeeper定义的超时时间就够了，但是这段时间内系统不可用了。</p>\n<p>拜占庭问题<br>\n原始问题起源于东罗马帝国（拜占庭帝国）。拜占庭帝国国土辽阔，为了防御目的，每支军队都分隔很远，将军之间只能依靠信差传信。在战争的时候，拜占庭军队内所有司令和将军必需达成一致的共识，决定是否有赢的机会才去攻打敌人的阵营。但是，在军队内有可能存有叛徒和敌军的间谍，左右将军们的决定又扰乱整体军队的秩序。因此表决的结果并不一定能代表大多数人的意见。这时候，在已知有成员谋反的情况下，其余忠诚的将军在不受叛徒的影响下如何达成一致的协议，拜占庭问题就此形成。</p>\n<p>三模冗余系统简称TMR(Triple Modular Redundancy)，是最常用的一种容错设计技术．三个模块同时执行相同的操作，以多数相同的输出作为表决系统的正确输出，通常称为三取二,三个模块相互独立<br>\nZooKeeper并没有完全采用Paxos算法，而是使用了一种称为ZooKeeper Atomic Broadcast（ZAB，ZooKeeper原子消息广播协议）的协议作为其数据一致性的核心算法。</p>\n<p>ZooKeeper具有以下两大特性<br>\n客户端如果对 ZooKeeper 的一个数据节点注册 Watcher 监听, 那么当该数据节点的内容或是其子节点列表发生变更时- Z00Keeper服务器就会向订阅的客户端发送变更通知。<br>\n对在 ZooKeeper上创建的临时节点, 一旦客户端与服务器之间的会话失效, 那么该临时节点也就被自动清除。</p>\n<p>Java Api基本操作</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 创建一个与服务器的连接</span><br><span class=\"line\"> ZooKeeper zk = new ZooKeeper(&quot;localhost:&quot; + CLIENT_PORT,</span><br><span class=\"line\">        ClientBase.CONNECTION_TIMEOUT, new Watcher() &#123;</span><br><span class=\"line\">            // 监控所有被触发的事件</span><br><span class=\"line\">            public void process(WatchedEvent event) &#123;</span><br><span class=\"line\">                System.out.println(&quot;已经触发了&quot; + event.getType() + &quot;事件！&quot;);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\"> // 创建一个目录节点</span><br><span class=\"line\"> zk.create(&quot;/testRootPath&quot;, &quot;testRootData&quot;.getBytes(), Ids.OPEN_ACL_UNSAFE,</span><br><span class=\"line\">   CreateMode.PERSISTENT);</span><br><span class=\"line\"> // 创建一个子目录节点</span><br><span class=\"line\"> zk.create(&quot;/testRootPath/testChildPathOne&quot;, &quot;testChildDataOne&quot;.getBytes(),</span><br><span class=\"line\">   Ids.OPEN_ACL_UNSAFE,CreateMode.PERSISTENT);</span><br><span class=\"line\"> System.out.println(new String(zk.getData(&quot;/testRootPath&quot;,false,null)));</span><br><span class=\"line\"> // 取出子目录节点列表</span><br><span class=\"line\"> System.out.println(zk.getChildren(&quot;/testRootPath&quot;,true));</span><br><span class=\"line\"> // 修改子目录节点数据</span><br><span class=\"line\"> zk.setData(&quot;/testRootPath/testChildPathOne&quot;,&quot;modifyChildDataOne&quot;.getBytes(),-1);</span><br><span class=\"line\"> System.out.println(&quot;目录节点状态：[&quot;+zk.exists(&quot;/testRootPath&quot;,true)+&quot;]&quot;);</span><br><span class=\"line\"> // 创建另外一个子目录节点</span><br><span class=\"line\"> zk.create(&quot;/testRootPath/testChildPathTwo&quot;, &quot;testChildDataTwo&quot;.getBytes(),</span><br><span class=\"line\">   Ids.OPEN_ACL_UNSAFE,CreateMode.PERSISTENT);</span><br><span class=\"line\"> System.out.println(new String(zk.getData(&quot;/testRootPath/testChildPathTwo&quot;,true,null)));</span><br><span class=\"line\"> // 删除子目录节点</span><br><span class=\"line\"> zk.delete(&quot;/testRootPath/testChildPathTwo&quot;,-1);</span><br><span class=\"line\"> zk.delete(&quot;/testRootPath/testChildPathOne&quot;,-1);</span><br><span class=\"line\"> // 删除父目录节点</span><br><span class=\"line\"> zk.delete(&quot;/testRootPath&quot;,-1);</span><br><span class=\"line\"> // 关闭连接</span><br><span class=\"line\"> zk.close();</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>","prev":{"title":"ElasticSearch相关知识","link":"2019/06/15/ElasticSearch相关知识"},"next":{"title":"JVM调优","link":"2019/04/15/JVM调优"},"plink":"https://zinki.github.io/2019/05/21/Zookeepe相关知识/"}