{"title":"循环链表实践","date":"2022-01-20T03:35:00.000Z","date_formatted":{"ll":"2022年1月20日","L":"2022/01/20","MM-DD":"01-20"},"link":"2022/01/20/循环链表实践","tags":["加密","链表"],"categories":["工作"],"updated":"2024-10-11T02:21:23.248Z","content":"<p>工作中涉及到针对证件号做软加密需求，要求是密文必须唯一，开始是通过数据库去重来实现，每次都要去数据库查询是否存在，存在的话重新生成，直到生成可用密文，这样有性能瓶颈。</p>\n<p>需要更换密文生成方式，后采用根据字符映射的方式，鉴于过于简单，所以添加偏移量增加复杂度。经过评估，双向循环链表很适合这种场景。<span id=\"more\"></span></p>\n<h3 id=\"节点信息\">节点信息<a title=\"#节点信息\" href=\"#节点信息\"></a></h3>\n<p><code>java</code><br>\n/**<br>\n* 源数据<br>\n<em>/<br>\npublic Character sourceData;<br>\n/</em>*<br>\n* 目标数据<br>\n<em>/<br>\npublic Character targetData;<br>\n/</em>*<br>\n* 上一个节点<br>\n<em>/<br>\npublic Node previous;<br>\n/</em>*<br>\n* 下一个节点<br>\n*/<br>\npu</p>\n<pre><code>blic Node next;\n</code></pre>\n<h3 id=\"添加节点\">添加节点<a title=\"#添加节点\" href=\"#添加节点\"></a></h3>\n<pre><code>/**\n * 添加元素\n * @param sourceData\n * @param targetData\n * @return\n */\npublic Node add(Character sourceData,Character targetData)&#123;\n    Node newNode = new Node(sourceData,targetData);\n    if(size == 0)&#123;\n        head = newNode;\n        head.next = head;\n        head.previous = head;\n    &#125;else&#123;\n        Node target = head;\n        while(target.next!=head)&#123;\n            target = target.next;\n        &#125;\n        target.next = newNode;\n        newNode.previous = target;\n        newNode.next = head;\n        head.previous = newNode;\n    &#125;\n    size++;\n    return newNode;\n&#125;\n</code></pre>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">### 定位节点</span><br><span class=\"line\"></span><br><span class=\"line\">```java</span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * 返回指定元素</span><br><span class=\"line\">     * @return</span><br><span class=\"line\">     */</span><br><span class=\"line\">    public Node findSourceNode(Character obj,int offset)&#123;</span><br><span class=\"line\">        Node target = head;</span><br><span class=\"line\">        while(target.next!=null)&#123;</span><br><span class=\"line\">            if(obj.equals(target.sourceData))&#123;</span><br><span class=\"line\">                return getNext(target,offset);</span><br><span class=\"line\">            &#125;else&#123;</span><br><span class=\"line\">                target = target.next;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return null;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * 返回指定元素</span><br><span class=\"line\">     * @return</span><br><span class=\"line\">     */</span><br><span class=\"line\">    public Node findTargetNode(Character obj,int offset)&#123;</span><br><span class=\"line\">        Node target = head;</span><br><span class=\"line\">        while(target.next!=null)&#123;</span><br><span class=\"line\">            if(obj.equals(target.targetData))&#123;</span><br><span class=\"line\">                return getPrevious(target,offset);</span><br><span class=\"line\">            &#125;else&#123;</span><br><span class=\"line\">                target = target.next;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return null;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>经过测试完全满足加解密需求</p>\n<h2 id=\"参考\">参考<a title=\"#参考\" href=\"#参考\"></a></h2>\n<p><a href=\"https://cloud.tencent.com/developer/article/1442643\" target=\"_blank\">数据结构Java实现：循环链表和双向链表 - 云+社区 - 腾讯云</a></p>\n","prev":{"title":"Luhn算法使用","link":"2022/02/21/Luhn算法使用"},"next":{"title":"Markdown图片解析","link":"2022/01/11/Markdown图片解析"},"plink":"https://zinki.github.io/2022/01/20/循环链表实践/","toc":[{"id":"节点信息","title":"节点信息","index":"1"},{"id":"添加节点","title":"添加节点","index":"2"}]}