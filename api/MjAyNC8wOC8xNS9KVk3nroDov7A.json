{"title":"JVM简述","date":"2024-08-15T07:10:00.000Z","date_formatted":{"ll":"2024年8月15日","L":"2024/08/15","MM-DD":"08-15"},"link":"2024/08/15/JVM简述","tags":["JVM"],"categories":["学习"],"updated":"2024-10-11T08:54:29.097Z","content":"<p>一、什么是JVM</p>\n<p>JVM是Java Virtual Machine（Java 虚拟机）的缩写，JVM是一种用于计算设备的规范，它是一个虚构出来的计算机，是通过在实际的计算机上仿真模拟各种计算机功能来实现的。</p>\n<span id=\"more\"></span>\n<p>Java语言的一个非常重要的特点就是平台无关性。而使用Java虚拟机是实现这一特点的关键。一般的高级语言如果要在不同的平台上运行，至少需要编译成不同的目标代码。而引入Java语言虚拟机后，Java语言在不同平台上运行时不需要重新编译。Java语言使用Java虚拟机屏蔽了与具体平台相关的信息，使得Java语言编译程序只需生成在Java虚拟机上运行的目标代码（字节码），就可以在多种平台上不加修改地运行。Java虚拟机在执行字节码时，把字节码解释成具体平台上的机器指令执行。这就是Java的能够“一次编译，到处运行”的原因。</p>\n<p>二、JVM总体概述</p>\n<p>JVM总体上是由类装载子系统（ClassLoader）、运行时数据区、执行引擎、垃圾收集这四个部分组成。其中我们最为关注的运行时数据区，也就是JVM的内存部分则是由方法区（Method Area）、JAVA堆（Java Heap）、虚拟机栈（JVM Stack）、程序计数器、本地方法栈（Native Method Stack）这几部分组成。</p>\n<p>三、JVM体系结构<br>\n<img src=\"http://zeven.cpolar.cn/2023/05/20230504110143.png\" alt=\"\" loading=\"lazy\"></p>\n<p>3.1 类装载子系统</p>\n<p>Class Loader类加载器负责加载.class文件，class文件在文件开头有特定的文件标示，并且ClassLoader负责class文件的加载等，至于它是否可以运行，则由Execution Engine决定。</p>\n<p>3.2 运行时数据区</p>\n<p>栈管运行，堆管存储。JVM调优主要是优化Java堆和方法区。</p>\n<p>3.2.1 方法区(Method Area)</p>\n<p>方法区是各线程共享的内存区域，它用于存储已被JVM加载的类信息、常量、静态变量、运行时常量池等数据。</p>\n<p>3.2.2 Java堆(Java Heap)</p>\n<p>Java堆是各线程共享的内存区域，在JVM启动时创建，这块区域是JVM中最大的， 用于存储应用的对象和数组，也是GC主要的回收区，一个 JVM 实例只存在一个堆内存，堆内存的大小是可以调节的。类加载器读取了类文件后，需要把类、方法、常变量放到堆内存中，以方便执行器执行，堆内存分为三部分：新生代、老年代、永久代。</p>\n<p>说明：</p>\n<ul>\n<li>Jdk1.6及之前：常量池分配在永久代 。</li>\n<li>Jdk1.7：有，但已经逐步“去永久代” 。</li>\n<li>Jdk1.8及之后：无永久代，改用元空间代替(java.lang.OutOfMemoryError: PermGen space,这种错误将不会出现在JDK1.8中)。</li>\n</ul>\n<p>3.2.3 Java栈(JVM Stack)</p>\n<ol>\n<li>栈是什么</li>\n</ol>\n<p>Java栈是线程私有的，是在线程创建时创建，它的生命期是跟随线程的生命期，线程结束栈内存也就释放，对于栈来说不存在垃圾回收问题，只要线程一结束该栈就Over，生命周期和线程一致。基本类型的变量和对象的引用变量都是在函数的栈内存中分配。</p>\n<ol>\n<li>栈存储什么</li>\n</ol>\n<p>每个方法执行的时候都会创建一个栈帧，栈帧中主要存储3类数据：</p>\n<ul>\n<li>局部变量表：输入参数和输出参数以及方法内的变量；</li>\n<li>栈操作：记录出栈和入栈的操作；</li>\n<li>栈帧数据：包括类文件、方法等等。</li>\n</ul>\n<ol>\n<li>栈运行原理</li>\n</ol>\n<p>栈中的数据都是以栈帧的格式存在，栈帧是一个内存区块，是一个数据集，是一个有关方法和运行期数据的数据集。每一个方法被调用直至执行完成的过程，就对应着一个栈帧在栈中从入栈到出栈的过程。</p>\n<p><img src=\"http://zeven.cpolar.cn/2023/05/20230504110229.png\" alt=\"\" loading=\"lazy\" class=\"φbp\"></p>\n<ol>\n<li>本地方法栈(Native Method Stack)</li>\n</ol>\n<p>本地方法栈和JVM栈发挥的作用非常相似，也是线程私有的，区别是JVM栈为JVM执行Java方法（也就是字节码）服务，而本地方法栈为JVM使用到的Native方法服务。它的具体做法是在本地方法栈中登记native方法，在执行引擎执行时加载Native Liberies.有的虚拟机（比如Sun Hotpot）直接把两者合二为一。</p>\n<ol>\n<li>\n<p>程序计数器(Program Counter Register)<br>\n程序计数器是一块非常小的内存空间，几乎可以忽略不计，每个线程都有一个程序计算器，是线程私有的，可以看作是当前线程所执行的字节码的行号指示器，指向方法区中的方法字节码（下一个将要执行的指令代码），由执行引擎读取下一条指令。</p>\n</li>\n<li>\n<p>运行时常量池<br>\n运行时常量池是方法区的一部分，用于存放编译器生成的各种字面量和符号引用，这部分内容将在类加载后存放到方法区的运行时常量池中。相较于Class文件常量池，运行时常量池更具动态性，在运行期间也可以将新的变量放入常量池中，而不是一定要在编译时确定的常量才能放入。最主要的运用便是String类的intern()方法。</p>\n</li>\n</ol>\n<p><img src=\"http://zeven.cpolar.cn/2023/05/20230504110301.png\" alt=\"\" loading=\"lazy\" class=\"φbp\"></p>\n<p>3.3 执行引擎(Execution Engine)</p>\n<p>执行引擎执行包在装载类的方法中的指令，也就是方法。执行引擎以指令为单位读取Java字节码。它就像一个CPU一样，一条一条地执行机器指令。每个字节码指令都由一个1字节的操作码和附加的操作数组成。执行引擎取得一个操作码，然后根据操作数来执行任务，完成后就继续执行下一条操作码。</p>\n<p>不过Java字节码是用一种人类可以读懂的语言编写的，而不是用机器可以直接执行的语言。因此，执行引擎必须把字节码转换成可以直接被JVM执行的语言。字节码可以通过以下两种方式转换成合适的语言：</p>\n<ul>\n<li>解释器： 一条一条地读取，解释并执行字节码执行，所以它可以很快地解释字节码，但是执行起来会比较慢。这是解释执行语言的一个缺点。</li>\n<li>即时编译器：用来弥补解释器的缺点，执行引擎首先按照解释执行的方式来执行，然后在合适的时候，即时编译器把整段字节码编译成本地代码。然后，执行引擎就没有必要再去解释执行方法了，它可以直接通过本地代码去执行。执行本地代码比一条一条进行解释执行的速度快很多，编译后的代码可以执行的很快，因为本地代码是保存在缓存里的。</li>\n</ul>\n<p><img src=\"http://zeven.cpolar.cn/2023/05/20230504110338.png\" alt=\"\" loading=\"lazy\" class=\"φbp\"></p>\n<p>3.4 垃圾收集(Garbage Collection, GC)</p>\n<p>3.4.1 什么是垃圾收集</p>\n<p>垃圾收集即垃圾回收，简单的说垃圾回收就是回收内存中不再使用的对象。所谓使用中的对象（已引用对象），指的是程序中有指针指向的对象；而未使用中的对象（未引用对象），则没有被任何指针给指向，因此占用的内存也可以被回收掉。</p>\n<p>垃圾回收的基本步骤分两步：</p>\n<ul>\n<li>查找内存中不再使用的对象（GC判断策略）</li>\n<li>释放这些对象占用的内存（GC收集算法）</li>\n</ul>\n<p>3.4.2 GC判断策略</p>\n<ol>\n<li>\n<p>引用计数算法<br>\n引用计数算法是给对象添加一个引用计数器，每当有一个引用它时，计数器值就加1；当引用失效时，计数器值就减1；任何时刻计数器都为0的对象就是不可能再被使用的对象。缺点：很难解决对象之间相互循环引用的问题。</p>\n</li>\n<li>\n<p>根搜索算法<br>\n根搜索算法的基本思路就是通过一系列名为“GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链（Reference Chain），当一个对象到GC Roots没有任何引用链相连（也就是说从GC Roots到这个对象不可达）时，则证明此对象是不可用的。</p>\n</li>\n</ol>\n<p>在Java语言里，可作为GC Roots的对象包括以下几种：</p>\n<ul>\n<li>虚拟机栈（栈帧中的本地变量表）中引用的对象；</li>\n<li>方法区中类静态属性引用的对象；</li>\n<li>方法区中常量应用的对象；</li>\n<li>本地方法栈中JNI（Native方法）引用的对象。</li>\n</ul>\n<p><img src=\"http://zeven.cpolar.cn/2023/05/20230504110406.png\" alt=\"\" loading=\"lazy\" class=\"φbp\"></p>\n<p>注：在根搜索算法中不可达的对象，也并非是“非死不可”的，因为要真正宣告一个对象死亡，至少要经历两次标记过程：第一次是标记没有与GC Roots相连接的引用链；第二次是GC对在F-Queue执行队列中的对象进行的小规模标记(对象需要覆盖finalize()方法且没被调用过)。</p>\n<p>3.4.3 GC收集算法</p>\n<ol>\n<li>标记-清除算法（Mark-Sweep）</li>\n</ol>\n<p>标记-清楚算法采用从根集合（GC Roots）进行扫描，首先标记出所有需要回收的对象（根搜索算法），标记完成后统一回收掉所有被标记的对象。</p>\n<p><img src=\"http://zeven.cpolar.cn/2023/05/20230504110455.png\" alt=\"\" loading=\"lazy\" class=\"φbp\"></p>\n<p>该算法有两个问题：</p>\n<ul>\n<li>效率问题：标记和清除过程的效率都不高；</li>\n<li>空间问题：标记清除后会产生大量不连续的内存碎片, 空间碎片太多可能会导致在运行过程中需要分配较大对象时无法找到足够的连续内存而不得不提前触发另一次垃圾收集。</li>\n</ul>\n<ol start=\"2\">\n<li>复制算法（Copying）</li>\n</ol>\n<p>复制算法是将可用内存按容量划分为大小相等的两块, 每次只用其中一块, 当这一块的内存用完, 就将还存活的对象复制到另外一块上面, 然后把已使用过的内存空间一次清理掉。</p>\n<p><img src=\"http://zeven.cpolar.cn/2023/05/20230504110519.png\" alt=\"\" loading=\"lazy\" class=\"φbp\"></p>\n<ol start=\"3\">\n<li>标记-整理算法（Mark-Compact）</li>\n</ol>\n<p>标记整理算法的标记过程与标记清除算法相同, 但后续步骤不再对可回收对象直接清理, 而是让所有存活的对象都向一端移动,然后清理掉端边界以外的内存。</p>\n<p><img src=\"http://zeven.cpolar.cn/2023/12/20231208213418.png\" alt=\"\" loading=\"lazy\" class=\"φbp\"></p>\n<ol start=\"4\">\n<li>分代收集算法（Generational Collection）</li>\n</ol>\n<p>分代收集算法是目前大部分JVM的垃圾收集器采用的算法。它的核心思想是根据对象存活的生命周期将内存划分为若干个不同的区域。一般情况下将堆区划分为老年代（Tenured Generation）和新生代（Young Generation），在堆区之外还有一个代就是永久代（Permanet Generation）。老年代的特点是每次垃圾收集时只有少量对象需要被回收，而新生代的特点是每次垃圾回收时都有大量的对象需要被回收，那么就可以根据不同代的特点采取最适合的收集算法。</p>\n<p><img src=\"http://zeven.cpolar.cn/2023/05/20230504110614.png\" alt=\"\" loading=\"lazy\" class=\"φbp\"></p>\n<p>新生代（Young Generation）的回收算法（以复制算法为主）</p>\n<ul>\n<li>所有新生成的对象首先都是放在年轻代的。年轻代的目标就是尽可能快速的收集掉那些生命周期短的对象。</li>\n<li>新生代内存按照8:1:1的比例分为一个eden区和两个survivor(survivor0,survivor1)区。一个Eden区，两个 Survivor区(一般而言)。大部分对象在Eden区中生成。回收时先将eden区存活对象复制到一个survivor0区，然后清空eden区，当这个survivor0区也存放满了时，则将eden区和survivor0区存活对象复制到另一个survivor1区，然后清空eden和这个survivor0区，此时survivor0区是空的，然后将survivor0区和survivor1区交换，即保持survivor1区为空， 如此往复。</li>\n<li>当survivor1区不足以存放 eden和survivor0的存活对象时，就将存活对象直接存放到老年代。若是老年代也满了就会触发一次Full GC(Major GC)，也就是新生代、老年代都进行回收。</li>\n<li>新生代发生的GC也叫做Minor GC，MinorGC发生频率比较高(不一定等Eden区满了才触发)。</li>\n</ul>\n<p>老年代（Tenured Generation）的回收算法（以标记-清除、标记-整理为主）</p>\n<ul>\n<li>在年轻代中经历了N次垃圾回收后仍然存活的对象，就会被放到老年代中。因此，可以认为老年代中存放的都是一些生命周期较长的对象。</li>\n<li>内存比新生代也大很多(大概比例是1:2)，当老年代内存满时触发Major GC即Full GC，Full GC发生频率比较低，老年代对象存活时间比较长，存活率标记高。</li>\n</ul>\n<p>永久代（Permanet Generation）的回收算法</p>\n<p>用于存放静态文件，如Java类、方法等。永久代对垃圾回收没有显著影响，但是有些应用可能动态生成或者调用一些class，例如Hibernate 等，在这种时候需要设置一个比较大的永久代空间来存放这些运行过程中新增的类。永久代也称方法区。方法区主要回收的内容有：废弃常量和无用的类。对于废弃常量也可通过根搜索算法来判断，但是对于无用的类则需要同时满足下面3个条件：</p>\n<ul>\n<li>该类所有的实例都已经被回收，也就是Java堆中不存在该类的任何实例；</li>\n<li>加载该类的ClassLoader已经被回收；</li>\n<li>该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。</li>\n</ul>\n<p>3.4.4 垃圾收集器</p>\n<ol>\n<li>Serial收集器（复制算法)</li>\n</ol>\n<p>新生代单线程收集器，标记和清理都是单线程，优点是简单高效。是client级别默认的GC方式，可以通过-XX:+UseSerialGC来强制指定。</p>\n<ol start=\"2\">\n<li>Serial Old收集器(标记-整理算法)</li>\n</ol>\n<p>老年代单线程收集器，Serial收集器的老年代版本。</p>\n<ol start=\"3\">\n<li>ParNew收集器(停止-复制算法)</li>\n</ol>\n<p>新生代多线程收集器，其实就是Serial收集器的多线程版本,在多核CPU环境下有着比Serial更好的表现。</p>\n<ol start=\"4\">\n<li>Parallel Scavenge收集器(停止-复制算法)</li>\n</ol>\n<p>新生代并行的多线程收集器，追求高吞吐量，高效利用CPU。吞吐量一般为99%， 吞吐量= 用户线程时间/(用户线程时间+GC线程时间)。适合后台应用等对交互相应要求不高的场景。是server级别默认采用的GC方式，可用-XX:+UseParallelGC来强制指定，用-XX:ParallelGCThreads=4来指定线程数。</p>\n<ol start=\"5\">\n<li>Parallel Old收集器(停止-复制算法)</li>\n</ol>\n<p>老年代并行的多线程收集器，Parallel Scavenge收集器的老年代版本，并行收集器，吞吐量优先。</p>\n<ol start=\"6\">\n<li>CMS(Concurrent Mark Sweep)收集器（标记-清除算法）</li>\n</ol>\n<p>CMS收集器是一种以获取最短回收停顿时间为目标的收集器，CMS收集器是基于“标记–清除”(Mark-Sweep)算法实现的，整个过程分为四个步骤：</p>\n<ul>\n<li>初始标记： 标记GC Roots能直接关联到的对象，速度很快；</li>\n<li>并发标记： 进行GC Roots Tracing的过程；</li>\n<li>重新标记： 修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段稍长一些，但比并发标记时间短；</li>\n<li>并发清除： 整个过程中耗时最长的并发标记和并发清除过程收集器线程都可以与用户线程一起工作，所以，从总体上来说，CMS收集器的内存回收过程是与用户线程一起并发执行的。</li>\n<li>优点：并发收集、低停顿</li>\n<li>缺点：对CPU资源非常敏感、无法处理浮动垃圾、产生大量空间碎片。</li>\n</ul>\n<ol start=\"7\">\n<li>G1(Garbage First)收集器（标记-整理算法）</li>\n</ol>\n<p>G1是一款面向服务端应用的垃圾收集器，是基于“标记-整理”算法实现的，与其他GC收集器相比，G1具备如下特点：</p>\n<ul>\n<li>并行与并发</li>\n<li>分代收集</li>\n<li>空间整合</li>\n<li>可预测性的停顿</li>\n</ul>\n<p>G1运作步骤：</p>\n<ul>\n<li>初始标记(stop the world事件，CPU停顿只处理垃圾)</li>\n<li>并发标记(与用户线程并发执行)</li>\n<li>最终标记(stop the world事件，CPU停顿处理垃圾)</li>\n<li>筛选回收(stop the world事件，根据用户期望的GC停顿时间回收)</li>\n</ul>\n<p>3.4.5 垃圾收集结构图<br>\n<img src=\"http://zeven.cpolar.cn/2023/05/20230504110645.png\" alt=\"\" loading=\"lazy\"></p>\n","next":{"title":"一次数据库连接池优化的实践剖析","link":"2023/08/20/一次数据库连接池优化的实践剖析"},"plink":"https://zinki.github.io/2024/08/15/JVM简述/"}